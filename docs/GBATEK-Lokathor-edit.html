<!DOCTYPE html> <html class="rdgual idc0_338" style lang=en-US><!--
 Page saved with SingleFile 
 url: https://rust-console.github.io/gbatek-gbaonly/ 
 saved date: Wed Sep 28 2022 19:22:25 GMT+0200 (Central European Summer Time)
--><meta charset=utf-8>
<meta http-equiv=X-UA-Compatible content="IE=edge">
<meta name=viewport content="width=device-width, initial-scale=1">
<title>gbatek-gbaonly | GBATEK Markdown Fork, GBA only</title>
<meta name=generator content="Jekyll v3.8.5">
<meta property=og:title content=gbatek-gbaonly>
<meta property=og:locale content=en_US>
<meta name=description content="GBATEK Markdown Fork, GBA only">
<meta property=og:description content="GBATEK Markdown Fork, GBA only">
<link rel=canonical href=https://rust-console.github.io/gbatek-gbaonly/>
<meta property=og:url content=https://rust-console.github.io/gbatek-gbaonly/>
<meta property=og:site_name content=gbatek-gbaonly>
<script type=application/ld+json>{"@type":"WebSite","headline":"gbatek-gbaonly","url":"https://rust-console.github.io/gbatek-gbaonly/","name":"gbatek-gbaonly","description":"GBATEK Markdown Fork, GBA only","@context":"http://schema.org"}</script>
<style>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}a{background-color:transparent}a:active,a:hover{outline-width:0}h1{margin:0.67em 0}hr{box-sizing:content-box}::-webkit-input-placeholder{color:inherit;opacity:0.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}*{box-sizing:border-box}body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";font-size:14px;line-height:1.5;color:#24292e;background-color:#fff}a{color:#0366d6;text-decoration:none}a:hover{text-decoration:underline}strong{font-weight:600}hr{overflow:hidden;background:transparent;border-bottom:1px solid #dfe2e5}hr::before,.rule::before{display:table;content:""}hr::after,.rule::after{display:table;clear:both;content:""}code{font-family:"SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace}pre{font-family:"SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace}@keyframes fade-in{0%{opacity:0}100%{opacity:1}}@keyframes fade-out{0%{opacity:1}100%{opacity:0}}@keyframes fade-up{0%{opacity:0.8;transform:translateY(100%)}100%{opacity:1;transform:translateY(0)}}@keyframes fade-down{0%{opacity:1;transform:translateY(0)}100%{opacity:0.5;transform:translateY(100%)}}@keyframes grow-x{to{width:100%}}@keyframes shrink-x{to{width:0%}}@keyframes scale-in{0%{opacity:0;transform:scale(0.5)}100%{opacity:1;transform:scale(1)}}@keyframes pulse{0%{opacity:0.3}10%{opacity:1}100%{opacity:0.3}}@keyframes pulse-in{0%{transform:scale3d(1,1,1)}50%{transform:scale3d(1.1,1.1,1.1)}100%{transform:scale3d(1,1,1)}}.my-5{margin-top:32px!important;margin-bottom:32px!important}.px-3{padding-right:16px!important;padding-left:16px!important}.container-lg{max-width:1012px;margin-right:auto;margin-left:auto}.markdown-body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body::before{display:table;content:""}.markdown-body::after{display:table;clear:both;content:""}.markdown-body>*:first-child{margin-top:0!important}.markdown-body>*:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body p,.markdown-body ul,.markdown-body ol,.markdown-body pre{margin-top:0;margin-bottom:16px}.markdown-body hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}.markdown-body h1,.markdown-body h2,.markdown-body h3{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.markdown-body h1{padding-bottom:0.3em;font-size:2em;border-bottom:1px solid #eaecef}.markdown-body h2{padding-bottom:0.3em;font-size:1.5em;border-bottom:1px solid #eaecef}.markdown-body h3{font-size:1.25em}.markdown-body ul,.markdown-body ol{padding-left:2em}.markdown-body ul ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body code{border-radius:3px}.markdown-body pre{word-wrap:normal}.markdown-body pre>code{font-size:100%;word-break:normal;white-space:pre;background:transparent}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}.markdown-body pre code{display:inline;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.highlight{background-color:#f8f8f8}</style>
<link type=image/x-icon rel="shortcut icon" href="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><style>.sf-hidden{display:none!important}</style><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:;"></head>
 <body>
 <div class="container-lg px-3 my-5 markdown-body">
 
 <h1><a href=https://rust-console.github.io/gbatek-gbaonly/>gbatek-gbaonly</a></h1>
 
 <p><a name=contents></a><a name=gbatek></a></p>
<h1 id=gbatek---gba-only>GBATEK - GBA Only</h1>
<p>Gameboy Advance Technical Info - Extracted from no$gba version 2.9b</p>
<h2 id=about-this-fork>About This Fork</h2>
<p><strong>THIS DOCUMENT IS ONLY THE GBA PORTION OF GBATEK</strong></p>
<ul>
 <li>The <a href=https://mgba-emu.github.io/gbatek/>full markdown fork</a> has the entire document in markdown form.</li>
 <li>The <a href=https://problemkaputt.de/gbatek.htm>full original version</a> is in HTML form.</li>
</ul>
<p>I started with the full markdown and then just deleted sections that were
obviously not needed for GBA development. The goal is to have a significantly
smaller document that’s easier for browsers to render and search through.
Without the DS and DSi content it’s about 1/6th as large as the full thing.</p>
<p>Not every non-GBA bit of info has been removed. <a href=https://github.com/rust-console/gbatek-gbaonly/pulls>PRs
welcome</a> if you want to
improve this document further.</p>
<p><a href=#aboutthisdocument>About this Document</a></p>
<h2 id=gba-reference>GBA Reference</h2>
<h3 id=overview>Overview</h3>
<ul>
 <li><a href=#gbatechnicaldata>GBA Technical Data</a></li>
 <li><a href=#gbamemorymap>GBA Memory Map</a></li>
 <li><a href=#gbaiomap>GBA I/O Map</a></li>
</ul>
<h3 id=hardware-programming>Hardware Programming</h3>
<ul>
 <li><a href=#gbalcdvideocontroller>GBA LCD Video Controller</a></li>
 <li><a href=#gbasoundcontroller>GBA Sound Controller</a></li>
 <li><a href=#gbatimers>GBA Timers</a></li>
 <li><a href=#gbadmatransfers>GBA DMA Transfers</a></li>
 <li><a href=#gbacommunicationports>GBA Communication Ports</a></li>
 <li><a href=#gbakeypadinput>GBA Keypad Input</a></li>
 <li><a href=#gbainterruptcontrol>GBA Interrupt Control</a></li>
 <li><a href=#gbasystemcontrol>GBA System Control</a></li>
 <li><a href=#gbacartridges>GBA Cartridges</a></li>
 <li><a href=#gbaunpredictablethings>GBA Unpredictable Things</a></li>
</ul>
<h2 id=--gba-reference><a name=gbareference></a> GBA Reference</h2>
<h3 id=overview-1>Overview</h3>
<ul>
 <li><a href=#gbatechnicaldata>GBA Technical Data</a></li>
 <li><a href=#gbamemorymap>GBA Memory Map</a></li>
 <li><a href=#gbaiomap>GBA I/O Map</a></li>
</ul>
<h3 id=hardware-programming-1>Hardware Programming</h3>
<ul>
 <li><a href=#gbalcdvideocontroller>GBA LCD Video Controller</a></li>
 <li><a href=#gbasoundcontroller>GBA Sound Controller</a></li>
 <li><a href=#gbatimers>GBA Timers</a></li>
 <li><a href=#gbadmatransfers>GBA DMA Transfers</a></li>
 <li><a href=#gbacommunicationports>GBA Communication Ports</a></li>
 <li><a href=#gbakeypadinput>GBA Keypad Input</a></li>
 <li><a href=#gbainterruptcontrol>GBA Interrupt Control</a></li>
 <li><a href=#gbasystemcontrol>GBA System Control</a></li>
 <li><a href=#gbacartridges>GBA Cartridges</a></li>
 <li><a href=#gbaunpredictablethings>GBA Unpredictable Things</a></li>
</ul>
<h2 id=--gba-technical-data><a name=gbatechnicaldata></a> GBA Technical Data</h2>
<h3 id=cpu-modes>CPU Modes</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  ARM Mode     ARM7TDMI 32bit RISC CPU, 16.78MHz, 32bit opcodes (GBA)
  THUMB Mode   ARM7TDMI 32bit RISC CPU, 16.78MHz, 16bit opcodes (GBA)
  CGB Mode     Z80/8080-style 8bit CPU, 4.2MHz or 8.4MHz  (CGB compatibility)
  DMG Mode     Z80/8080-style 8bit CPU, 4.2MHz (monochrome gameboy compatib.)
</code></pre></div></div>
<h3 id=internal-memory>Internal Memory</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  BIOS ROM     16 KBytes
  Work RAM     288 KBytes (Fast 32K on-chip, plus Slow 256K on-board)
  VRAM         96 KBytes
  OAM          1 KByte (128 OBJs 3x16bit, 32 OBJ-Rotation/Scalings 4x16bit)
  Palette RAM  1 KByte (256 BG colors, 256 OBJ colors)
</code></pre></div></div>
<h3 id=video>Video</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Display      240x160 pixels (2.9 inch TFT color LCD display)
  BG layers    4 background layers
  BG types     Tile/map based, or Bitmap based
  BG colors    256 colors, or 16 colors/16 palettes, or 32768 colors
  OBJ colors   256 colors, or 16 colors/16 palettes
  OBJ size     12 types (in range 8x8 up to 64x64 dots)
  OBJs/Screen  max. 128 OBJs of any size (up to 64x64 dots each)
  OBJs/Line    max. 128 OBJs of 8x8 dots size (under best circumstances)
  Priorities   OBJ/OBJ: 0-127, OBJ/BG: 0-3, BG/BG: 0-3
  Effects      Rotation/Scaling, alpha blending, fade-in/out, mosaic, window
  Backlight    GBA SP only (optionally by light on/off toggle button)
</code></pre></div></div>
<h3 id=sound>Sound</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Analogue     4 channel CGB compatible (3x square wave, 1x noise)
  Digital      2 DMA sound channels
  Output       Built-in speaker (mono), or headphones socket (stereo)
</code></pre></div></div>
<h3 id=controls>Controls</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Gamepad      4 Direction Keys, 6 Buttons
</code></pre></div></div>
<h3 id=communication-ports>Communication Ports</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Serial Port  Various transfer modes, 4-Player Link, Single Game Pak play
</code></pre></div></div>
<h3 id=external-memory>External Memory</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  GBA Game Pak max. 32MB ROM or flash ROM + max 64K SRAM
  CGB Game Pak max. 32KB ROM + 8KB SRAM (more memory requires banking)
</code></pre></div></div>
<h3 id=case-dimensions>Case Dimensions</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Size (mm)    GBA: 145x81x25 - GBA SP: 82x82x24 (closed), 155x82x24 (stretch)
</code></pre></div></div>
<h3 id=power-supply>Power Supply</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Battery GBA  GBA: 2x1.5V DC (AA), Life-time approx. 15 hours
  Battery SP   GBA SP: Built-in rechargeable Lithium ion battery, 3.7V 600mAh
  External     GBA: 3.3V DC 350mA - GBA SP: 5.2V DC 320mA
</code></pre></div></div>
<hr>
<h3 id=original-gameboy-advance-gba>Original Gameboy Advance (GBA)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>        ____._____________...___.____
   ____/    :  CARTRIDGE  SIO   :    \____
  | L       _____________________  LED  R |
  |        |                     |        |
  |  _||_  |   2.9" TFT SCREEN   |    (A) |
  | |_  _| | 240x160pix  61x40mm | (B)    |
  |   ||   |    NO BACKLIGHT     |  ::::  |
  |        |                     | SPEAKR |
  | STRT() |_____________________|  ::::  |
  | SLCT()     GAME BOY ADVANCE    VOLUME |
  |____  OFF-ON  BATTERY 2xAA PHONES  _==_|
       \__.##.__________________,,___/
</code></pre></div></div>
<h3 id=gba-sp-gba-sp>GBA SP (GBA SP)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>   _______________________                                 _
  | _____________________ |                               / /
  ||                     ||                              / /
  ||   2.9" TFT SCREEN   ||                             / /
  || 240x160pix  61x40mm ||                            / /
  ||   WITH BACKLIGHT    ||                           / /
  ||                     ||     GBA SP SIDE VIEWS    / /
  ||_____________________||                         / /
  |  GAME BOY ADVANCE SP  |   _____________________(_)
  |_______________________|  |. . . . . . . .'.'.   _|
  |_|________|________|_|_|  |_CARTRIDGE_:_BATT._:_|_| &lt;-- EXT1/EXT2
  |L    EXT1     EXT2    R|
  |          (*)      LEDSo   _____________________ _
  (VOL_||_           (A)  o  |_____________________(_)
  |  |_  _| ,,,,,(B)      |  |. . . . . . . .'.'.   _|
  |    ||   ;SPK;         |  |_CARTRIDGE_:_BATT._:_|_| &lt;-- EXT1/EXT2
  |         '''''      ON #                         _ _____________________
  |       SLCT STRT    OFF#   _____________________(_)_____________________|
  | CART.  ()   ()        |  |. . . . . . . .'.'.   _|
  |_:___________________:_|  |_CARTRIDGE_:_BATT._:_|_| &lt;-- EXT1/EXT2
</code></pre></div></div>
<h3 id=gameboy-micro-gba-micro>Gameboy Micro (GBA Micro)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>      ________________SIO_______________
     | L      __________________      R |
     |       |     GBA-MICRO    |       |
     | _||_  |  2.0" TFT SCREEN |    (A)| +
     ||_  _| |240x160pix 42x28mm| (B)   |VOL
     |  ||   |     BACKLIGHT    |       | -
     |       |__________________|  ...  |
     |___________SELECT__START__________|
       PWR   &lt;--- CARTRIDGE SLOT ---&gt; PHONES
</code></pre></div></div>
<h3 id=nintendo-ds-nds>Nintendo DS (NDS)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>     _____________________________________
    |        _____________________        |
    |       |                     |       |
    |       |    3" TFT SCREEN    |       |
    |       | 256x192pix  61x46mm |       |
    |       |      BACKLIGHT      |       |
    | ::::: |    Original NDS     | ::::: |
    | ::::: |_____________________| ::::: |
   _|        _          ______   _        |_  &lt;-- gap between screens: 22mm
  |L|_______| |________|      |_| |_______|R|     (equivalent to 90 pixels)
  |_______   _____________________   _______|
  |  PWR  | |                     | |SEL STA|
  |   _   | |    3" TFT SCREEN    | |       |
  | _| |_ | | 256x192pix  61x46mm | |   X   |
  ||_   _|| |      BACKLIGHT      | | Y   A |
  |  |_|  | |    TOUCH SCREEN     | |   B   |
  |       | |_____________________| |       |
  |_______|             NintendoDS  |_______|
  |         MIC                LEDS         |
  |_________________________________________|
       VOL        SLOT2(GBA)     MIC/PHONES
</code></pre></div></div>
<h3 id=nintendo-ds-lite-nds-lite>Nintendo DS Lite (NDS-Lite)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>     _____________________________________
    |        _____________________        |
    |       |                     |       |
    |       |    3" TFT SCREEN    |       |
    |  ...  | 256x192pix  61x46mm |  ...  |
    |  ...  |      BACKLIGHT      |  ...  |
    |       |      NDS-LITE       |       |
    |       |_____________________|       |
    |___  _ _ _ _ _ _ _ _ _ _ _ _ _ _ ____|   &lt;-- gap between screens: 23mm
   L| _ |_____________MIC____________|LEDS|R
    |   _    _____________________        |
    | _| |_ |                     |   X   |
    ||_   _||    3" TFT SCREEN    | Y   A |PWR
    |  |_|  | 256x192pix  61x46mm |   B   |
    |       |      BACKLIGHT      |       |
    |       |    TOUCH SCREEN     |oSTART |
    |       |_____________________|oSELECT|
    |_____________________________________|
       VOL        SLOT2(GBA)     MIC/PHONES
</code></pre></div></div>
<h3 id=nintendo-dsi-dsi>Nintendo DSi (DSi)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>     _____________________________________
    |        _____________________        |
    |       |                     |   O o | &lt;-- CAM (O) and LED (o)
    |       |   3.25" TFT SCREEN  |       |     (on backside)
    |       | 256x192pix  66x50mm |       |
    |       |      BACKLIGHT      |       |
    |  __   |         DSi         |   __  |
    | (__)  |_____________________|  (__) |
    |___  _ _ _ _ _ _ _ _ _ _ _ _ _ _ ____|  &lt;-- gap between screens: 23mm
   L|LEDS|__________CAM__MIC_________| __ |R                   (88 pixels)
  + |   _    _____________________        |
 VOL| _| |_ |                     |   X   | &lt;-- SD Card Slot
  - ||_   _||   3.25" TFT SCREEN  | Y   A |
    |  |_|  | 256x192pix  66x50mm |   B   |
    |       |      BACKLIGHT      |       |
    |       |    TOUCH SCREEN     |oSTART |
    | POWERo|_____________________|oSELECT|
    |_____________________________________|
                                 MIC/PHONES
</code></pre></div></div>
<h3 id=nintendo-dsi-xl>Nintendo DSi XL</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  As DSi, but bigger case, and bigger 4.2" screens
</code></pre></div></div>
<h3 id=gameboy-player-gamecube-joypad-gba-player>Gameboy Player (Gamecube Joypad) (GBA Player)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>                   _________
       L____-------         -------____R
       /   ___   \           /   (Y)   \Z
      /   / O \   | (START) |        (X)\   Z      = Gameboy Player Menu
     |    \___/    \_______/      (A)    |  X or Y = Select button
     |\         _   \     /    (B)      /|
     | \___   _| |_  \   /   ___    ___/ |  optionally X/Y can be
     |    |\ |_   _| /   \  / C \  /|    |  swapped with L/R (?)
     |    | \  |_|  /     \ \___/ / |    |
     |    |  \_____/       \_____/  |    |  analogue sticks = ?
      \__/                           \__/
</code></pre></div></div>
<h3 id=gameboy-player-gamecube-bongos-gba-player>Gameboy Player (Gamecube Bongos) (GBA Player)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>       _______     _______
      /   Y   \   /   X   \   Y/B = left bongo rear/front side
     | . . . . |_| . . . . |  X/A = right bongo rear/front side
     |    B    |R|    A    |  S   = start/pause button
     |\_______/|_|\_______/|  R   = microphone (triggers R button)
     |\_______/|S|\_______/|
     |         |_|         |  (the X/Y inputs can be assigned to
     |\_______/| |\_______/|  GBA R/L inputs in GBA player setup)
      \_______/   \_______/
</code></pre></div></div>
<p>The GBA’s separate 8bit/32bit CPU modes cannot be operated simultaneously.
Switching is allowed between ARM and THUMB modes only (that are the two GBA
modes).</p>
<p>This manual does not describe CGB and DMG modes, both are completely different
than GBA modes, and both cannot be accessed from inside of GBA modes anyways.</p>
<h3 id=gameboy-player>Gameboy Player</h3>
<p>An GBA Adapter for the Gamecube console; allowing to play GBA games on a
television set.</p>
<ul>
 <li><a href=#gbagameboyplayer>GBA Gameboy Player</a></li>
</ul>
<h3 id=gba-sp-notes>GBA SP Notes</h3>
<p>Deluxe version of the original GBA. With backlight, new folded laptop-style
case, and built-in rechargeable battery. Appears to be 100% compatible with
GBA, there seems to be no way to detect SPs by software.</p>
<h3 id=gameboy-micro-gba-micro-1>Gameboy Micro (GBA Micro)</h3>
<p>Minituarized GBA. Supports 32bit GBA games only (no 8bit DMG/CGB games). The
256K Main RAM is a bit slower than usually (cannot be “overclocked via port
4000800h).</p>
<h3 id=nintendo-ds-dual-screen-notes>Nintendo DS (Dual Screen) Notes</h3>
<p>New handheld with two screens, backwards compatible with GBA games, it is NOT
backwards compatible with older 8bit games (mono/color gameboys) though..</p>
<p>Also, the DS has no link port, so that GBA games will thus work only in single
player mode, link-port accessoires like printers cannot be used, and most
unfortunately multiboot won’t work (trying to press Select+Start at powerup
will just lock up the DS).</p>
<h3 id=ique-notes>iQue Notes</h3>
<p>iQue is a brand name used by Nintendo in China, iQue GBA and iQue DS are
essentially same as Nintendo GBA and Nintendo DS.</p>
<p>The iQue DS contains a larger firmware chip (the charset additionally contains
about 6700 simplified chinese characters), the bootmenu still allows to select
(only) six languages (japanese has been replaced by chinese). The iQue DS can
play normal international NDS games, plus chinese dedicated games. The latter
ones won’t work on normal NDS consoles (that, reportedly simply due to a
firmware-version check contained in chinese dedicated games, aside from that
check, the games should be fully compatible with NDS consoles).</p>
<h2 id=--gba-memory-map><a name=gbamemorymap></a> GBA Memory Map</h2>
<h3 id=general-internal-memory>General Internal Memory</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  00000000-00003FFF   BIOS - System ROM         (16 KBytes)
  00004000-01FFFFFF   Not used
  02000000-0203FFFF   WRAM - On-board Work RAM  (256 KBytes) 2 Wait
  02040000-02FFFFFF   Not used
  03000000-03007FFF   WRAM - On-chip Work RAM   (32 KBytes)
  03008000-03FFFFFF   Not used
  04000000-040003FE   I/O Registers
  04000400-04FFFFFF   Not used
</code></pre></div></div>
<h3 id=internal-display-memory>Internal Display Memory</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  05000000-050003FF   BG/OBJ Palette RAM        (1 Kbyte)
  05000400-05FFFFFF   Not used
  06000000-06017FFF   VRAM - Video RAM          (96 KBytes)
  06018000-06FFFFFF   Not used
  07000000-070003FF   OAM - OBJ Attributes      (1 Kbyte)
  07000400-07FFFFFF   Not used
</code></pre></div></div>
<h3 id=external-memory-game-pak>External Memory (Game Pak)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  08000000-09FFFFFF   Game Pak ROM/FlashROM (max 32MB) - Wait State 0
  0A000000-0BFFFFFF   Game Pak ROM/FlashROM (max 32MB) - Wait State 1
  0C000000-0DFFFFFF   Game Pak ROM/FlashROM (max 32MB) - Wait State 2
  0E000000-0E00FFFF   Game Pak SRAM    (max 64 KBytes) - 8bit Bus width
  0E010000-0FFFFFFF   Not used
</code></pre></div></div>
<h3 id=unused-memory-area>Unused Memory Area</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  10000000-FFFFFFFF   Not used (upper 4bits of address bus unused)
</code></pre></div></div>
<h3 id=default-wram-usage>Default WRAM Usage</h3>
<p>By default, the 256 bytes at 03007F00h-03007FFFh in Work RAM are reserved for
Interrupt vector, Interrupt Stack, and BIOS Call Stack. The remaining WRAM is
free for whatever use (including User Stack, which is initially located at
03007F00h).</p>
<h3 id=address-bus-width-and-cpu-readwrite-access-widths>Address Bus Width and CPU Read/Write Access Widths</h3>
<p>Shows the Bus-Width, supported read and write widths, and the clock cycles for
8/16/32bit accesses.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Region        Bus   Read      Write     Cycles
  BIOS ROM      32    8/16/32   -         1/1/1
  Work RAM 32K  32    8/16/32   8/16/32   1/1/1
  I/O           32    8/16/32   8/16/32   1/1/1
  OAM           32    8/16/32   16/32     1/1/1 *
  Work RAM 256K 16    8/16/32   8/16/32   3/3/6 **
  Palette RAM   16    8/16/32   16/32     1/1/2 *
  VRAM          16    8/16/32   16/32     1/1/2 *
  GamePak ROM   16    8/16/32   -         5/5/8 **/***
  GamePak Flash 16    8/16/32   16/32     5/5/8 **/***
  GamePak SRAM  8     8         8         5     **
</code></pre></div></div>
<p>Timing Notes:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  *   Plus 1 cycle if GBA accesses video memory at the same time.
  **  Default waitstate settings, see System Control chapter.
  *** Separate timings for sequential, and non-sequential accesses.
  One cycle equals approx. 59.59ns (ie. 16.78MHz clock).
</code></pre></div></div>
<p>All memory (except GamePak SRAM) can be accessed by 16bit and 32bit DMA.</p>
<h3 id=gamepak-memory>GamePak Memory</h3>
<p>Only DMA3 (and the CPU of course) may access GamePak ROM. GamePak SRAM can be
accessed by the CPU only - restricted to bytewise 8bit transfers. The SRAM
region is supposed for as external FLASH backup memory, or for battery-backed
SRAM.</p>
<p>For details about configuration of GamePak Waitstates, see:</p>
<ul>
 <li><a href=#gbasystemcontrol>GBA System Control</a></li>
</ul>
<h3 id=vram-oam-and-palette-ram-access>VRAM, OAM, and Palette RAM Access</h3>
<p>These memory regions can be accessed during H-Blank or V-Blank only (unless
display is disabled by Forced Blank bit in DISPCNT register).</p>
<p>There is an additional restriction for OAM memory: Accesses during H-Blank are
allowed only if ‘H-Blank Interval Free’ in DISPCNT is set (which’d reduce
number of display-able OBJs though).</p>
<p>The CPU appears to be able to access VRAM/OAM/Palette at any time, a waitstate
(one clock cycle) being inserted automatically in case that the display
controller was accessing memory simultaneously. (Ie. unlike as in old 8bit
gameboy, the data will not get lost.)</p>
<h3 id=cpu-mode-performance>CPU Mode Performance</h3>
<p>Note that the GamePak ROM bus is limited to 16bits, thus executing ARM
instructions (32bit opcodes) from inside of GamePak ROM would result in a not
so good performance. So, it’d be more recommended to use THUMB instruction
(16bit opcodes) which’d allow each opcode to be read at once.</p>
<p>(ARM instructions can be used at best performance by copying code from GamePak
ROM into internal Work RAM)</p>
<h3 id=data-format>Data Format</h3>
<p>Even though the ARM CPU itself would allow to select between Little-Endian and
Big-Endian format by using an external circuit, in the GBA no such circuit
exists, and the data format is always Little-Endian. That is, when accessing
16bit or 32bit data in memory, the least significant bits are stored in the
first byte (smallest address), and the most significant bits in the last byte.
(Ie. same as for 80x86 and Z80 CPUs.)</p>
<h2 id=--gba-io-map><a name=gbaiomap></a> GBA I/O Map</h2>
<h3 id=lcd-io-registers>LCD I/O Registers</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  4000000h  2    R/W  DISPCNT   LCD Control
  4000002h  2    R/W  -         Undocumented - Green Swap
  4000004h  2    R/W  DISPSTAT  General LCD Status (STAT,LYC)
  4000006h  2    R    VCOUNT    Vertical Counter (LY)
  4000008h  2    R/W  BG0CNT    BG0 Control
  400000Ah  2    R/W  BG1CNT    BG1 Control
  400000Ch  2    R/W  BG2CNT    BG2 Control
  400000Eh  2    R/W  BG3CNT    BG3 Control
  4000010h  2    W    BG0HOFS   BG0 X-Offset
  4000012h  2    W    BG0VOFS   BG0 Y-Offset
  4000014h  2    W    BG1HOFS   BG1 X-Offset
  4000016h  2    W    BG1VOFS   BG1 Y-Offset
  4000018h  2    W    BG2HOFS   BG2 X-Offset
  400001Ah  2    W    BG2VOFS   BG2 Y-Offset
  400001Ch  2    W    BG3HOFS   BG3 X-Offset
  400001Eh  2    W    BG3VOFS   BG3 Y-Offset
  4000020h  2    W    BG2PA     BG2 Rotation/Scaling Parameter A (dx)
  4000022h  2    W    BG2PB     BG2 Rotation/Scaling Parameter B (dmx)
  4000024h  2    W    BG2PC     BG2 Rotation/Scaling Parameter C (dy)
  4000026h  2    W    BG2PD     BG2 Rotation/Scaling Parameter D (dmy)
  4000028h  4    W    BG2X      BG2 Reference Point X-Coordinate
  400002Ch  4    W    BG2Y      BG2 Reference Point Y-Coordinate
  4000030h  2    W    BG3PA     BG3 Rotation/Scaling Parameter A (dx)
  4000032h  2    W    BG3PB     BG3 Rotation/Scaling Parameter B (dmx)
  4000034h  2    W    BG3PC     BG3 Rotation/Scaling Parameter C (dy)
  4000036h  2    W    BG3PD     BG3 Rotation/Scaling Parameter D (dmy)
  4000038h  4    W    BG3X      BG3 Reference Point X-Coordinate
  400003Ch  4    W    BG3Y      BG3 Reference Point Y-Coordinate
  4000040h  2    W    WIN0H     Window 0 Horizontal Dimensions
  4000042h  2    W    WIN1H     Window 1 Horizontal Dimensions
  4000044h  2    W    WIN0V     Window 0 Vertical Dimensions
  4000046h  2    W    WIN1V     Window 1 Vertical Dimensions
  4000048h  2    R/W  WININ     Inside of Window 0 and 1
  400004Ah  2    R/W  WINOUT    Inside of OBJ Window &amp; Outside of Windows
  400004Ch  2    W    MOSAIC    Mosaic Size
  400004Eh       -    -         Not used
  4000050h  2    R/W  BLDCNT    Color Special Effects Selection
  4000052h  2    R/W  BLDALPHA  Alpha Blending Coefficients
  4000054h  2    W    BLDY      Brightness (Fade-In/Out) Coefficient
  4000056h       -    -         Not used
</code></pre></div></div>
<h3 id=sound-registers>Sound Registers</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  4000060h  2  R/W  SOUND1CNT_L Channel 1 Sweep register       (NR10)
  4000062h  2  R/W  SOUND1CNT_H Channel 1 Duty/Length/Envelope (NR11, NR12)
  4000064h  2  R/W  SOUND1CNT_X Channel 1 Frequency/Control    (NR13, NR14)
  4000066h     -    -           Not used
  4000068h  2  R/W  SOUND2CNT_L Channel 2 Duty/Length/Envelope (NR21, NR22)
  400006Ah     -    -           Not used
  400006Ch  2  R/W  SOUND2CNT_H Channel 2 Frequency/Control    (NR23, NR24)
  400006Eh     -    -           Not used
  4000070h  2  R/W  SOUND3CNT_L Channel 3 Stop/Wave RAM select (NR30)
  4000072h  2  R/W  SOUND3CNT_H Channel 3 Length/Volume        (NR31, NR32)
  4000074h  2  R/W  SOUND3CNT_X Channel 3 Frequency/Control    (NR33, NR34)
  4000076h     -    -           Not used
  4000078h  2  R/W  SOUND4CNT_L Channel 4 Length/Envelope      (NR41, NR42)
  400007Ah     -    -           Not used
  400007Ch  2  R/W  SOUND4CNT_H Channel 4 Frequency/Control    (NR43, NR44)
  400007Eh     -    -           Not used
  4000080h  2  R/W  SOUNDCNT_L  Control Stereo/Volume/Enable   (NR50, NR51)
  4000082h  2  R/W  SOUNDCNT_H  Control Mixing/DMA Control
  4000084h  2  R/W  SOUNDCNT_X  Control Sound on/off           (NR52)
  4000086h     -    -           Not used
  4000088h  2  BIOS SOUNDBIAS   Sound PWM Control
  400008Ah  ..   -    -         Not used
  4000090h 2x10h R/W  WAVE_RAM  Channel 3 Wave Pattern RAM (2 banks!!)
  40000A0h  4    W    FIFO_A    Channel A FIFO, Data 0-3
  40000A4h  4    W    FIFO_B    Channel B FIFO, Data 0-3
  40000A8h       -    -         Not used
</code></pre></div></div>
<h3 id=dma-transfer-channels>DMA Transfer Channels</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  40000B0h  4    W    DMA0SAD   DMA 0 Source Address
  40000B4h  4    W    DMA0DAD   DMA 0 Destination Address
  40000B8h  2    W    DMA0CNT_L DMA 0 Word Count
  40000BAh  2    R/W  DMA0CNT_H DMA 0 Control
  40000BCh  4    W    DMA1SAD   DMA 1 Source Address
  40000C0h  4    W    DMA1DAD   DMA 1 Destination Address
  40000C4h  2    W    DMA1CNT_L DMA 1 Word Count
  40000C6h  2    R/W  DMA1CNT_H DMA 1 Control
  40000C8h  4    W    DMA2SAD   DMA 2 Source Address
  40000CCh  4    W    DMA2DAD   DMA 2 Destination Address
  40000D0h  2    W    DMA2CNT_L DMA 2 Word Count
  40000D2h  2    R/W  DMA2CNT_H DMA 2 Control
  40000D4h  4    W    DMA3SAD   DMA 3 Source Address
  40000D8h  4    W    DMA3DAD   DMA 3 Destination Address
  40000DCh  2    W    DMA3CNT_L DMA 3 Word Count
  40000DEh  2    R/W  DMA3CNT_H DMA 3 Control
  40000E0h       -    -         Not used
</code></pre></div></div>
<h3 id=timer-registers>Timer Registers</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  4000100h  2    R/W  TM0CNT_L  Timer 0 Counter/Reload
  4000102h  2    R/W  TM0CNT_H  Timer 0 Control
  4000104h  2    R/W  TM1CNT_L  Timer 1 Counter/Reload
  4000106h  2    R/W  TM1CNT_H  Timer 1 Control
  4000108h  2    R/W  TM2CNT_L  Timer 2 Counter/Reload
  400010Ah  2    R/W  TM2CNT_H  Timer 2 Control
  400010Ch  2    R/W  TM3CNT_L  Timer 3 Counter/Reload
  400010Eh  2    R/W  TM3CNT_H  Timer 3 Control
  4000110h       -    -         Not used
</code></pre></div></div>
<h3 id=serial-communication-1>Serial Communication (1)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  4000120h  4    R/W  SIODATA32 SIO Data (Normal-32bit Mode; shared with below)
  4000120h  2    R/W  SIOMULTI0 SIO Data 0 (Parent)    (Multi-Player Mode)
  4000122h  2    R/W  SIOMULTI1 SIO Data 1 (1st Child) (Multi-Player Mode)
  4000124h  2    R/W  SIOMULTI2 SIO Data 2 (2nd Child) (Multi-Player Mode)
  4000126h  2    R/W  SIOMULTI3 SIO Data 3 (3rd Child) (Multi-Player Mode)
  4000128h  2    R/W  SIOCNT    SIO Control Register
  400012Ah  2    R/W  SIOMLT_SEND SIO Data (Local of MultiPlayer; shared below)
  400012Ah  2    R/W  SIODATA8  SIO Data (Normal-8bit and UART Mode)
  400012Ch       -    -         Not used
</code></pre></div></div>
<h3 id=keypad-input>Keypad Input</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  4000130h  2    R    KEYINPUT  Key Status
  4000132h  2    R/W  KEYCNT    Key Interrupt Control
</code></pre></div></div>
<h3 id=serial-communication-2>Serial Communication (2)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  4000134h  2    R/W  RCNT      SIO Mode Select/General Purpose Data
  4000136h  -    -    IR        Ancient - Infrared Register (Prototypes only)
  4000138h       -    -         Not used
  4000140h  2    R/W  JOYCNT    SIO JOY Bus Control
  4000142h       -    -         Not used
  4000150h  4    R/W  JOY_RECV  SIO JOY Bus Receive Data
  4000154h  4    R/W  JOY_TRANS SIO JOY Bus Transmit Data
  4000158h  2    R/?  JOYSTAT   SIO JOY Bus Receive Status
  400015Ah       -    -         Not used
</code></pre></div></div>
<h3 id=interrupt-waitstate-and-power-down-control>Interrupt, Waitstate, and Power-Down Control</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  4000200h  2    R/W  IE        Interrupt Enable Register
  4000202h  2    R/W  IF        Interrupt Request Flags / IRQ Acknowledge
  4000204h  2    R/W  WAITCNT   Game Pak Waitstate Control
  4000206h       -    -         Not used
  4000208h  2    R/W  IME       Interrupt Master Enable Register
  400020Ah       -    -         Not used
  4000300h  1    R/W  POSTFLG   Undocumented - Post Boot Flag
  4000301h  1    W    HALTCNT   Undocumented - Power Down Control
  4000302h       -    -         Not used
  4000410h  ?    ?    ?         Undocumented - Purpose Unknown / Bug ??? 0FFh
  4000411h       -    -         Not used
  4000800h  4    R/W  ?         Undocumented - Internal Memory Control (R/W)
  4000804h       -    -         Not used
  4xx0800h  4    R/W  ?         Mirrors of 4000800h (repeated each 64K)
</code></pre></div></div>
<p>All further addresses at 4XXXXXXh are unused and do not contain mirrors of the
I/O area, with the only exception that 4000800h is repeated each 64K (ie.
mirrored at 4010800h, 4020800h, etc.)</p>
<h2 id=--gba-lcd-video-controller><a name=gbalcdvideocontroller></a> GBA LCD Video Controller</h2>
<h3 id=registers>Registers</h3>
<ul>
 <li><a href=#lcdiodisplaycontrol>LCD I/O Display Control</a></li>
 <li><a href=#lcdiointerruptsandstatus>LCD I/O Interrupts and Status</a></li>
 <li><a href=#lcdiobgcontrol>LCD I/O BG Control</a></li>
 <li><a href=#lcdiobgscrolling>LCD I/O BG Scrolling</a></li>
 <li><a href=#lcdiobgrotationscaling>LCD I/O BG Rotation/Scaling</a></li>
 <li><a href=#lcdiowindowfeature>LCD I/O Window Feature</a></li>
 <li><a href=#lcdiomosaicfunction>LCD I/O Mosaic Function</a></li>
 <li><a href=#lcdiocolorspecialeffects>LCD I/O Color Special Effects</a></li>
</ul>
<h3 id=vram>VRAM</h3>
<ul>
 <li><a href=#lcdvramoverview>LCD VRAM Overview</a></li>
 <li><a href=#lcdvramcharacterdata>LCD VRAM Character Data</a></li>
 <li><a href=#lcdvrambgscreendataformatbgmap>LCD VRAM BG Screen Data Format (BG Map)</a></li>
 <li><a href=#lcdvrambitmapbgmodes>LCD VRAM Bitmap BG Modes</a></li>
</ul>
<h3 id=sprites>Sprites</h3>
<ul>
 <li><a href=#lcdobjoverview>LCD OBJ - Overview</a></li>
 <li><a href=#lcdobjoamattributes>LCD OBJ - OAM Attributes</a></li>
 <li><a href=#lcdobjoamrotationscalingparameters>LCD OBJ - OAM Rotation/Scaling Parameters</a></li>
 <li><a href=#lcdobjvramcharactertilemapping>LCD OBJ - VRAM Character (Tile) Mapping</a></li>
</ul>
<h3 id=other-2>Other</h3>
<ul>
 <li><a href=#lcdcolorpalettes>LCD Color Palettes</a></li>
 <li><a href=#lcddimensionsandtimings>LCD Dimensions and Timings</a></li>
</ul>
<h2 id=--lcd-io-display-control><a name=lcdiodisplaycontrol></a> LCD I/O Display Control</h2>
<h3 id=4000000h---dispcnt---lcd-control-readwrite>4000000h - DISPCNT - LCD Control (Read/Write)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-2   BG Mode                (0-5=Video Mode 0-5, 6-7=Prohibited)
  3     Reserved / CGB Mode    (0=GBA, 1=CGB; can be set only by BIOS opcodes)
  4     Display Frame Select   (0-1=Frame 0-1) (for BG Modes 4,5 only)
  5     H-Blank Interval Free  (1=Allow access to OAM during H-Blank)
  6     OBJ Character VRAM Mapping (0=Two dimensional, 1=One dimensional)
  7     Forced Blank           (1=Allow FAST access to VRAM,Palette,OAM)
  8     Screen Display BG0  (0=Off, 1=On)
  9     Screen Display BG1  (0=Off, 1=On)
  10    Screen Display BG2  (0=Off, 1=On)
  11    Screen Display BG3  (0=Off, 1=On)
  12    Screen Display OBJ  (0=Off, 1=On)
  13    Window 0 Display Flag   (0=Off, 1=On)
  14    Window 1 Display Flag   (0=Off, 1=On)
  15    OBJ Window Display Flag (0=Off, 1=On)
</code></pre></div></div>
<p>The table summarizes the facilities of the separate BG modes (video modes).</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Mode  Rot/Scal Layers Size               Tiles Colors       Features
  0     No       0123   256x256..512x515   1024  16/16..256/1 SFMABP
  1     Mixed    012-   (BG0,BG1 as above Mode 0, BG2 as below Mode 2)
  2     Yes      --23   128x128..1024x1024 256   256/1        S-MABP
  3     Yes      --2-   240x160            1     32768        --MABP
  4     Yes      --2-   240x160            2     256/1        --MABP
  5     Yes      --2-   160x128            2     32768        --MABP
</code></pre></div></div>
<p>Features: S)crolling, F)lip, M)osaic, A)lphaBlending, B)rightness, P)riority.</p>
<p>BG Modes 0-2 are Tile/Map-based. BG Modes 3-5 are Bitmap-based, in these modes
1 or 2 Frames (ie. bitmaps, or ‘full screen tiles’) exists, if two frames
exist, either one can be displayed, and the other one can be redrawn in
background.</p>
<h3 id=blanking-bits>Blanking Bits</h3>
<p>Setting Forced Blank (Bit 7) causes the video controller to display white
lines, and all VRAM, Palette RAM, and OAM may be accessed.</p>
<p>“When the internal HV synchronous counter cancels a forced blank during a
display period, the display begins from the beginning, following the display of
two vertical lines.” What ?</p>
<p>Setting H-Blank Interval Free (Bit 5) allows to access OAM during H-Blank time</p>
<ul>
 <li>using this feature reduces the number of sprites that can be displayed per
line.</li>
</ul>
<h3 id=display-enable-bits>Display Enable Bits</h3>
<p>By default, BG0-3 and OBJ Display Flags (Bit 8-12) are used to enable/disable
BGs and OBJ. When enabling Window 0 and/or 1 (Bit 13-14), color special effects
may be used, and BG0-3 and OBJ are controlled by the window(s).</p>
<h3 id=frame-selection>Frame Selection</h3>
<p>In BG Modes 4 and 5 (Bitmap modes), either one of the two bitmaps/frames may be
displayed (Bit 4), allowing the user to update the other (invisible) frame in
background. In BG Mode 3, only one frame exists.</p>
<p>In BG Modes 0-2 (Tile/Map based modes), a similar effect may be gained by
altering the base address(es) of BG Map and/or BG Character data.</p>
<h3 id=4000002h---undocumented---green-swap-rw>4000002h - Undocumented - Green Swap (R/W)</h3>
<p>Normally, red green blue intensities for a group of two pixels is output as
BGRbgr (uppercase for left pixel at even xloc, lowercase for right pixel at odd
xloc). When the Green Swap bit is set, each pixel group is output as BgRbGr
(ie. green intensity of each two pixels exchanged).</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0     Green Swap  (0=Normal, 1=Swap)
  1-15  Not used
</code></pre></div></div>
<p>This feature appears to be applied to the final picture (ie. after mixing the
separate BG and OBJ layers). Eventually intended for other display types (with
other pin-outs). With normal GBA hardware it is just producing an interesting
dirt effect.</p>
<p>The NDS DISPCNT registers are 32bit (4000000h..4000003h), so Green Swap doesn’t
exist in NDS mode, however, the NDS does support Green Swap in GBA mode.</p>
<h2 id=--lcd-io-interrupts-and-status><a name=lcdiointerruptsandstatus></a> LCD I/O Interrupts and Status</h2>
<h3 id=4000004h---dispstat---general-lcd-status-readwrite>4000004h - DISPSTAT - General LCD Status (Read/Write)</h3>
<p>Display status and Interrupt control. The H-Blank conditions are generated once
per scanline, including for the ‘hidden’ scanlines during V-Blank.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0     V-Blank flag   (Read only) (1=VBlank) (set in line 160..226; not 227)
  1     H-Blank flag   (Read only) (1=HBlank) (toggled in all lines, 0..227)
  2     V-Counter flag (Read only) (1=Match)  (set in selected line)     (R)
  3     V-Blank IRQ Enable         (1=Enable)                          (R/W)
  4     H-Blank IRQ Enable         (1=Enable)                          (R/W)
  5     V-Counter IRQ Enable       (1=Enable)                          (R/W)
  6     Not used (0) / DSi: LCD Initialization Ready (0=Busy, 1=Ready)   (R)
  7     Not used (0) / NDS: MSB of V-Vcount Setting (LYC.Bit8) (0..262)(R/W)
  8-15  V-Count Setting (LYC)      (0..227)                            (R/W)
</code></pre></div></div>
<p>The V-Count-Setting value is much the same as LYC of older gameboys, when its
value is identical to the content of the VCOUNT register then the V-Counter
flag is set (Bit 2), and (if enabled in Bit 5) an interrupt is requested.</p>
<p>Although the drawing time is only 960 cycles (240*4), the H-Blank flag is “0”
for a total of 1006 cycles.</p>
<h3 id=4000006h---vcount---vertical-counter-read-only>4000006h - VCOUNT - Vertical Counter (Read only)</h3>
<p>Indicates the currently drawn scanline, values in range from 160..227 indicate
‘hidden’ scanlines within VBlank area.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-7   Current Scanline (LY)      (0..227)                              (R)
  8     Not used (0) / NDS: MSB of Current Scanline (LY.Bit8) (0..262)   (R)
  9-15  Not Used (0)
</code></pre></div></div>
<p>Note: This is much the same than the ‘LY’ register of older gameboys.</p>
<h2 id=--lcd-io-bg-control><a name=lcdiobgcontrol></a> LCD I/O BG Control</h2>
<h3 id=4000008h---bg0cnt---bg0-control-rw-bg-modes-01-only>4000008h - BG0CNT - BG0 Control (R/W) (BG Modes 0,1 only)</h3>
<h3 id=400000ah---bg1cnt---bg1-control-rw-bg-modes-01-only>400000Ah - BG1CNT - BG1 Control (R/W) (BG Modes 0,1 only)</h3>
<h3 id=400000ch---bg2cnt---bg2-control-rw-bg-modes-012-only>400000Ch - BG2CNT - BG2 Control (R/W) (BG Modes 0,1,2 only)</h3>
<h3 id=400000eh---bg3cnt---bg3-control-rw-bg-modes-02-only>400000Eh - BG3CNT - BG3 Control (R/W) (BG Modes 0,2 only)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-1   BG Priority           (0-3, 0=Highest)
  2-3   Character Base Block  (0-3, in units of 16 KBytes) (=BG Tile Data)
  4-5   Not used (must be zero) (except in NDS mode: MSBs of char base)
  6     Mosaic                (0=Disable, 1=Enable)
  7     Colors/Palettes       (0=16/16, 1=256/1)
  8-12  Screen Base Block     (0-31, in units of 2 KBytes) (=BG Map Data)
  13    BG0/BG1: Not used (except in NDS mode: Ext Palette Slot for BG0/BG1)
  13    BG2/BG3: Display Area Overflow (0=Transparent, 1=Wraparound)
  14-15 Screen Size (0-3)
</code></pre></div></div>
<p>Internal Screen Size (dots) and size of BG Map (bytes):</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Value  Text Mode      Rotation/Scaling Mode
  0      256x256 (2K)   128x128   (256 bytes)
  1      512x256 (4K)   256x256   (1K)
  2      256x512 (4K)   512x512   (4K)
  3      512x512 (8K)   1024x1024 (16K)
</code></pre></div></div>
<p>In case that some or all BGs are set to same priority then BG0 is having the
highest, and BG3 the lowest priority.</p>
<p>In ‘Text Modes’, the screen size is organized as follows: The screen consists
of one or more 256x256 pixel (32x32 tiles) areas. When Size=0: only 1 area
(SC0), when Size=1 or Size=2: two areas (SC0,SC1 either horizontally or
vertically arranged next to each other), when Size=3: four areas (SC0,SC1 in
upper row, SC2,SC3 in lower row). Whereas SC0 is defined by the normal BG Map
base address (Bit 8-12 of BGxCNT), SC1 uses same address +2K, SC2 address +4K,
SC3 address +6K. When the screen is scrolled it’ll always wraparound.</p>
<p>In ‘Rotation/Scaling Modes’, the screen size is organized as follows, only one
area (SC0) of variable size 128x128..1024x1024 pixels (16x16..128x128 tiles)
exists. When the screen is rotated/scaled (or scrolled?) so that the LCD
viewport reaches outside of the background/screen area, then BG may be either
displayed as transparent or wraparound (Bit 13 of BGxCNT).</p>
<h2 id=--lcd-io-bg-scrolling><a name=lcdiobgscrolling></a> LCD I/O BG Scrolling</h2>
<h3 id=4000010h---bg0hofs---bg0-x-offset-w>4000010h - BG0HOFS - BG0 X-Offset (W)</h3>
<h3 id=4000012h---bg0vofs---bg0-y-offset-w>4000012h - BG0VOFS - BG0 Y-Offset (W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-8   Offset (0-511)
  9-15  Not used
</code></pre></div></div>
<p>Specifies the coordinate of the upperleft first visible dot of BG0 background
layer, ie. used to scroll the BG0 area.</p>
<h3 id=4000014h---bg1hofs---bg1-x-offset-w>4000014h - BG1HOFS - BG1 X-Offset (W)</h3>
<h3 id=4000016h---bg1vofs---bg1-y-offset-w>4000016h - BG1VOFS - BG1 Y-Offset (W)</h3>
<p>Same as above BG0HOFS and BG0VOFS for BG1 respectively.</p>
<h3 id=4000018h---bg2hofs---bg2-x-offset-w>4000018h - BG2HOFS - BG2 X-Offset (W)</h3>
<h3 id=400001ah---bg2vofs---bg2-y-offset-w>400001Ah - BG2VOFS - BG2 Y-Offset (W)</h3>
<p>Same as above BG0HOFS and BG0VOFS for BG2 respectively.</p>
<h3 id=400001ch---bg3hofs---bg3-x-offset-w>400001Ch - BG3HOFS - BG3 X-Offset (W)</h3>
<h3 id=400001eh---bg3vofs---bg3-y-offset-w>400001Eh - BG3VOFS - BG3 Y-Offset (W)</h3>
<p>Same as above BG0HOFS and BG0VOFS for BG3 respectively.</p>
<p>The above BG scrolling registers are exclusively used in Text modes, ie. for
all layers in BG Mode 0, and for the first two layers in BG mode 1.</p>
<p>In other BG modes (Rotation/Scaling and Bitmap modes) above registers are
ignored. Instead, the screen may be scrolled by modifying the BG
Rotation/Scaling Reference Point registers.</p>
<h2 id=--lcd-io-bg-rotationscaling><a name=lcdiobgrotationscaling></a> LCD I/O BG Rotation/Scaling</h2>
<h3 id=4000028h---bg2x_l---bg2-reference-point-x-coordinate-lower-16-bit-w>4000028h - BG2X_L - BG2 Reference Point X-Coordinate, lower 16 bit (W)</h3>
<h3 id=400002ah---bg2x_h---bg2-reference-point-x-coordinate-upper-12-bit-w>400002Ah - BG2X_H - BG2 Reference Point X-Coordinate, upper 12 bit (W)</h3>
<h3 id=400002ch---bg2y_l---bg2-reference-point-y-coordinate-lower-16-bit-w>400002Ch - BG2Y_L - BG2 Reference Point Y-Coordinate, lower 16 bit (W)</h3>
<h3 id=400002eh---bg2y_h---bg2-reference-point-y-coordinate-upper-12-bit-w>400002Eh - BG2Y_H - BG2 Reference Point Y-Coordinate, upper 12 bit (W)</h3>
<p>These registers are replacing the BG scrolling registers which are used for
Text mode, ie. the X/Y coordinates specify the source position from inside of
the BG Map/Bitmap of the pixel to be displayed at upper left of the GBA
display. The normal BG scrolling registers are ignored in Rotation/Scaling and
Bitmap modes.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-7   Fractional portion (8 bits)
  8-26  Integer portion    (19 bits)
  27    Sign               (1 bit)
  28-31 Not used
</code></pre></div></div>
<p>Because values are shifted left by eight, fractional portions may be specified
in steps of 1/256 pixels (this would be relevant only if the screen is actually
rotated or scaled). Normal signed 32bit values may be written to above
registers (the most significant bits will be ignored and the value will be
cut-down to 28bits, but this is no actual problem because signed values have
set all MSBs to the same value).</p>
<h3 id=internal-reference-point-registers>Internal Reference Point Registers</h3>
<p>The above reference points are automatically copied to internal registers
during each vblank, specifying the origin for the first scanline. The internal
registers are then incremented by dmx and dmy after each scanline.</p>
<p>Caution: Writing to a reference point register by software outside of the
Vblank period does immediately copy the new value to the corresponding internal
register, that means: in the current frame, the new value specifies the origin
of the &lt;current&gt; scanline (instead of the topmost scanline).</p>
<h3 id=4000020h---bg2pa---bg2-rotationscaling-parameter-a-alias-dx-w>4000020h - BG2PA - BG2 Rotation/Scaling Parameter A (alias dx) (W)</h3>
<h3 id=4000022h---bg2pb---bg2-rotationscaling-parameter-b-alias-dmx-w>4000022h - BG2PB - BG2 Rotation/Scaling Parameter B (alias dmx) (W)</h3>
<h3 id=4000024h---bg2pc---bg2-rotationscaling-parameter-c-alias-dy--w>4000024h - BG2PC - BG2 Rotation/Scaling Parameter C (alias dy) (W)</h3>
<h3 id=4000026h---bg2pd---bg2-rotationscaling-parameter-d-alias-dmy-w>4000026h - BG2PD - BG2 Rotation/Scaling Parameter D (alias dmy) (W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-7   Fractional portion (8 bits)
  8-14  Integer portion    (7 bits)
  15    Sign               (1 bit)
</code></pre></div></div>
<p>See below for details.</p>
<h3 id=400003xh---bg3x_lh-bg3y_lh-bg3pa-d---bg3-rotationscaling-parameters>400003Xh - BG3X_L/H, BG3Y_L/H, BG3PA-D - BG3 Rotation/Scaling Parameters</h3>
<p>Same as above BG2 Reference Point, and Rotation/Scaling Parameters, for BG3
respectively.</p>
<h3 id=dx-pa-and-dy-pc>dx (PA) and dy (PC)</h3>
<p>When transforming a horizontal line, dx and dy specify the resulting gradient
and magnification for that line. For example:</p>
<p>Horizontal line, length=100, dx=1, and dy=1. The resulting line would be drawn
at 45 degrees, f(y)=1/1*x. Note that this would involve that line is magnified,
the new length is SQR(100^2+100^2)=141.42. Yup, exactly - that’s the old a^2 +
b^2 = c^2 formula.</p>
<h3 id=dmx-pb-and-dmy-pd>dmx (PB) and dmy (PD)</h3>
<p>These values define the resulting gradient and magnification for transformation
of vertical lines. However, when rotating a square area (which is surrounded by
horizontal and vertical lines), then the desired result should be usually a
rotated &lt;square&gt; area (ie. not a parallelogram, for example).</p>
<p>Thus, dmx and dmy must be defined in direct relationship to dx and dy, taking
the example above, we’d have to set dmx=-1, and dmy=1, f(x)=-1/1*y.</p>
<h3 id=area-overflow>Area Overflow</h3>
<p>In result of rotation/scaling it may often happen that areas outside of the
actual BG area become moved into the LCD viewport. Depending of the Area
Overflow bit (BG2CNT and BG3CNT, Bit 13) these areas may be either displayed
(by wrapping the BG area), or may be displayed transparent.</p>
<p>This works only in BG modes 1 and 2. The area overflow is ignored in Bitmap
modes (BG modes 3-5), the outside of the Bitmaps is always transparent.</p>
<p>— more details and confusing or helpful formulas —</p>
<h3 id=the-following-parameters-are-required-for-rotationscaling>The following parameters are required for Rotation/Scaling</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Rotation Center X and Y Coordinates (x0,y0)
  Rotation Angle                      (alpha)
  Magnification X and Y Values        (xMag,yMag)
</code></pre></div></div>
<p>The display is rotated by ‘alpha’ degrees around the center.</p>
<p>The displayed picture is magnified by ‘xMag’ along x-Axis (Y=y0) and ‘yMag’
along y-Axis (X=x0).</p>
<h3 id=calculating-rotationscaling-parameters-a-d>Calculating Rotation/Scaling Parameters A-D</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  A = Cos (alpha) / xMag    ;distance moved in direction x, same line
  B = Sin (alpha) / xMag    ;distance moved in direction x, next line
  C = Sin (alpha) / yMag    ;distance moved in direction y, same line
  D = Cos (alpha) / yMag    ;distance moved in direction y, next line
</code></pre></div></div>
<h3 id=calculating-the-position-of-a-rotatedscaled-dot>Calculating the position of a rotated/scaled dot</h3>
<p>Using the following expressions,</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  x0,y0    Rotation Center
  x1,y1    Old Position of a pixel (before rotation/scaling)
  x2,y2    New position of above pixel (after rotation scaling)
  A,B,C,D  BG2PA-BG2PD Parameters (as calculated above)
</code></pre></div></div>
<p>the following formula can be used to calculate x2,y2:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  x2 = A(x1-x0) + B(y1-y0) + x0
  y2 = C(x1-x0) + D(y1-y0) + y0
</code></pre></div></div>
<h2 id=--lcd-io-window-feature><a name=lcdiowindowfeature></a> LCD I/O Window Feature</h2>
<p>The Window Feature may be used to split the screen into four regions. The
BG0-3,OBJ layers and Color Special Effects can be separately enabled or
disabled in each of these regions.</p>
<h3 id=the-dispcnt-register>The DISPCNT Register</h3>
<p>DISPCNT Bits 13-15 are used to enable Window 0, Window 1, and/or OBJ Window
regions, if any of these regions is enabled then the “Outside of Windows”
region is automatically enabled, too.</p>
<p>DISPCNT Bits 8-12 are kept used as master enable bits for the BG0-3,OBJ layers,
a layer is displayed only if both DISPCNT and WININ/OUT enable bits are set.</p>
<h3 id=4000040h---win0h---window-0-horizontal-dimensions-w>4000040h - WIN0H - Window 0 Horizontal Dimensions (W)</h3>
<h3 id=4000042h---win1h---window-1-horizontal-dimensions-w>4000042h - WIN1H - Window 1 Horizontal Dimensions (W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-7   X2, Rightmost coordinate of window, plus 1
  8-15  X1, Leftmost coordinate of window
</code></pre></div></div>
<p>Garbage values of X2&gt;240 or X1&gt;X2 are interpreted as X2=240.</p>
<h3 id=4000044h---win0v---window-0-vertical-dimensions-w>4000044h - WIN0V - Window 0 Vertical Dimensions (W)</h3>
<h3 id=4000046h---win1v---window-1-vertical-dimensions-w>4000046h - WIN1V - Window 1 Vertical Dimensions (W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-7   Y2, Bottom-most coordinate of window, plus 1
  8-15  Y1, Top-most coordinate of window
</code></pre></div></div>
<p>Garbage values of Y2&gt;160 or Y1&gt;Y2 are interpreted as Y2=160.</p>
<h3 id=4000048h---winin---control-of-inside-of-windows-rw>4000048h - WININ - Control of Inside of Window(s) (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-3   Window 0 BG0-BG3 Enable Bits     (0=No Display, 1=Display)
  4     Window 0 OBJ Enable Bit          (0=No Display, 1=Display)
  5     Window 0 Color Special Effect    (0=Disable, 1=Enable)
  6-7   Not used
  8-11  Window 1 BG0-BG3 Enable Bits     (0=No Display, 1=Display)
  12    Window 1 OBJ Enable Bit          (0=No Display, 1=Display)
  13    Window 1 Color Special Effect    (0=Disable, 1=Enable)
  14-15 Not used
</code></pre></div></div>
<h3 id=400004ah---winout---control-of-outside-of-windows--inside-of-obj-window-rw>400004Ah - WINOUT - Control of Outside of Windows &amp; Inside of OBJ Window (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-3   Outside BG0-BG3 Enable Bits      (0=No Display, 1=Display)
  4     Outside OBJ Enable Bit           (0=No Display, 1=Display)
  5     Outside Color Special Effect     (0=Disable, 1=Enable)
  6-7   Not used
  8-11  OBJ Window BG0-BG3 Enable Bits   (0=No Display, 1=Display)
  12    OBJ Window OBJ Enable Bit        (0=No Display, 1=Display)
  13    OBJ Window Color Special Effect  (0=Disable, 1=Enable)
  14-15 Not used
</code></pre></div></div>
<h3 id=the-obj-window>The OBJ Window</h3>
<p>The dimension of the OBJ Window is specified by OBJs which are having the “OBJ
Mode” attribute being set to “OBJ Window”. Any non-transparent dots of any such
OBJs are marked as OBJ Window area. The OBJ itself is not displayed.</p>
<p>The color, palette, and display priority of these OBJs are ignored. Both
DISPCNT Bits 12 and 15 must be set when defining OBJ Window region(s).</p>
<h3 id=window-priority>Window Priority</h3>
<p>In case that more than one window is enabled, and that these windows do
overlap, Window 0 is having highest priority, Window 1 medium, and Obj Window
lowest priority. Outside of Window is having zero priority, it is used for all
dots which are not inside of any window region.</p>
<h2 id=--lcd-io-mosaic-function><a name=lcdiomosaicfunction></a> LCD I/O Mosaic Function</h2>
<h3 id=400004ch---mosaic---mosaic-size-w>400004Ch - MOSAIC - Mosaic Size (W)</h3>
<p>The Mosaic function can be separately enabled/disabled for BG0-BG3 by
BG0CNT-BG3CNT Registers, as well as for each OBJ0-127 by OBJ attributes in OAM
memory. Also, setting all of the bits below to zero effectively disables the
mosaic function.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-3   BG Mosaic H-Size  (minus 1)
  4-7   BG Mosaic V-Size  (minus 1)
  8-11  OBJ Mosaic H-Size (minus 1)
  12-15 OBJ Mosaic V-Size (minus 1)
  16-31 Not used
</code></pre></div></div>
<p>Example: When setting H-Size to 5, then pixels 0-5 of each display row are
colorized as pixel 0, pixels 6-11 as pixel 6, pixels 12-17 as pixel 12, and so
on.</p>
<p>Normally, a ‘mosaic-pixel’ is colorized by the color of the upperleft covered
pixel. In many cases it might be more desireful to use the color of the pixel
in the center of the covered area - this effect may be gained by scrolling the
background (or by adjusting the OBJ position, as far as upper/left rows/columns
of OBJ are transparent).</p>
<h2 id=--lcd-io-color-special-effects><a name=lcdiocolorspecialeffects></a> LCD I/O Color Special Effects</h2>
<p>Two types of Special Effects are supported: Alpha Blending (Semi-Transparency)
allows to combine colors of two selected surfaces. Brightness Increase/Decrease
adjust the brightness of the selected surface.</p>
<h3 id=4000050h---bldcnt---color-special-effects-selection-rw>4000050h - BLDCNT - Color Special Effects Selection (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0     BG0 1st Target Pixel (Background 0)
  1     BG1 1st Target Pixel (Background 1)
  2     BG2 1st Target Pixel (Background 2)
  3     BG3 1st Target Pixel (Background 3)
  4     OBJ 1st Target Pixel (Top-most OBJ pixel)
  5     BD  1st Target Pixel (Backdrop)
  6-7   Color Special Effect (0-3, see below)
         0 = None                (Special effects disabled)
         1 = Alpha Blending      (1st+2nd Target mixed)
         2 = Brightness Increase (1st Target becomes whiter)
         3 = Brightness Decrease (1st Target becomes blacker)
  8     BG0 2nd Target Pixel (Background 0)
  9     BG1 2nd Target Pixel (Background 1)
  10    BG2 2nd Target Pixel (Background 2)
  11    BG3 2nd Target Pixel (Background 3)
  12    OBJ 2nd Target Pixel (Top-most OBJ pixel)
  13    BD  2nd Target Pixel (Backdrop)
  14-15 Not used
</code></pre></div></div>
<p>Selects the 1st Target layer(s) for special effects. For Alpha
Blending/Semi-Transparency, it does also select the 2nd Target layer(s), which
should have next lower display priority as the 1st Target.</p>
<p>However, any combinations are possible, including that all layers may be
selected as both 1st+2nd target, in that case the top-most pixel will be used
as 1st target, and the next lower pixel as 2nd target.</p>
<h3 id=4000052h---bldalpha---alpha-blending-coefficients-rw-not-w>4000052h - BLDALPHA - Alpha Blending Coefficients (R/W) (not W)</h3>
<p>Used for Color Special Effects Mode 1, and for Semi-Transparent OBJs.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-4   EVA Coefficient (1st Target) (0..16 = 0/16..16/16, 17..31=16/16)
  5-7   Not used
  8-12  EVB Coefficient (2nd Target) (0..16 = 0/16..16/16, 17..31=16/16)
  13-15 Not used
</code></pre></div></div>
<p>For this effect, the top-most non-transparent pixel must be selected as 1st
Target, and the next-lower non-transparent pixel must be selected as 2nd
Target, if so - and only if so, then color intensities of 1st and 2nd Target
are mixed together by using the parameters in BLDALPHA register, for each pixel
each R, G, B intensities are calculated separately:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  I = MIN ( 31, I1st*EVA + I2nd*EVB )
</code></pre></div></div>
<p>Otherwise - for example, if only one target exists, or if a non-transparent
non-2nd-target pixel is moved between the two targets, or if 2nd target has
higher display priority than 1st target - then only the top-most pixel is
displayed (at normal intensity, regardless of BLDALPHA).</p>
<h3 id=4000054h---bldy---brightness-fade-inout-coefficient-w-not-rw>4000054h - BLDY - Brightness (Fade-In/Out) Coefficient (W) (not R/W)</h3>
<p>Used for Color Special Effects Modes 2 and 3.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-4   EVY Coefficient (Brightness) (0..16 = 0/16..16/16, 17..31=16/16)
  5-31  Not used
</code></pre></div></div>
<p>For each pixel each R, G, B intensities are calculated separately:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  I = I1st + (31-I1st)*EVY   ;For Brightness Increase
  I = I1st - (I1st)*EVY      ;For Brightness Decrease
</code></pre></div></div>
<p>The color intensities of any selected 1st target surface(s) are increased or
decreased by using the parameter in BLDY register.</p>
<h3 id=semi-transparent-objs>Semi-Transparent OBJs</h3>
<p>OBJs that are defined as ‘Semi-Transparent’ in OAM memory are always selected
as 1st Target (regardless of BLDCNT Bit 4), and are always using Alpha Blending
mode (regardless of BLDCNT Bit 6-7).</p>
<p>The BLDCNT register may be used to perform Brightness effects on the OBJ
(and/or other BG/BD layers). However, if a semi-transparent OBJ pixel does
overlap a 2nd target pixel, then semi-transparency becomes priority, and the
brightness effect will not take place (neither on 1st, nor 2nd target).</p>
<h3 id=the-obj-layer>The OBJ Layer</h3>
<p>Before special effects are applied, the display controller computes the OBJ
priority ordering, and isolates the top-most OBJ pixel. In result, only the
top-most OBJ pixel is recursed at the time when processing special effects. Ie.
alpha blending and semi-transparency can be used for OBJ-to-BG or BG-to-OBJ ,
but not for OBJ-to-OBJ.</p>
<h2 id=--lcd-vram-overview><a name=lcdvramoverview></a> LCD VRAM Overview</h2>
<p>The GBA contains 96 Kbytes VRAM built-in, located at address 06000000-06017FFF,
depending on the BG Mode used as follows:</p>
<h3 id=bg-mode-012-tilemap-based-modes>BG Mode 0,1,2 (Tile/Map based Modes)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  06000000-0600FFFF  64 KBytes shared for BG Map and Tiles
  06010000-06017FFF  32 KBytes OBJ Tiles
</code></pre></div></div>
<p>The shared 64K area can be split into BG Map area(s), and BG Tiles area(s), the
respective addresses for Map and Tile areas are set up by BG0CNT-BG3CNT
registers. The Map address may be specified in units of 2K (steps of 800h), the
Tile address in units of 16K (steps of 4000h).</p>
<h3 id=bg-mode-01-tilemap-based-text-mode>BG Mode 0,1 (Tile/Map based Text mode)</h3>
<p>The tiles may have 4bit or 8bit color depth, minimum map size is 32x32 tiles,
maximum is 64x64 tiles, up to 1024 tiles can be used per map.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Item        Depth     Required Memory
  One Tile    4bit      20h bytes
  One Tile    8bit      40h bytes
  1024 Tiles  4bit      8000h (32K)
  1024 Tiles  8bit      10000h (64K) - excluding some bytes for BG map
  BG Map      32x32     800h (2K)
  BG Map      64x64     2000h (8K)
</code></pre></div></div>
<h3 id=bg-mode-12-tilemap-based-rotationscaling-mode>BG Mode 1,2 (Tile/Map based Rotation/Scaling mode)</h3>
<p>The tiles may have 8bit color depth only, minimum map size is 16x16 tiles,
maximum is 128x128 tiles, up to 256 tiles can be used per map.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Item        Depth     Required Memory
  One Tile    8bit      40h bytes
  256  Tiles  8bit      4000h (16K)
  BG Map      16x16     100h bytes
  BG Map      128x128   4000h (16K)
</code></pre></div></div>
<h3 id=bg-mode-3-bitmap-based-mode-for-still-images>BG Mode 3 (Bitmap based Mode for still images)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  06000000-06013FFF  80 KBytes Frame 0 buffer (only 75K actually used)
  06014000-06017FFF  16 KBytes OBJ Tiles
</code></pre></div></div>
<h3 id=bg-mode-45-bitmap-based-modes>BG Mode 4,5 (Bitmap based Modes)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  06000000-06009FFF  40 KBytes Frame 0 buffer (only 37.5K used in Mode 4)
  0600A000-06013FFF  40 KBytes Frame 1 buffer (only 37.5K used in Mode 4)
  06014000-06017FFF  16 KBytes OBJ Tiles
</code></pre></div></div>
<h3 id=note>Note</h3>
<p>Additionally to the above VRAM, the GBA also contains 1 KByte Palette RAM (at
05000000h) and 1 KByte OAM (at 07000000h) which are both used by the display
controller as well.</p>
<h2 id=--lcd-vram-character-data><a name=lcdvramcharacterdata></a> LCD VRAM Character Data</h2>
<p>Each character (tile) consists of 8x8 dots (64 dots in total). The color depth
may be either 4bit or 8bit (see BG0CNT-BG3CNT).</p>
<h3 id=4bit-depth-16-colors-16-palettes>4bit depth (16 colors, 16 palettes)</h3>
<p>Each tile occupies 32 bytes of memory, the first 4 bytes for the topmost row of
the tile, and so on. Each byte representing two dots, the lower 4 bits define
the color for the left (!) dot, the upper 4 bits the color for the right dot.</p>
<h3 id=8bit-depth-256-colors-1-palette>8bit depth (256 colors, 1 palette)</h3>
<p>Each tile occupies 64 bytes of memory, the first 8 bytes for the topmost row of
the tile, and so on. Each byte selects the palette entry for each dot.</p>
<h2 id=--lcd-vram-bg-screen-data-format-bg-map><a name=lcdvrambgscreendataformatbgmap></a> LCD VRAM BG Screen Data Format (BG Map)</h2>
<p>The display background consists of 8x8 dot tiles, the arrangement of these
tiles is specified by the BG Screen Data (BG Map). The separate entries in this
map are as follows:</p>
<h3 id=text-bg-screen-2-bytes-per-entry>Text BG Screen (2 bytes per entry)</h3>
<p>Specifies the tile number and attributes. Note that BG tile numbers are always
specified in steps of 1 (unlike OBJ tile numbers which are using steps of two
in 256 color/1 palette mode).</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-9   Tile Number     (0-1023) (a bit less in 256 color mode, because
                           there'd be otherwise no room for the bg map)
  10    Horizontal Flip (0=Normal, 1=Mirrored)
  11    Vertical Flip   (0=Normal, 1=Mirrored)
  12-15 Palette Number  (0-15)    (Not used in 256 color/1 palette mode)
</code></pre></div></div>
<p>A Text BG Map always consists of 32x32 entries (256x256 pixels), 400h entries =
800h bytes. However, depending on the BG Size, one, two, or four of these Maps
may be used together, allowing to create backgrounds of 256x256, 512x256,
256x512, or 512x512 pixels, if so, the first map (SC0) is located at base+0,
the next map (SC1) at base+800h, and so on.</p>
<h3 id=rotationscaling-bg-screen-1-byte-per-entry>Rotation/Scaling BG Screen (1 byte per entry)</h3>
<p>In this mode, only 256 tiles can be used. There are no x/y-flip attributes, the
color depth is always 256 colors/1 palette.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-7   Tile Number     (0-255)
</code></pre></div></div>
<p>The dimensions of Rotation/Scaling BG Maps depend on the BG size. For size 0-3
that are: 16x16 tiles (128x128 pixels), 32x32 tiles (256x256 pixels), 64x64
tiles (512x512 pixels), or 128x128 tiles (1024x1024 pixels).</p>
<p>The size and VRAM base address of the separate BG maps for BG0-3 are set up by
BG0CNT-BG3CNT registers.</p>
<h2 id=--lcd-vram-bitmap-bg-modes><a name=lcdvrambitmapbgmodes></a> LCD VRAM Bitmap BG Modes</h2>
<p>In BG Modes 3-5 the background is defined in form of a bitmap (unlike as for
Tile/Map based BG modes). Bitmaps are implemented as BG2, with Rotation/Scaling
support. As bitmap modes are occupying 80KBytes of BG memory, only 16KBytes of
VRAM can be used for OBJ tiles.</p>
<h3 id=bg-mode-3---240x160-pixels-32768-colors>BG Mode 3 - 240x160 pixels, 32768 colors</h3>
<p>Two bytes are associated to each pixel, directly defining one of the 32768
colors (without using palette data, and thus not supporting a ‘transparent’ BG
color).</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-4   Red Intensity   (0-31)
  5-9   Green Intensity (0-31)
  10-14 Blue Intensity  (0-31)
  15    Not used in GBA Mode (in NDS Mode: Alpha=0=Transparent, Alpha=1=Normal)
</code></pre></div></div>
<p>The first 480 bytes define the topmost line, the next 480 the next line, and so
on. The background occupies 75 KBytes (06000000-06012BFF), most of the 80
Kbytes BG area, not allowing to redraw an invisible second frame in background,
so this mode is mostly recommended for still images only.</p>
<h3 id=bg-mode-4---240x160-pixels-256-colors-out-of-32768-colors>BG Mode 4 - 240x160 pixels, 256 colors (out of 32768 colors)</h3>
<p>One byte is associated to each pixel, selecting one of the 256 palette entries.
Color 0 (backdrop) is transparent, and OBJs may be displayed behind the bitmap.</p>
<p>The first 240 bytes define the topmost line, the next 240 the next line, and so
on. The background occupies 37.5 KBytes, allowing two frames to be used
(06000000-060095FF for Frame 0, and 0600A000-060135FF for Frame 1).</p>
<h3 id=bg-mode-5---160x128-pixels-32768-colors>BG Mode 5 - 160x128 pixels, 32768 colors</h3>
<p>Colors are defined as for Mode 3 (see above), but horizontal and vertical size
are cut down to 160x128 pixels only - smaller than the physical dimensions of
the LCD screen.</p>
<p>The background occupies exactly 40 KBytes, so that BG VRAM may be split into
two frames (06000000-06009FFF for Frame 0, and 0600A000-06013FFF for Frame 1).</p>
<p>In BG modes 4,5, one Frame may be displayed (selected by DISPCNT Bit 4), the
other Frame is invisible and may be redrawn in background.</p>
<h2 id=--lcd-obj---overview><a name=lcdobjoverview></a> LCD OBJ - Overview</h2>
<h3 id=general>General</h3>
<p>Objects (OBJs) are moveable sprites. Up to 128 OBJs (of any size, up to 64x64
dots each) can be displayed per screen, and under best circumstances up to 128
OBJs (of small 8x8 dots size) can be displayed per horizontal display line.</p>
<h3 id=maximum-number-of-sprites-per-line>Maximum Number of Sprites per Line</h3>
<p>The total available OBJ rendering cycles per line are</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  1210  (=304*4-6)   If "H-Blank Interval Free" bit in DISPCNT register is 0
  954   (=240*4-6)   If "H-Blank Interval Free" bit in DISPCNT register is 1
</code></pre></div></div>
<p>The required rendering cycles are (depending on horizontal OBJ size)</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Cycles per &lt;n&gt; Pixels    OBJ Type              OBJ Type Screen Pixel Range
  n*1 cycles               Normal OBJs           8..64 pixels
  10+n*2 cycles            Rotation/Scaling OBJs 8..64 pixels   (area clipped)
  10+n*2 cycles            Rotation/Scaling OBJs 16..128 pixels (double size)
</code></pre></div></div>
<p>Caution:</p>
<p>The maximum number of OBJs per line is also affected by undisplayed (offscreen)
OBJs which are having higher priority than displayed OBJs.</p>
<p>To avoid this, move displayed OBJs to the begin of OAM memory (ie. OBJ0 has
highest priority, OBJ127 lowest).</p>
<p>Otherwise (in case that the program logic expects OBJs at fixed positions in
OAM) at least take care to set the OBJ size of undisplayed OBJs to 8x8 with
Rotation/Scaling disabled (this reduces the overload).</p>
<p>Does the above also apply for VERTICALLY OFFSCREEN (or VERTICALLY not on
CURRENT LINE) sprites ?</p>
<h3 id=vram---character-data>VRAM - Character Data</h3>
<p>OBJs are always combined of one or more 8x8 pixel Tiles (much like BG Tiles in
BG Modes 0-2). However, OBJ Tiles are stored in a separate area in VRAM:
06010000-06017FFF (32 KBytes) in BG Mode 0-2, or 06014000-06017FFF (16 KBytes)
in BG Mode 3-5.</p>
<p>Depending on the size of the above area (16K or 32K), and on the OBJ color
depth (4bit or 8bit), 256-1024 8x8 dots OBJ Tiles can be defined.</p>
<h3 id=oam---object-attribute-memory>OAM - Object Attribute Memory</h3>
<p>This memory area contains Attributes which specify position, size, color depth,
etc. appearance for each of the 128 OBJs. Additionally, it contains 32 OBJ
Rotation/Scaling Parameter groups. OAM is located at 07000000-070003FF (sized 1
KByte).</p>
<h2 id=--lcd-obj---oam-attributes><a name=lcdobjoamattributes></a> LCD OBJ - OAM Attributes</h2>
<h3 id=obj-attributes>OBJ Attributes</h3>
<p>There are 128 entries in OAM for each OBJ0-OBJ127. Each entry consists of 6
bytes (three 16bit Attributes). Attributes for OBJ0 are located at 07000000,
for OBJ1 at 07000008, OBJ2 at 07000010, and so on.</p>
<p>As you can see, there are blank spaces at 07000006, 0700000E, 07000016, etc. -
these 16bit values are used for OBJ Rotation/Scaling (as described in the next
chapter) - they are not directly related to the separate OBJs.</p>
<h3 id=obj-attribute-0-rw>OBJ Attribute 0 (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-7   Y-Coordinate           (0-255)
  8     Rotation/Scaling Flag  (0=Off, 1=On)
  When Rotation/Scaling used (Attribute 0, bit 8 set):
    9     Double-Size Flag     (0=Normal, 1=Double)
  When Rotation/Scaling not used (Attribute 0, bit 8 cleared):
    9     OBJ Disable          (0=Normal, 1=Not displayed)
  10-11 OBJ Mode  (0=Normal, 1=Semi-Transparent, 2=OBJ Window, 3=Prohibited)
  12    OBJ Mosaic             (0=Off, 1=On)
  13    Colors/Palettes        (0=16/16, 1=256/1)
  14-15 OBJ Shape              (0=Square,1=Horizontal,2=Vertical,3=Prohibited)
</code></pre></div></div>
<p>Caution: A very large OBJ (of 128 pixels vertically, ie. a 64 pixels OBJ in a
Double Size area) located at Y&gt;128 will be treated as at Y&gt;-128, the OBJ
is then displayed parts offscreen at the TOP of the display, it is then NOT
displayed at the bottom.</p>
<h3 id=obj-attribute-1-rw>OBJ Attribute 1 (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-8   X-Coordinate           (0-511)
  When Rotation/Scaling used (Attribute 0, bit 8 set):
    9-13  Rotation/Scaling Parameter Selection (0-31)
          (Selects one of the 32 Rotation/Scaling Parameters that
          can be defined in OAM, for details read next chapter.)
  When Rotation/Scaling not used (Attribute 0, bit 8 cleared):
    9-11  Not used
    12    Horizontal Flip      (0=Normal, 1=Mirrored)
    13    Vertical Flip        (0=Normal, 1=Mirrored)
  14-15 OBJ Size               (0..3, depends on OBJ Shape, see Attr 0)
          Size  Square   Horizontal  Vertical
          0     8x8      16x8        8x16
          1     16x16    32x8        8x32
          2     32x32    32x16       16x32
          3     64x64    64x32       32x64
</code></pre></div></div>
<h3 id=obj-attribute-2-rw>OBJ Attribute 2 (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-9   Character Name          (0-1023=Tile Number)
  10-11 Priority relative to BG (0-3; 0=Highest)
  12-15 Palette Number   (0-15) (Not used in 256 color/1 palette mode)
</code></pre></div></div>
<h3 id=notes>Notes:</h3>
<h3 id=obj-mode>OBJ Mode</h3>
<p>The OBJ Mode may be Normal, Semi-Transparent, or OBJ Window.</p>
<p>Semi-Transparent means that the OBJ is used as ‘Alpha Blending 1st Target’
(regardless of BLDCNT register, for details see chapter about Color Special
Effects).</p>
<p>OBJ Window means that the OBJ is not displayed, instead, dots with non-zero
color are used as mask for the OBJ Window, see DISPCNT and WINOUT for details.</p>
<h3 id=obj-tile-number>OBJ Tile Number</h3>
<p>There are two situations which may divide the amount of available tiles by two
(by four if both situations apply):</p>
<ol>
 <li>
 <p>When using the 256 Colors/1 Palette mode, only each second tile may be used,
the lower bit of the tile number should be zero (in 2-dimensional mapping mode,
the bit is completely ignored).</p>
 </li>
 <li>
 <p>When using BG Mode 3-5 (Bitmap Modes), only tile numbers 512-1023 may be
used. That is because lower 16K of OBJ memory are used for BG. Attempts to use
tiles 0-511 are ignored (not displayed).</p>
 </li>
</ol>
<h3 id=priority>Priority</h3>
<p>In case that the ‘Priority relative to BG’ is the same than the priority of one
of the background layers, then the OBJ becomes higher priority and is displayed
on top of that BG layer.</p>
<p>Caution: Take care not to mess up BG Priority and OBJ priority. For example,
the following would cause garbage to be displayed:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  OBJ No. 0 with Priority relative to BG=1   ;hi OBJ prio, lo BG prio
  OBJ No. 1 with Priority relative to BG=0   ;lo OBJ prio, hi BG prio
</code></pre></div></div>
<p>That is, OBJ0 is always having priority above OBJ1-127, so assigning a lower BG
Priority to OBJ0 than for OBJ1-127 would be a bad idea.</p>
<h2 id=--lcd-obj---oam-rotationscaling-parameters><a name=lcdobjoamrotationscalingparameters></a> LCD OBJ - OAM Rotation/Scaling Parameters</h2>
<p>As described in the previous chapter, there are blank spaces between each of
the 128 OBJ Attribute Fields in OAM memory. These 128 16bit gaps are used to
store OBJ Rotation/Scaling Parameters.</p>
<h3 id=location-of-rotationscaling-parameters-in-oam>Location of Rotation/Scaling Parameters in OAM</h3>
<p>Four 16bit parameters (PA,PB,PC,PD) are required to define a complete group of
Rotation/Scaling data. These are spread across OAM as such:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  1st Group - PA=07000006, PB=0700000E, PC=07000016, PD=0700001E
  2nd Group - PA=07000026, PB=0700002E, PC=07000036, PD=0700003E
  etc.
</code></pre></div></div>
<p>By using all blank space (128 x 16bit), up to 32 of these groups (4 x 16bit
each) can be defined in OAM.</p>
<h3 id=obj-rotationscaling-papbpcpd-parameters-rw>OBJ Rotation/Scaling PA,PB,PC,PD Parameters (R/W)</h3>
<p>Each OBJ that uses Rotation/Scaling may select between any of the above 32
parameter groups. For details, refer to the previous chapter about OBJ
Attributes.</p>
<p>The meaning of the separate PA,PB,PC,PD values is identical as for BG, for
details read the chapter about BG Rotation/Scaling.</p>
<h3 id=obj-reference-point--rotation-center>OBJ Reference Point &amp; Rotation Center</h3>
<p>The OBJ Reference Point is the upper left of the OBJ, ie. OBJ X/Y coordinates:
X+0, Y+0.</p>
<p>The OBJ Rotation Center is always (or should be usually?) in the middle of the
object, ie. for a 8x32 pixel OBJ, this would be at the OBJ X/Y coordinates:
X+4, and Y+16.</p>
<h3 id=obj-double-size-bit-for-objs-that-use-rotationscaling>OBJ Double-Size Bit (for OBJs that use Rotation/Scaling)</h3>
<p>When Double-Size is zero: The sprite is rotated, and then display inside of the
normal-sized (not rotated) rectangular area - the edges of the rotated sprite
will become invisible if they reach outside of that area.</p>
<p>When Double-Size is set: The sprite is rotated, and then display inside of the
double-sized (not rotated) rectangular area - this ensures that the edges of
the rotated sprite remain visible even if they would reach outside of the
normal-sized area. (Except that, for example, rotating a 8x32 pixel sprite by
90 degrees would still cut off parts of the sprite as the double-size area
isn’t large enough.)</p>
<h2 id=--lcd-obj---vram-character-tile-mapping><a name=lcdobjvramcharactertilemapping></a> LCD OBJ - VRAM Character (Tile) Mapping</h2>
<p>Each OBJ tile consists of 8x8 dots, however, bigger OBJs can be displayed by
combining several 8x8 tiles. The horizontal and vertical size for each OBJ may
be separately defined in OAM, possible H/V sizes are 8,16,32,64 dots - allowing
‘square’ OBJs to be used (such like 8x8, 16x16, etc) as well as ‘rectangular’
OBJs (such like 8x32, 64x16, etc.)</p>
<p>When displaying an OBJ that contains of more than one 8x8 tile, one of the
following two mapping modes can be used. In either case, the tile number of the
upperleft tile must be specified in OAM memory.</p>
<h3 id=two-dimensional-character-mapping-dispcnt-bit-6-cleared>Two Dimensional Character Mapping (DISPCNT Bit 6 cleared)</h3>
<p>This mapping mode assumes that the 1024 OBJ tiles are arranged as a matrix of
32x32 tiles / 256x256 pixels (In 256 color mode: 16x32 tiles / 128x256 pixels).
Ie. the upper row of this matrix contains tiles 00h-1Fh, the next row tiles
20h-3Fh, and so on.</p>
<p>For example, when displaying a 16x16 pixel OBJ, with tile number set to 04h;
The upper row of the OBJ will consist of tile 04h and 05h, the next row of 24h
and 25h. (In 256 color mode: 04h and 06h, 24h and 26h.)</p>
<h3 id=one-dimensional-character-mapping-dispcnt-bit-6-set>One Dimensional Character Mapping (DISPCNT Bit 6 set)</h3>
<p>In this mode, tiles are mapped each after each other from 00h-3FFh.</p>
<p>Using the same example as above, the upper row of the OBJ will consist of tile
04h and 05h, the next row of tile 06h and 07h. (In 256 color mode: 04h and 06h,
08h and 0Ah.)</p>
<h2 id=--lcd-color-palettes><a name=lcdcolorpalettes></a> LCD Color Palettes</h2>
<h3 id=color-palette-ram>Color Palette RAM</h3>
<p>BG and OBJ palettes are using separate memory regions:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  05000000-050001FF - BG Palette RAM (512 bytes, 256 colors)
  05000200-050003FF - OBJ Palette RAM (512 bytes, 256 colors)
</code></pre></div></div>
<p>Each BG and OBJ palette RAM may be either split into 16 palettes with 16 colors
each, or may be used as a single palette with 256 colors.</p>
<p>Note that some OBJs may access palette RAM in 16 color mode, while other OBJs
may use 256 color mode at the same time. Same for BG0-BG3 layers.</p>
<h3 id=transparent-colors>Transparent Colors</h3>
<p>Color 0 of all BG and OBJ palettes is transparent. Even though palettes are
described as 16 (256) color palettes, only 15 (255) colors are actually
visible.</p>
<h3 id=backdrop-color>Backdrop Color</h3>
<p>Color 0 of BG Palette 0 is used as backdrop color. This color is displayed if
an area of the screen is not covered by any non-transparent BG or OBJ dots.</p>
<h3 id=color-definitions>Color Definitions</h3>
<p>Each color occupies two bytes (same as for 32768 color BG modes):</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-4   Red Intensity   (0-31)
  5-9   Green Intensity (0-31)
  10-14 Blue Intensity  (0-31)
  15    Not used
</code></pre></div></div>
<h3 id=intensities>Intensities</h3>
<p>Under normal circumstances (light source/viewing angle), the intensities 0-14
are practically all black, and only intensities 15-31 are resulting in visible
medium..bright colors.</p>
<p>Note: The intensity problem appears in the 8bit CGB “compatibility” mode
either. The original CGB display produced the opposite effect: Intensities 0-14
resulted in dark..medium colors, and intensities 15-31 resulted in bright
colors. Any “medium” colors of CGB games will appear invisible/black on GBA
hardware, and only very bright colors will be visible.</p>
<h2 id=--lcd-dimensions-and-timings><a name=lcddimensionsandtimings></a> LCD Dimensions and Timings</h2>
<h3 id=horizontal-dimensions>Horizontal Dimensions</h3>
<p>The drawing time for each dot is 4 CPU cycles.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Visible     240 dots,  57.221 us,    960 cycles - 78% of h-time
  H-Blanking   68 dots,  16.212 us,    272 cycles - 22% of h-time
  Total       308 dots,  73.433 us,   1232 cycles - ca. 13.620 kHz
</code></pre></div></div>
<p>VRAM and Palette RAM may be accessed during H-Blanking. OAM can accessed only
if “H-Blank Interval Free” bit in DISPCNT register is set.</p>
<h3 id=vertical-dimensions>Vertical Dimensions</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Visible (*) 160 lines, 11.749 ms, 197120 cycles - 70% of v-time
  V-Blanking   68 lines,  4.994 ms,  83776 cycles - 30% of v-time
  Total       228 lines, 16.743 ms, 280896 cycles - ca. 59.737 Hz
</code></pre></div></div>
<p>All VRAM, OAM, and Palette RAM may be accessed during V-Blanking.</p>
<p>Note that no H-Blank interrupts are generated within V-Blank period.</p>
<h3 id=system-clock>System Clock</h3>
<p>The system clock is 16.78MHz (16*1024*1024 Hz), one cycle is thus approx.
59.59ns.</p>
<p>(*) Even though vertical screen size is 160 lines, the upper 8 lines are not
&lt;really&gt; visible, these lines are covered by a shadow when holding the
GBA orientated towards a light source, the lines are effectively black - and
should not be used to display important information.</p>
<h3 id=interlace>Interlace</h3>
<p>The LCD display is using some sort of interlace in which even scanlines are
dimmed in each second frame, and odd scanlines are dimmed in each other frame
(it does always render ALL lines in ALL frames, but half of them are dimmed).</p>
<p>The effect can be seen when displaying some horizontal lines in each second
frame, and hiding them in each other frame: the hardware will randomly show the
lines in dimmed or non-dimmed form (depending on whether the test was started
in an even or odd frame).</p>
<p>Unknown if it’s possible to determine the even/off frame state by software (or
possibly to reset the hardware to this or that state by software).</p>
<p>Note: The NDS is applying some sort of frameskip to GBA games, about every 3
seconds there will by a missing (or maybe: inserted) frame, ie. a GBA game that
is updating the display in sync with GBA interlace will get offsync on NDS
consoles.</p>
<h2 id=--gba-sound-controller><a name=gbasoundcontroller></a> GBA Sound Controller</h2>
<p>The GBA supplies four ‘analogue’ sound channels for Tone and Noise (mostly
compatible to CGB sound), as well as two ‘digital’ sound channels (which can be
used to replay 8bit DMA sample data).</p>
<ul>
 <li><a href=#gbasoundchannel1tonesweep>GBA Sound Channel 1 - Tone &amp; Sweep</a></li>
 <li><a href=#gbasoundchannel2tone>GBA Sound Channel 2 - Tone</a></li>
 <li><a href=#gbasoundchannel3waveoutput>GBA Sound Channel 3 - Wave Output</a></li>
 <li><a href=#gbasoundchannel4noise>GBA Sound Channel 4 - Noise</a></li>
 <li>
 <p><a href=#gbasoundchannelaandbdmasound>GBA Sound Channel A and B - DMA Sound</a></p>
 </li>
 <li><a href=#gbasoundcontrolregisters>GBA Sound Control Registers</a></li>
 <li><a href=#gbacomparisonofcgbandgbasound>GBA Comparison of CGB and GBA Sound</a></li>
</ul>
<p>The GBA includes only a single (mono) speaker built-in, each channel may be
output to either left and/or right channels by using the external line-out
connector (for stereo headphones, etc).</p>
<h2 id=--gba-sound-channel-1---tone--sweep><a name=gbasoundchannel1tonesweep></a> GBA Sound Channel 1 - Tone &amp; Sweep</h2>
<h3 id=4000060h---sound1cnt_l-nr10---channel-1-sweep-register-rw>4000060h - SOUND1CNT_L (NR10) - Channel 1 Sweep register (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit        Expl.
  0-2   R/W  Number of sweep shift      (n=0-7)
  3     R/W  Sweep Frequency Direction  (0=Increase, 1=Decrease)
  4-6   R/W  Sweep Time; units of 7.8ms (0-7, min=7.8ms, max=54.7ms)
  7-15  -    Not used
</code></pre></div></div>
<p>Sweep is disabled by setting Sweep Time to zero, if so, the direction bit
should be set.</p>
<p>The change of frequency (NR13,NR14) at each shift is calculated by the
following formula where X(0) is initial freq &amp; X(t-1) is last freq:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  X(t) = X(t-1) +/- X(t-1)/2^n
</code></pre></div></div>
<h3 id=4000062h---sound1cnt_h-nr11-nr12---channel-1-dutylenenvelope-rw>4000062h - SOUND1CNT_H (NR11, NR12) - Channel 1 Duty/Len/Envelope (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit        Expl.
  0-5   W    Sound length; units of (64-n)/256s  (0-63)
  6-7   R/W  Wave Pattern Duty                   (0-3, see below)
  8-10  R/W  Envelope Step-Time; units of n/64s  (1-7, 0=No Envelope)
  11    R/W  Envelope Direction                  (0=Decrease, 1=Increase)
  12-15 R/W  Initial Volume of envelope          (1-15, 0=No Sound)
</code></pre></div></div>
<p>Wave Duty:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  0: 12.5% ( -_______-_______-_______ )
  1: 25%   ( --______--______--______ )
  2: 50%   ( ----____----____----____ ) (normal)
  3: 75%   ( ------__------__------__ )
</code></pre></div></div>
<p>The Length value is used only if Bit 6 in NR14 is set.</p>
<h3 id=4000064h---sound1cnt_x-nr13-nr14---channel-1-frequencycontrol-rw>4000064h - SOUND1CNT_X (NR13, NR14) - Channel 1 Frequency/Control (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit        Expl.
  0-10  W    Frequency; 131072/(2048-n)Hz  (0-2047)
  11-13 -    Not used
  14    R/W  Length Flag  (1=Stop output when length in NR11 expires)
  15    W    Initial      (1=Restart Sound)
  16-31 -    Not used
</code></pre></div></div>
<h2 id=--gba-sound-channel-2---tone><a name=gbasoundchannel2tone></a> GBA Sound Channel 2 - Tone</h2>
<p>This sound channel works exactly as channel 1, except that it doesn’t have a
Tone Envelope/Sweep Register.</p>
<h3 id=4000068h---sound2cnt_l-nr21-nr22---channel-2-dutylengthenvelope-rw>4000068h - SOUND2CNT_L (NR21, NR22) - Channel 2 Duty/Length/Envelope (R/W)</h3>
<h3 id=400006ah---not-used>400006Ah - Not used</h3>
<h3 id=400006ch---sound2cnt_h-nr23-nr24---channel-2-frequencycontrol-rw>400006Ch - SOUND2CNT_H (NR23, NR24) - Channel 2 Frequency/Control (R/W)</h3>
<p>For details, refer to channel 1 description.</p>
<h2 id=--gba-sound-channel-3---wave-output><a name=gbasoundchannel3waveoutput></a> GBA Sound Channel 3 - Wave Output</h2>
<p>This channel can be used to output digital sound, the length of the sample
buffer (Wave RAM) can be either 32 or 64 digits (4bit samples). This sound
channel can be also used to output normal tones when initializing the Wave RAM
by a square wave. This channel doesn’t have a volume envelope register.</p>
<h3 id=4000070h---sound3cnt_l-nr30---channel-3-stopwave-ram-select-rw>4000070h - SOUND3CNT_L (NR30) - Channel 3 Stop/Wave RAM select (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit        Expl.
  0-4   -    Not used
  5     R/W  Wave RAM Dimension   (0=One bank/32 digits, 1=Two banks/64 digits)
  6     R/W  Wave RAM Bank Number (0-1, see below)
  7     R/W  Sound Channel 3 Off  (0=Stop, 1=Playback)
  8-15  -    Not used
</code></pre></div></div>
<p>The currently selected Bank Number (Bit 6) will be played back, while
reading/writing to/from wave RAM will address the other (not selected) bank.
When dimension is set to two banks, output will start by replaying the
currently selected bank.</p>
<h3 id=4000072h---sound3cnt_h-nr31-nr32---channel-3-lengthvolume-rw>4000072h - SOUND3CNT_H (NR31, NR32) - Channel 3 Length/Volume (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit        Expl.
  0-7   W    Sound length; units of (256-n)/256s  (0-255)
  8-12  -    Not used.
  13-14 R/W  Sound Volume  (0=Mute/Zero, 1=100%, 2=50%, 3=25%)
  15    R/W  Force Volume  (0=Use above, 1=Force 75% regardless of above)
</code></pre></div></div>
<p>The Length value is used only if Bit 6 in NR34 is set.</p>
<h3 id=4000074h---sound3cnt_x-nr33-nr34---channel-3-frequencycontrol-rw>4000074h - SOUND3CNT_X (NR33, NR34) - Channel 3 Frequency/Control (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit        Expl.
  0-10  W    Sample Rate; 2097152/(2048-n) Hz   (0-2047)
  11-13 -    Not used
  14    R/W  Length Flag  (1=Stop output when length in NR31 expires)
  15    W    Initial      (1=Restart Sound)
  16-31 -    Not used
</code></pre></div></div>
<p>The above sample rate specifies the number of wave RAM digits per second, the
actual tone frequency depends on the wave RAM content, for example:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Wave RAM, single bank 32 digits   Tone Frequency
  FFFFFFFFFFFFFFFF0000000000000000  65536/(2048-n) Hz
  FFFFFFFF00000000FFFFFFFF00000000  131072/(2048-n) Hz
  FFFF0000FFFF0000FFFF0000FFFF0000  262144/(2048-n) Hz
  FF00FF00FF00FF00FF00FF00FF00FF00  524288/(2048-n) Hz
  F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0  1048576/(2048-n) Hz
</code></pre></div></div>
<h3 id=4000090h---wave_ram0_l---channel-3-wave-pattern-ram-wr>4000090h - WAVE_RAM0_L - Channel 3 Wave Pattern RAM (W/R)</h3>
<h3 id=4000092h---wave_ram0_h---channel-3-wave-pattern-ram-wr>4000092h - WAVE_RAM0_H - Channel 3 Wave Pattern RAM (W/R)</h3>
<h3 id=4000094h---wave_ram1_l---channel-3-wave-pattern-ram-wr>4000094h - WAVE_RAM1_L - Channel 3 Wave Pattern RAM (W/R)</h3>
<h3 id=4000096h---wave_ram1_h---channel-3-wave-pattern-ram-wr>4000096h - WAVE_RAM1_H - Channel 3 Wave Pattern RAM (W/R)</h3>
<h3 id=4000098h---wave_ram2_l---channel-3-wave-pattern-ram-wr>4000098h - WAVE_RAM2_L - Channel 3 Wave Pattern RAM (W/R)</h3>
<h3 id=400009ah---wave_ram2_h---channel-3-wave-pattern-ram-wr>400009Ah - WAVE_RAM2_H - Channel 3 Wave Pattern RAM (W/R)</h3>
<h3 id=400009ch---wave_ram3_l---channel-3-wave-pattern-ram-wr>400009Ch - WAVE_RAM3_L - Channel 3 Wave Pattern RAM (W/R)</h3>
<h3 id=400009eh---wave_ram3_h---channel-3-wave-pattern-ram-wr>400009Eh - WAVE_RAM3_H - Channel 3 Wave Pattern RAM (W/R)</h3>
<p>This area contains 16 bytes (32 x 4bits) Wave Pattern data which is output by
channel 3. Data is played back ordered as follows: MSBs of 1st byte, followed
by LSBs of 1st byte, followed by MSBs of 2nd byte, and so on - this results in
a confusing ordering when filling Wave RAM in units of 16bit data - ie. samples
would be then located in Bits 4-7, 0-3, 12-15, 8-11.</p>
<p>In the GBA, two Wave Patterns exists (each 32 x 4bits), either one may be
played (as selected in NR30 register), the other bank may be accessed by the
users. After all 32 samples have been played, output of the same bank (or other
bank, as specified in NR30) will be automatically restarted.</p>
<p>Internally, Wave RAM is a giant shift-register, there is no pointer which is
addressing the currently played digit. Instead, the entire 128 bits are
shifted, and the 4 least significant bits are output.</p>
<p>Thus, when reading from Wave RAM, data might have changed its position. And,
when writing to Wave RAM all data should be updated (it’d be no good idea to
assume that old data is still located at the same position where it has been
written to previously).</p>
<h2 id=--gba-sound-channel-4---noise><a name=gbasoundchannel4noise></a> GBA Sound Channel 4 - Noise</h2>
<p>This channel is used to output white noise. This is done by randomly switching
the amplitude between high and low at a given frequency. Depending on the
frequency the noise will appear ‘harder’ or ‘softer’.</p>
<p>It is also possible to influence the function of the random generator, so the
that the output becomes more regular, resulting in a limited ability to output
Tone instead of Noise.</p>
<h3 id=4000078h---sound4cnt_l-nr41-nr42---channel-4-lengthenvelope-rw>4000078h - SOUND4CNT_L (NR41, NR42) - Channel 4 Length/Envelope (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit        Expl.
  0-5   W    Sound length; units of (64-n)/256s  (0-63)
  6-7   -    Not used
  8-10  R/W  Envelope Step-Time; units of n/64s  (1-7, 0=No Envelope)
  11    R/W  Envelope Direction                  (0=Decrease, 1=Increase)
  12-15 R/W  Initial Volume of envelope          (1-15, 0=No Sound)
  16-31 -    Not used
</code></pre></div></div>
<p>The Length value is used only if Bit 6 in NR44 is set.</p>
<h3 id=400007ch---sound4cnt_h-nr43-nr44---channel-4-frequencycontrol-rw>400007Ch - SOUND4CNT_H (NR43, NR44) - Channel 4 Frequency/Control (R/W)</h3>
<p>The amplitude is randomly switched between high and low at the given frequency.
A higher frequency will make the noise to appear ‘softer’.</p>
<p>When Bit 3 is set, the output will become more regular, and some frequencies
will sound more like Tone than Noise.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit        Expl.
  0-2   R/W  Dividing Ratio of Frequencies (r)
  3     R/W  Counter Step/Width (0=15 bits, 1=7 bits)
  4-7   R/W  Shift Clock Frequency (s)
  8-13  -    Not used
  14    R/W  Length Flag  (1=Stop output when length in NR41 expires)
  15    W    Initial      (1=Restart Sound)
  16-31 -    Not used
</code></pre></div></div>
<p>Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead</p>
<h3 id=noise-random-generator-aka-polynomial-counter>Noise Random Generator (aka Polynomial Counter)</h3>
<p>Noise randomly switches between HIGH and LOW levels, the output levels are
calculated by a shift register (X), at the selected frequency, as such:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  7bit:  X=X SHR 1, IF carry THEN Out=HIGH, X=X XOR 60h ELSE Out=LOW
  15bit: X=X SHR 1, IF carry THEN Out=HIGH, X=X XOR 6000h ELSE Out=LOW
</code></pre></div></div>
<p>The initial value when (re-)starting the sound is X=40h (7bit) or X=4000h
(15bit). The data stream repeats after 7Fh (7bit) or 7FFFh (15bit) steps.</p>
<h2 id=--gba-sound-channel-a-and-b---dma-sound><a name=gbasoundchannelaandbdmasound></a> GBA Sound Channel A and B - DMA Sound</h2>
<p>The GBA contains two DMA sound channels (A and B), each allowing to replay
digital sound (signed 8bit data, ie. -128..+127). Data can be transferred from
INTERNAL memory (not sure if EXTERNAL memory works also ?) to FIFO by using DMA
channel 1 or 2, the sample rate is generated by using one of the Timers.</p>
<h3 id=40000a0h---fifo_a_l---sound-a-fifo-data-0-and-data-1-w>40000A0h - FIFO_A_L - Sound A FIFO, Data 0 and Data 1 (W)</h3>
<h3 id=40000a2h---fifo_a_h---sound-a-fifo-data-2-and-data-3-w>40000A2h - FIFO_A_H - Sound A FIFO, Data 2 and Data 3 (W)</h3>
<p>These two registers may receive 32bit (4 bytes) of audio data (Data 0-3, Data 0
being located in least significant byte which is replayed first).</p>
<p>Internally, the capacity of the FIFO is 8 x 32bit (32 bytes), allowing to
buffer a small amount of samples. As the name says (First In First Out), oldest
data is replayed first.</p>
<h3 id=40000a4h---fifo_b_l---sound-b-fifo-data-0-and-data-1-w>40000A4h - FIFO_B_L - Sound B FIFO, Data 0 and Data 1 (W)</h3>
<h3 id=40000a6h---fifo_b_h---sound-b-fifo-data-2-and-data-3-w>40000A6h - FIFO_B_H - Sound B FIFO, Data 2 and Data 3 (W)</h3>
<p>Same as above, for Sound B.</p>
<h3 id=initializing-dma-sound-playback>Initializing DMA-Sound Playback</h3>
<ul>
 <li>
 <p>Select Timer 0 or 1 in SOUNDCNT_H control register.</p>
 </li>
 <li>
 <p>Clear the FIFO.</p>
 </li>
 <li>
 <p>Manually write a sample byte to the FIFO.</p>
 </li>
 <li>
 <p>Initialize transfer mode for DMA 1 or 2.</p>
 </li>
 <li>
 <p>Initialize DMA Sound settings in sound control register.</p>
 </li>
 <li>
 <p>Start the timer.</p>
 </li>
</ul>
<h3 id=dma-sound-playback-procedure>DMA-Sound Playback Procedure</h3>
<p>The pseudo-procedure below is automatically repeated.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  If Timer overflows then
    Move 8bit data from FIFO to sound circuit.
    If FIFO contains only 4 x 32bits (16 bytes) then
      Request more data per DMA
      Receive 4 x 32bit (16 bytes) per DMA
    Endif
  Endif
</code></pre></div></div>
<p>This playback mechanism will be repeated forever, regardless of the actual
length of the sample buffer.</p>
<h3 id=synchronizing-sample-buffers>Synchronizing Sample Buffers</h3>
<p>The buffer-end may be determined by counting sound Timer IRQs (each sample
byte), or sound DMA IRQs (each 16th sample byte). Both methods would require a
lot of CPU time (IRQ processing), and both would fail if interrupts are
disabled for a longer period.</p>
<p>Better solutions would be to synchronize the sample rate/buffer length with
V-blanks, or to use a second timer (in count up/slave mode) which produces an
IRQ after the desired number of samples.</p>
<h3 id=the-sample-rate>The Sample Rate</h3>
<p>The GBA hardware does internally re-sample all sound output to 32.768kHz
(default SOUNDBIAS setting). It’d thus do not make much sense to use higher
DMA/Timer rates. Best re-sampling accuracy can be gained by using DMA/Timer
rates of 32.768kHz, 16.384kHz, or 8.192kHz (ie. fragments of the physical
output rate).</p>
<h2 id=--gba-sound-control-registers><a name=gbasoundcontrolregisters></a> GBA Sound Control Registers</h2>
<h3 id=4000080h---soundcnt_l-nr50-nr51---channel-lr-volumeenable-rw>4000080h - SOUNDCNT_L (NR50, NR51) - Channel L/R Volume/Enable (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit        Expl.
  0-2   R/W  Sound 1-4 Master Volume RIGHT (0-7)
  3     -    Not used
  4-6   R/W  Sound 1-4 Master Volume LEFT (0-7)
  7     -    Not used
  8-11  R/W  Sound 1-4 Enable Flags RIGHT (each Bit 8-11, 0=Disable, 1=Enable)
  12-15 R/W  Sound 1-4 Enable Flags LEFT (each Bit 12-15, 0=Disable, 1=Enable)
</code></pre></div></div>
<h3 id=4000082h---soundcnt_h-gba-only---dma-sound-controlmixing-rw>4000082h - SOUNDCNT_H (GBA only) - DMA Sound Control/Mixing (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit        Expl.
  0-1   R/W  Sound # 1-4 Volume   (0=25%, 1=50%, 2=100%, 3=Prohibited)
  2     R/W  DMA Sound A Volume   (0=50%, 1=100%)
  3     R/W  DMA Sound B Volume   (0=50%, 1=100%)
  4-7   -    Not used
  8     R/W  DMA Sound A Enable RIGHT (0=Disable, 1=Enable)
  9     R/W  DMA Sound A Enable LEFT  (0=Disable, 1=Enable)
  10    R/W  DMA Sound A Timer Select (0=Timer 0, 1=Timer 1)
  11    W?   DMA Sound A Reset FIFO   (1=Reset)
  12    R/W  DMA Sound B Enable RIGHT (0=Disable, 1=Enable)
  13    R/W  DMA Sound B Enable LEFT  (0=Disable, 1=Enable)
  14    R/W  DMA Sound B Timer Select (0=Timer 0, 1=Timer 1)
  15    W?   DMA Sound B Reset FIFO   (1=Reset)
</code></pre></div></div>
<h3 id=4000084h---soundcnt_x-nr52---sound-onoff-rw>4000084h - SOUNDCNT_X (NR52) - Sound on/off (R/W)</h3>
<p>Bits 0-3 are automatically set when starting sound output, and are
automatically cleared when a sound ends. (Ie. when the length expires, as far
as length is enabled. The bits are NOT reset when an volume envelope ends.)</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit        Expl.
  0     R    Sound 1 ON flag (Read Only)
  1     R    Sound 2 ON flag (Read Only)
  2     R    Sound 3 ON flag (Read Only)
  3     R    Sound 4 ON flag (Read Only)
  4-6   -    Not used
  7     R/W  PSG/FIFO Master Enable (0=Disable, 1=Enable) (Read/Write)
  8-31  -    Not used
</code></pre></div></div>
<p>While Bit 7 is cleared, both PSG and FIFO sounds are disabled, and all PSG
registers at 4000060h..4000081h are reset to zero (and must be re-initialized
after re-enabling sound). However, registers 4000082h and 4000088h are kept
read/write-able (of which, 4000082h has no function when sound is off, whilst
4000088h does work even when sound is off).</p>
<h3 id=4000088h---soundbias---sound-pwm-control-rw-see-below>4000088h - SOUNDBIAS - Sound PWM Control (R/W, see below)</h3>
<p>This register controls the final sound output. The default setting is 0200h, it
is normally not required to change this value.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit        Expl.
  0     -    Not used
  1-9   R/W  Bias Level (Default=100h, converting signed samples into unsigned)
  10-13 -    Not used
  14-15 R/W  Amplitude Resolution/Sampling Cycle (Default=0, see below)
  16-31 -    Not used
</code></pre></div></div>
<p>Amplitude Resolution/Sampling Cycle (0-3):</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  0  9bit / 32.768kHz   (Default, best for DMA channels A,B)
  1  8bit / 65.536kHz
  2  7bit / 131.072kHz
  3  6bit / 262.144kHz  (Best for PSG channels 1-4)
</code></pre></div></div>
<p>For more information on this register, read the descriptions below.</p>
<h3 id=400008ch---not-used>400008Ch - Not used</h3>
<h3 id=400008eh---not-used>400008Eh - Not used</h3>
<h3 id=max-output-levels-with-max-volume-settings>Max Output Levels (with max volume settings)</h3>
<p>Each of the two FIFOs can span the FULL output range (+/-200h).</p>
<p>Each of the four PSGs can span one QUARTER of the output range (+/-80h).</p>
<p>The current output levels of all six channels are added together by hardware.</p>
<p>So together, the FIFOs and PSGs, could reach THRICE the range (+/-600h).</p>
<p>The BIAS value is added to that signed value. With default BIAS (200h), the
possible range becomes -400h..+800h, however, values that exceed the unsigned
10bit output range of 0..3FFh are clipped to MinMax(0,3FFh).</p>
<h3 id=resampling-to-32768khz--9bit-default>Resampling to 32.768kHz / 9bit (default)</h3>
<p>The PSG channels 1-4 are internally generated at 262.144kHz, and DMA sound A-B
could be theoretically generated at timer rates up to 16.78MHz. However, the
final sound output is resampled to a rate of 32.768kHz, at 9bit depth (the
above 10bit value, divided by two). If necessary, rates higher than 32.768kHz
can be selected in the SOUNDBIAS register, that would result in a depth smaller
than 9bit though.</p>
<h3 id=pwm-pulse-width-modulation-output-1678mhz--1bit>PWM (Pulse Width Modulation) Output 16.78MHz / 1bit</h3>
<p>Okay, now comes the actual output. The GBA can output only two voltages (low
and high), these ‘bits’ are output at system clock speed (16.78MHz). If using
the default 32.768kHz sampling rate, then 512 bits are output per sample
(512*32K=16M). Each sample value (9bit range, N=0..511), would be then output
as N low bits, followed by 512-N high bits. The resulting ‘noise’ is smoothed
down by capacitors, by the speaker, and by human hearing, so that it will
effectively sound like clean D/A converted 9bit voltages at 32kHz sampling
rate.</p>
<h3 id=changing-the-bias-level>Changing the BIAS Level</h3>
<p>Normally use 200h for clean sound output. A value of 000h might make sense
during periods when no sound is output (causing the PWM circuit to output
low-bits only, which is eventually reducing the power consumption, and/or
preventing 32KHz noise). Note: Using the SoundBias function (SWI 19h) allows to
change the level by slowly incrementing or decrementing it (without hard
scratch noise).</p>
<h3 id=low-power-mode>Low Power Mode</h3>
<p>When not using sound output, power consumption can be reduced by setting both
4000084h (PSG/FIFO) and 4000088h (BIAS) to zero.</p>
<h2 id=--gba-comparison-of-cgb-and-gba-sound><a name=gbacomparisonofcgbandgbasound></a> GBA Comparison of CGB and GBA Sound</h2>
<p>The GBA sound controller is mostly the same than that of older monochrome
gameboy and CGB. The following changes have been done:</p>
<h3 id=new-sound-channels>New Sound Channels</h3>
<p>Two new sound channels have been added that may be used to replay 8bit digital
sound. Sample rate and sample data must be supplied by using a Timer and a DMA
channel.</p>
<h3 id=new-control-registers>New Control Registers</h3>
<p>The SOUNDCNT_H register controls the new DMA channels - as well as mixing with
the four old channels. The SOUNDBIAS register controls the final sound output.</p>
<h3 id=sound-channel-3-changes>Sound Channel 3 Changes</h3>
<p>The length of the Wave RAM is doubled by dividing it into two banks of 32
digits each, either one or both banks may be replayed (one after each other),
for details check NR30 Bit 5-6. Optionally, the sound may be output at 75%
volume, for details check NR32 Bit 7.</p>
<h3 id=changed-control-registers>Changed Control Registers</h3>
<p>NR50 is not supporting Vin signals (that’s been an external sound input from
cartridge).</p>
<h3 id=changed-io-addresses>Changed I/O Addresses</h3>
<p>The GBAs sound register are located at 04000060-040000AE instead of at
FF10-FF3F as in CGB and monochrome gameboy. However, note that there have been
new blank spaces inserted between some of the separate registers - therefore it
is NOT possible to port CGB software to GBA just by changing the sound base
address.</p>
<h3 id=accessing-io-registers>Accessing I/O Registers</h3>
<p>In some cases two of the old 8bit registers are packed into a 16bit register
and may be accessed as such.</p>
<h2 id=--gba-timers><a name=gbatimers></a> GBA Timers</h2>
<p>The GBA includes four incrementing 16bit timers.</p>
<p>Timer 0 and 1 can be used to supply the sample rate for DMA sound channel A
and/or B.</p>
<h3 id=4000100h---tm0cnt_l---timer-0-counterreload-rw>4000100h - TM0CNT_L - Timer 0 Counter/Reload (R/W)</h3>
<h3 id=4000104h---tm1cnt_l---timer-1-counterreload-rw>4000104h - TM1CNT_L - Timer 1 Counter/Reload (R/W)</h3>
<h3 id=4000108h---tm2cnt_l---timer-2-counterreload-rw>4000108h - TM2CNT_L - Timer 2 Counter/Reload (R/W)</h3>
<h3 id=400010ch---tm3cnt_l---timer-3-counterreload-rw>400010Ch - TM3CNT_L - Timer 3 Counter/Reload (R/W)</h3>
<p>Writing to these registers initializes the &lt;reload&gt; value (but does not
directly affect the current counter value). Reading returns the current
&lt;counter&gt; value (or the recent/frozen counter value if the timer has been
stopped).</p>
<p>The reload value is copied into the counter only upon following two situations:
Automatically upon timer overflows, or when the timer start bit becomes changed
from 0 to 1.</p>
<p>Note: When simultaneously changing the start bit from 0 to 1, and setting the
reload value at the same time (by a single 32bit I/O operation), then the newly
written reload value is recognized as new counter value.</p>
<h3 id=4000102h---tm0cnt_h---timer-0-control-rw>4000102h - TM0CNT_H - Timer 0 Control (R/W)</h3>
<h3 id=4000106h---tm1cnt_h---timer-1-control-rw>4000106h - TM1CNT_H - Timer 1 Control (R/W)</h3>
<h3 id=400010ah---tm2cnt_h---timer-2-control-rw>400010Ah - TM2CNT_H - Timer 2 Control (R/W)</h3>
<h3 id=400010eh---tm3cnt_h---timer-3-control-rw>400010Eh - TM3CNT_H - Timer 3 Control (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-1   Prescaler Selection (0=F/1, 1=F/64, 2=F/256, 3=F/1024)
  2     Count-up Timing   (0=Normal, 1=See below)  ;Not used in TM0CNT_H
  3-5   Not used
  6     Timer IRQ Enable  (0=Disable, 1=IRQ on Timer overflow)
  7     Timer Start/Stop  (0=Stop, 1=Operate)
  8-15  Not used
</code></pre></div></div>
<p>When Count-up Timing is enabled, the prescaler value is ignored, instead the
time is incremented each time when the previous counter overflows. This
function cannot be used for Timer 0 (as it is the first timer).</p>
<p>F = System Clock (16.78MHz).</p>
<h2 id=--gba-dma-transfers><a name=gbadmatransfers></a> GBA DMA Transfers</h2>
<h3 id=overview-2>Overview</h3>
<p>The GBA includes four DMA channels, the highest priority is assigned to DMA0,
followed by DMA1, DMA2, and DMA3. DMA Channels with lower priority are paused
until channels with higher priority have completed.</p>
<p>The CPU is paused when DMA transfers are active, however, the CPU is operating
during the periods when Sound/Blanking DMA transfers are paused.</p>
<h3 id=special-features-of-the-separate-dma-channels>Special features of the separate DMA channels</h3>
<p>DMA0 - highest priority, best for timing critical transfers (eg. HBlank DMA).</p>
<p>DMA1 and DMA2 - can be used to feed digital sample data to the Sound FIFOs.</p>
<p>DMA3 - can be used to write to Game Pak ROM/FlashROM (but not GamePak SRAM).</p>
<p>Beside for that, each DMA 0-3 may be used for whatever general purposes.</p>
<h3 id=40000b0h0b2h---dma0sad---dma-0-source-address-w-internal-memory>40000B0h,0B2h - DMA0SAD - DMA 0 Source Address (W) (internal memory)</h3>
<h3 id=40000bch0beh---dma1sad---dma-1-source-address-w-any-memory>40000BCh,0BEh - DMA1SAD - DMA 1 Source Address (W) (any memory)</h3>
<h3 id=40000c8h0cah---dma2sad---dma-2-source-address-w-any-memory>40000C8h,0CAh - DMA2SAD - DMA 2 Source Address (W) (any memory)</h3>
<h3 id=40000d4h0d6h---dma3sad---dma-3-source-address-w-any-memory>40000D4h,0D6h - DMA3SAD - DMA 3 Source Address (W) (any memory)</h3>
<p>The most significant address bits are ignored, only the least significant 27 or
28 bits are used (max 07FFFFFFh internal memory, or max 0FFFFFFFh any memory -
except SRAM ?!).</p>
<h3 id=40000b4h0b6h---dma0dad---dma-0-destination-address-w-internal-memory>40000B4h,0B6h - DMA0DAD - DMA 0 Destination Address (W) (internal memory)</h3>
<h3 id=40000c0h0c2h---dma1dad---dma-1-destination-address-w-internal-memory>40000C0h,0C2h - DMA1DAD - DMA 1 Destination Address (W) (internal memory)</h3>
<h3 id=40000cch0ceh---dma2dad---dma-2-destination-address-w-internal-memory>40000CCh,0CEh - DMA2DAD - DMA 2 Destination Address (W) (internal memory)</h3>
<h3 id=40000d8h0dah---dma3dad---dma-3-destination-address-w-any-memory>40000D8h,0DAh - DMA3DAD - DMA 3 Destination Address (W) (any memory)</h3>
<p>The most significant address bits are ignored, only the least significant 27 or
28 bits are used (max. 07FFFFFFh internal memory or 0FFFFFFFh any memory -
except SRAM ?!).</p>
<h3 id=40000b8h---dma0cnt_l---dma-0-word-count-w-14-bit-14000h>40000B8h - DMA0CNT_L - DMA 0 Word Count (W) (14 bit, 1..4000h)</h3>
<h3 id=40000c4h---dma1cnt_l---dma-1-word-count-w-14-bit-14000h>40000C4h - DMA1CNT_L - DMA 1 Word Count (W) (14 bit, 1..4000h)</h3>
<h3 id=40000d0h---dma2cnt_l---dma-2-word-count-w-14-bit-14000h>40000D0h - DMA2CNT_L - DMA 2 Word Count (W) (14 bit, 1..4000h)</h3>
<h3 id=40000dch---dma3cnt_l---dma-3-word-count-w-16-bit-110000h>40000DCh - DMA3CNT_L - DMA 3 Word Count (W) (16 bit, 1..10000h)</h3>
<p>Specifies the number of data units to be transferred, each unit is 16bit or
32bit depending on the transfer type, a value of zero is treated as max length
(ie. 4000h, or 10000h for DMA3).</p>
<h3 id=40000bah---dma0cnt_h---dma-0-control-rw>40000BAh - DMA0CNT_H - DMA 0 Control (R/W)</h3>
<h3 id=40000c6h---dma1cnt_h---dma-1-control-rw>40000C6h - DMA1CNT_H - DMA 1 Control (R/W)</h3>
<h3 id=40000d2h---dma2cnt_h---dma-2-control-rw>40000D2h - DMA2CNT_H - DMA 2 Control (R/W)</h3>
<h3 id=40000deh---dma3cnt_h---dma-3-control-rw>40000DEh - DMA3CNT_H - DMA 3 Control (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-4   Not used
  5-6   Dest Addr Control  (0=Increment,1=Decrement,2=Fixed,3=Increment/Reload)
  7-8   Source Adr Control (0=Increment,1=Decrement,2=Fixed,3=Prohibited)
  9     DMA Repeat                   (0=Off, 1=On) (Must be zero if Bit 11 set)
  10    DMA Transfer Type            (0=16bit, 1=32bit)
  11    Game Pak DRQ  - DMA3 only -  (0=Normal, 1=DRQ &lt;from&gt; Game Pak, DMA3)
  12-13 DMA Start Timing  (0=Immediately, 1=VBlank, 2=HBlank, 3=Special)
          The 'Special' setting (Start Timing=3) depends on the DMA channel:
          DMA0=Prohibited, DMA1/DMA2=Sound FIFO, DMA3=Video Capture
  14    IRQ upon end of Word Count   (0=Disable, 1=Enable)
  15    DMA Enable                   (0=Off, 1=On)
</code></pre></div></div>
<p>After changing the Enable bit from 0 to 1, wait 2 clock cycles before accessing
any DMA related registers.</p>
<p>When accessing OAM (7000000h) or OBJ VRAM (6010000h) by HBlank Timing, then the
“H-Blank Interval Free” bit in DISPCNT register must be set.</p>
<h3 id=source-and-destination-address-and-word-count-registers>Source and Destination Address and Word Count Registers</h3>
<p>The SAD, DAD, and CNT_L registers are holding the initial start addresses, and
initial length. The hardware does NOT change the content of these registers
during or after the transfer.</p>
<p>The actual transfer takes place by using internal pointer/counter registers.
The initial values are copied into internal regs under the following
circumstances:</p>
<p>Upon DMA Enable (Bit 15) changing from 0 to 1: Reloads SAD, DAD, CNT_L.</p>
<p>Upon Repeat: Reloads CNT_L, and optionally DAD (Increment+Reload).</p>
<h3 id=dma-repeat-bit>DMA Repeat bit</h3>
<p>If the Repeat bit is cleared: The Enable bit is automatically cleared after the
specified number of data units has been transferred.</p>
<p>If the Repeat bit is set: The Enable bit remains set after the transfer, and
the transfer will be restarted each time when the Start condition (eg. HBlank,
Fifo) becomes true. The specified number of data units is transferred
&lt;each&gt; time when the transfer is (re-)started. The transfer will be
repeated forever, until it gets stopped by software.</p>
<h3 id=sound-dma-fifo-timing-mode-dma1-and-dma2-only>Sound DMA (FIFO Timing Mode) (DMA1 and DMA2 only)</h3>
<p>In this mode, the DMA Repeat bit must be set, and the destination address must
be FIFO_A (040000A0h) or FIFO_B (040000A4h).</p>
<p>Upon DMA request from sound controller, 4 units of 32bits (16 bytes) are
transferred (both Word Count register and DMA Transfer Type bit are ignored).
The destination address will not be incremented in FIFO mode.</p>
<p>Keep in mind that DMA channels of higher priority may offhold sound DMA. For
example, when using a 64 kHz sample rate, 16 bytes of sound DMA data are
requested each 0.25ms (4 kHz), at this time another 16 bytes are still in the
FIFO so that there’s still 0.25ms time to satisfy the DMA request. Thus DMAs
with higher priority should not be operated for longer than 0.25ms. (This
problem does not arise for HBlank transfers as HBlank time is limited to
16.212us.)</p>
<h3 id=game-pak-dma>Game Pak DMA</h3>
<p>Only DMA 3 may be used to transfer data to/from Game Pak ROM or Flash ROM - it
cannot access Game Pak SRAM though (as SRAM data bus is limited to 8bit units).
In normal mode, DMA is requested as long until Word Count becomes zero. When
setting the ‘Game Pack DRQ’ bit, then the cartridge must contain an external
circuit which outputs a /DREQ signal. Note that there is only one pin for /DREQ
and /IREQ, thus the cartridge may not supply /IREQs while using DRQ mode.</p>
<h3 id=video-capture-mode-dma3-only>Video Capture Mode (DMA3 only)</h3>
<p>Intended to copy a bitmap from memory (or from external hardware/camera) to
VRAM. When using this transfer mode, set the repeat bit, and write the number
of data units (per scanline) to the word count register. Capture works similar
like HBlank DMA, however, the transfer is started when VCOUNT=2, it is then
repeated each scanline, and it gets stopped when VCOUNT=162.</p>
<h3 id=transfer-end>Transfer End</h3>
<p>The DMA Enable flag (Bit 15) is automatically cleared upon completion of the
transfer. The user may also clear this bit manually in order to stop the
transfer (obviously this is possible for Sound/Blanking DMAs only, in all other
cases the CPU is stopped until the transfer completes by itself).</p>
<h3 id=transfer-ratetiming>Transfer Rate/Timing</h3>
<p>Except for the first data unit, all units are transferred by sequential reads
and writes. For n data units, the DMA transfer time is:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  2N+2(n-1)S+xI
</code></pre></div></div>
<p>Of which, 1N+(n-1)S are read cycles, and the other 1N+(n-1)S are write cycles,
actual number of cycles depends on the waitstates and bus-width of the source
and destination areas (as described in CPU Instruction Cycle Times chapter).
Internal time for DMA processing is 2I (normally), or 4I (if both source and
destination are in gamepak memory area).</p>
<p>DMA lockup when stopping while starting ???</p>
<p>Capture delayed, Capture Enable=AutoCleared ???</p>

<h2 id=--gba-keypad-input><a name=gbakeypadinput></a> GBA Keypad Input</h2>
<p>The built-in GBA gamepad has 4 direction keys, and 6 buttons.</p>
<h3 id=4000130h---keyinput---key-status-r>4000130h - KEYINPUT - Key Status (R)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0     Button A        (0=Pressed, 1=Released)
  1     Button B        (etc.)
  2     Select          (etc.)
  3     Start           (etc.)
  4     Right           (etc.)
  5     Left            (etc.)
  6     Up              (etc.)
  7     Down            (etc.)
  8     Button R        (etc.)
  9     Button L        (etc.)
  10-15 Not used
</code></pre></div></div>
<p>It’d be usually recommended to read-out this register only once per frame, and
to store the current state in memory. As a side effect, this method avoids
problems caused by switch bounce when a key is newly released or pressed.</p>
<h3 id=4000132h---keycnt---key-interrupt-control-rw>4000132h - KEYCNT - Key Interrupt Control (R/W)</h3>
<p>The keypad IRQ function is intended to terminate the very-low-power Stop mode,
it is not suitable for processing normal user input, to do this, most programs
are invoking their keypad handlers from within VBlank IRQ.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0     Button A        (0=Ignore, 1=Select)
  1     Button B        (etc.)
  2     Select          (etc.)
  3     Start           (etc.)
  4     Right           (etc.)
  5     Left            (etc.)
  6     Up              (etc.)
  7     Down            (etc.)
  8     Button R        (etc.)
  9     Button L        (etc.)
  10-13 Not used
  14    IRQ Enable Flag (0=Disable, 1=Enable)
  15    IRQ Condition   (0=Logical OR, 1=Logical AND)
</code></pre></div></div>
<p>In logical OR mode, an interrupt is requested when at least one of the selected
buttons is pressed.</p>
<p>In logical AND mode, an interrupt is requested when ALL of the selected buttons
are pressed.</p>
<h3 id=notes-1>Notes</h3>
<p>In 8bit gameboy compatibility mode, L and R Buttons are used to toggle the
screen size between normal 160x144 pixels and stretched 240x144 pixels.</p>
<p>The GBA SP is additionally having a * Button used to toggle the backlight on
and off (controlled by separate hardware logic, there’s no way to detect or
change the current backlight state by software).</p>
<h2 id=--gba-interrupt-control><a name=gbainterruptcontrol></a> GBA Interrupt Control</h2>
<h3 id=4000208h---ime---interrupt-master-enable-register-rw>4000208h - IME - Interrupt Master Enable Register (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0     Disable all interrupts         (0=Disable All, 1=See IE register)
  1-31  Not used
</code></pre></div></div>
<h3 id=4000200h---ie---interrupt-enable-register-rw>4000200h - IE - Interrupt Enable Register (R/W)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0     LCD V-Blank                    (0=Disable)
  1     LCD H-Blank                    (etc.)
  2     LCD V-Counter Match            (etc.)
  3     Timer 0 Overflow               (etc.)
  4     Timer 1 Overflow               (etc.)
  5     Timer 2 Overflow               (etc.)
  6     Timer 3 Overflow               (etc.)
  7     Serial Communication           (etc.)
  8     DMA 0                          (etc.)
  9     DMA 1                          (etc.)
  10    DMA 2                          (etc.)
  11    DMA 3                          (etc.)
  12    Keypad                         (etc.)
  13    Game Pak (external IRQ source) (etc.)
  14-15 Not used
</code></pre></div></div>
<p>Note that there is another ‘master enable flag’ directly in the CPUs Status
Register (CPSR) accessible in privileged modes, see CPU reference for details.</p>
<h3 id=4000202h---if---interrupt-request-flags--irq-acknowledge-rw-see-below>4000202h - IF - Interrupt Request Flags / IRQ Acknowledge (R/W, see below)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0     LCD V-Blank                    (1=Request Interrupt)
  1     LCD H-Blank                    (etc.)
  2     LCD V-Counter Match            (etc.)
  3     Timer 0 Overflow               (etc.)
  4     Timer 1 Overflow               (etc.)
  5     Timer 2 Overflow               (etc.)
  6     Timer 3 Overflow               (etc.)
  7     Serial Communication           (etc.)
  8     DMA 0                          (etc.)
  9     DMA 1                          (etc.)
  10    DMA 2                          (etc.)
  11    DMA 3                          (etc.)
  12    Keypad                         (etc.)
  13    Game Pak (external IRQ source) (etc.)
  14-15 Not used
</code></pre></div></div>
<p>Interrupts must be manually acknowledged by writing a “1” to one of the IRQ
bits, the IRQ bit will then be cleared.</p>
<p>“[Cautions regarding clearing IME and IE]</p>
<p>A corresponding interrupt could occur even while a command to clear IME or each
flag of the IE register is being executed. When clearing a flag of IE, you need
to clear IME in advance so that mismatching of interrupt checks will not
occur.” ?</p>
<p>“[When multiple interrupts are used]</p>
<p>When the timing of clearing of IME and the timing of an interrupt agree,
multiple interrupts will not occur during that interrupt. Therefore, set
(enable) IME after saving IME during the interrupt routine.” ?</p>
<h3 id=bios-interrupt-handling>BIOS Interrupt handling</h3>
<p>Upon interrupt execution, the CPU is switched into IRQ mode, and the physical
interrupt vector is called - as this address is located in BIOS ROM, the BIOS
will always execute the following code before it forwards control to the user
handler:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  00000018  b      128h                ;IRQ vector: jump to actual BIOS handler
  00000128  stmfd  r13!,r0-r3,r12,r14  ;save registers to SP_irq
  0000012C  mov    r0,4000000h         ;ptr+4 to 03FFFFFC (mirror of 03007FFC)
  00000130  add    r14,r15,0h          ;retadr for USER handler $+8=138h
  00000134  ldr    r15,[r0,-4h]        ;jump to [03FFFFFC] USER handler
  00000138  ldmfd  r13!,r0-r3,r12,r14  ;restore registers from SP_irq
  0000013C  subs   r15,r14,4h          ;return from IRQ (PC=LR-4, CPSR=SPSR)
</code></pre></div></div>
<p>As shown above, a pointer to the 32bit/ARM-code user handler must be setup in
[03007FFCh]. By default, 160 bytes of memory are reserved for interrupt stack
at 03007F00h-03007F9Fh.</p>
<h3 id=recommended-user-interrupt-handling>Recommended User Interrupt handling</h3>
<ul>
 <li>
 <p>If necessary switch to THUMB state manually (handler is called in ARM state)</p>
 </li>
 <li>
 <p>Determine reason(s) of interrupt by examining IF register</p>
 </li>
 <li>
 <p>User program may freely assign priority to each reason by own logic</p>
 </li>
 <li>
 <p>Process the most important reason of your choice</p>
 </li>
 <li>
 <p>User MUST manually acknowledge by writing to IF register</p>
 </li>
 <li>
 <p>If user wants to allow nested interrupts, save SPSR_irq, then enable IRQs.</p>
 </li>
 <li>
 <p>If using other registers than BIOS-pushed R0-R3, manually save R4-R11 also.</p>
 </li>
 <li>
 <p>Note that Interrupt Stack is used (which may have limited size)</p>
 </li>
 <li>
 <p>So, for memory consuming stack operations use system mode (=user stack).</p>
 </li>
 <li>
 <p>When calling subroutines in system mode, save LSR_usr also.</p>
 </li>
 <li>
 <p>Restore SPSR_irq and/or R4-R11 if you’ve saved them above.</p>
 </li>
 <li>
 <p>Finally, return to BIOS handler by BX LR (R14_irq) instruction.</p>
 </li>
</ul>
<h3 id=default-memory-usage-at-03007fxx-and-mirrored-to-03ffffxx>Default memory usage at 03007FXX (and mirrored to 03FFFFXX)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Addr.    Size Expl.
  3007FFCh 4    Pointer to user IRQ handler (32bit ARM code)
  3007FF8h 2    Interrupt Check Flag (for IntrWait/VBlankIntrWait functions)
  3007FF4h 4    Allocated Area
  3007FF0h 4    Pointer to Sound Buffer
  3007FE0h 16   Allocated Area
  3007FA0h 64   Default area for SP_svc Supervisor Stack (4 words/time)
  3007F00h 160  Default area for SP_irq Interrupt Stack (6 words/time)
</code></pre></div></div>
<p>Memory below 7F00h is free for User Stack and user data. The three stack
pointers are initially initialized at the TOP of the respective areas:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  SP_svc=03007FE0h
  SP_irq=03007FA0h
  SP_usr=03007F00h
</code></pre></div></div>
<p>The user may redefine these addresses and move stacks into other locations,
however, the addresses for system data at 7FE0h-7FFFh are fixed.</p>
<h3 id=not-sure-is-following-free-for-user->Not sure, is following free for user ?</h3>
<p>Registers R8-R12_fiq, R13_fiq, R14_fiq, SPSR_fiq</p>
<p>Registers R13-R14_abt, SPSR_abt</p>
<p>Registers R13-R14_und, SPSR_und</p>
<h3 id=fast-interrupt-fiq>Fast Interrupt (FIQ)</h3>
<p>The ARM CPU provides two interrupt sources, IRQ and FIQ. In the GBA only IRQ is
used. In normal GBAs, the FIQ signal is shortcut to VDD35, ie. the signal is
always high, and there is no way to generate a FIQ by hardware. The registers
R8..12_fiq could be used by software (when switching into FIQ mode by writing
to CPSR) - however, this might make the game incompatible with hardware
debuggers (which are reportedly using FIQs for debugging purposes).</p>
<h2 id=--gba-system-control><a name=gbasystemcontrol></a> GBA System Control</h2>
<h3 id=4000204h---waitcnt---waitstate-control-rw>4000204h - WAITCNT - Waitstate Control (R/W)</h3>
<p>This register is used to configure game pak access timings. The game pak ROM is
mirrored to three address regions at 08000000h, 0A000000h, and 0C000000h, these
areas are called Wait State 0-2. Different access timings may be assigned to
each area (this might be useful in case that a game pak contains several ROM
chips with different access times each).</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-1   SRAM Wait Control          (0..3 = 4,3,2,8 cycles)
  2-3   Wait State 0 First Access  (0..3 = 4,3,2,8 cycles)
  4     Wait State 0 Second Access (0..1 = 2,1 cycles)
  5-6   Wait State 1 First Access  (0..3 = 4,3,2,8 cycles)
  7     Wait State 1 Second Access (0..1 = 4,1 cycles; unlike above WS0)
  8-9   Wait State 2 First Access  (0..3 = 4,3,2,8 cycles)
  10    Wait State 2 Second Access (0..1 = 8,1 cycles; unlike above WS0,WS1)
  11-12 PHI Terminal Output        (0..3 = Disable, 4.19MHz, 8.38MHz, 16.78MHz)
  13    Not used
  14    Game Pak Prefetch Buffer (Pipe) (0=Disable, 1=Enable)
  15    Game Pak Type Flag  (Read Only) (0=GBA, 1=CGB) (IN35 signal)
  16-31 Not used
</code></pre></div></div>
<p>At startup, the default setting is 0000h. Currently manufactured cartridges are
using the following settings: WS0/ROM=3,1 clks; SRAM=8 clks; WS2/EEPROM: 8,8
clks; prefetch enabled; that is, WAITCNT=4317h, for more info see “GBA
Cartridges” chapter.</p>
<p>First Access (Non-sequential) and Second Access (Sequential) define the
waitstates for N and S cycles, the actual access time is 1 clock cycle PLUS the
number of waitstates.</p>
<p>GamePak uses 16bit data bus, so that a 32bit access is split into TWO 16bit
accesses (of which, the second fragment is always sequential, even if the first
fragment was non-sequential).</p>
<ul>
 <li><a href=#gbagamepakprefetch>GBA GamePak Prefetch</a></li>
</ul>
<p>NOTES:</p>
<p>The GBA forcefully uses non-sequential timing at the beginning of each
128K-block of gamepak ROM, eg. “LDMIA [801fff8h],r0-r7” will have
non-sequential timing at 8020000h.</p>
<p>The PHI Terminal output (PHI Pin of Gamepak Bus) should be disabled.</p>
<h3 id=4000300h---postflg---byte---undocumented---post-boot--debug-control-rw>4000300h - POSTFLG - BYTE - Undocumented - Post Boot / Debug Control (R/W)</h3>
<p>After initial reset, the GBA BIOS initializes the register to 01h, and any
further execution of the Reset vector (00000000h) will pass control to the
Debug vector (0000001Ch) when sensing the register to be still set to 01h.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0     Undocumented. First Boot Flag  (0=First, 1=Further)
  1-7   Undocumented. Not used.
</code></pre></div></div>
<p>Normally the debug handler rejects control unless it detects Debug flags in
cartridge header, in that case it may redirect to a cut-down boot procedure
(bypassing Nintendo logo and boot delays, much like nocash burst boot for
multiboot software). I am not sure if it is possible to reset the GBA
externally without automatically resetting register 300h though.</p>
<h3 id=4000301h---haltcnt---byte---undocumented---low-power-mode-control-w>4000301h - HALTCNT - BYTE - Undocumented - Low Power Mode Control (W)</h3>
<p>Writing to this register switches the GBA into battery saving mode.</p>
<p>In Halt mode, the CPU is paused as long as (IE AND IF)=0, this should be used
to reduce power-consumption during periods when the CPU is waiting for
interrupt events.</p>
<p>In Stop mode, most of the hardware including sound and video are paused, this
very-low-power mode could be used much like a screensaver.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0-6   Undocumented. Not used.
  7     Undocumented. Power Down Mode  (0=Halt, 1=Stop)
</code></pre></div></div>
<p>The current GBA BIOS addresses only the upper eight bits of this register (by
writing 00h or 80h to address 04000301h), however, as the register isn’t
officially documented, some or all of the bits might have different meanings in
future GBA models.</p>
<p>For best forwards compatibility, it’d generally be more recommended to use the
BIOS Functions SWI 2 (Halt) or SWI 3 (Stop) rather than writing to this
register directly.</p>
<h3 id=4000410h---undocumented---purpose-unknown--8bit-w>4000410h - Undocumented - Purpose Unknown ? 8bit (W)</h3>
<p>The BIOS writes the 8bit value 0FFh to this address. Purpose Unknown.</p>
<p>Probably just another bug in the BIOS.</p>
<h3 id=4000800h---32bit---undocumented---internal-memory-control-rw>4000800h - 32bit - Undocumented - Internal Memory Control (R/W)</h3>
<p>Supported by GBA and GBA SP only - NOT supported by DS (even in GBA mode).</p>
<p>Also supported by GBA Micro - but crashes on “overclocked” WRAM setting.</p>
<p>Initialized to 0D000020h (by hardware). Unlike all other I/O registers, this
register is mirrored across the whole I/O area (in increments of 64K, ie. at
4000800h, 4010800h, 4020800h, …, 4FF0800h)</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  0     Disable 32K+256K WRAM (0=Normal, 1=Disable) (when off: empty/prefetch)
  1-3   Unknown          (Read/Write-able)
  4     Unknown          (Always zero, not used or write only)
  5     Enable 256K WRAM (0=Disable, 1=Normal) (when off: mirror of 32K WRAM)
  6-23  Unknown          (Always zero, not used or write only)
  24-27 Wait Control WRAM 256K (0-14 = 15..1 Waitstates, 15=Lockup)
  28-31 Unknown          (Read/Write-able)
</code></pre></div></div>
<p>The default value 0Dh in Bits 24-27 selects 2 waitstates for 256K WRAM (ie.
3/3/6 cycles 8/16/32bit accesses). The fastest possible setting would be 0Eh (1
waitstate, 2/2/4 cycles for 8/16/32bit), that works on GBA and GBA SP only, the
GBA Micro locks up with that setting (it’s on-chip RAM is too slow, and works
only with 2 or more waitstates).</p>
<p>Note: One cycle equals approx. 59.59ns (ie. 16.78MHz clock).</p>
<h2 id=--gba-gamepak-prefetch><a name=gbagamepakprefetch></a> GBA GamePak Prefetch</h2>
<p>GamePak Prefetch can be enabled in WAITCNT register. When prefetch buffer is
enabled, the GBA attempts to read opcodes from Game Pak ROM during periods when
the CPU is not using the bus (if any). Memory access is then performed with 0
Waits if the CPU requests data which is already stored in the buffer. The
prefetch buffer stores up to eight 16bit values.</p>
<h3 id=gamepak-rom-opcodes>GamePak ROM Opcodes</h3>
<p>The prefetch feature works only with &lt;opcodes&gt; fetched from GamePak ROM.
Opcodes executed in RAM or BIOS are not affected by the prefetch feature (even
if that opcodes read &lt;data&gt; from GamePak ROM).</p>
<h3 id=prefetch-enable>Prefetch Enable</h3>
<p>For GamePak ROM opcodes, prefetch may occur in two situations:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  1) opcodes with internal cycles (I) which do not change R15, shift/rotate
     register-by-register, load opcodes (ldr,ldm,pop,swp), multiply opcodes
  2) opcodes that load/store memory (ldr,str,ldm,stm,etc.)
</code></pre></div></div>
<h3 id=prefetch-disable-bug>Prefetch Disable Bug</h3>
<p>When Prefetch is disabled, the Prefetch Disable Bug will occur for all</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  "Opcodes in GamePak ROM with Internal Cycles which do not change R15"
</code></pre></div></div>
<p>for those opcodes, the bug changes the opcode fetch time from 1S to 1N.</p>
<p>Note: Affected opcodes (with I cycles) are: Shift/rotate register-by-register
opcodes, multiply opcodes, and load opcodes (ldr,ldm,pop,swp).</p>
<h2 id=--gba-cartridges><a name=gbacartridges></a> GBA Cartridges</h2>
<h3 id=rom>ROM</h3>
<ul>
 <li><a href=#gbacartridgeheader>GBA Cartridge Header</a></li>
 <li><a href=#gbacartridgerom>GBA Cartridge ROM</a></li>
</ul>
<h3 id=backup-media>Backup Media</h3>
<p>Aside from ROM, cartridges may also include one of the following backup medias,
used to store game positions, highscore tables, options, or other data.</p>
<ul>
 <li><a href=#gbacartbackupids>GBA Cart Backup IDs</a></li>
 <li><a href=#gbacartbackupsramfram>GBA Cart Backup SRAM/FRAM</a></li>
 <li><a href=#gbacartbackupeeprom>GBA Cart Backup EEPROM</a></li>
 <li><a href=#gbacartbackupflashrom>GBA Cart Backup Flash ROM</a></li>
</ul>
<h2 id=--gba-cartridge-header><a name=gbacartridgeheader></a> GBA Cartridge Header</h2>
<p>The first 192 bytes at 8000000h-80000BFh in ROM are used as cartridge header.
The same header is also used for Multiboot images at 2000000h-20000BFh (plus
some additional multiboot entries at 20000C0h and up).</p>
<h3 id=header-overview>Header Overview</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Address Bytes Expl.
  000h    4     ROM Entry Point  (32bit ARM branch opcode, eg. "B rom_start")
  004h    156   Nintendo Logo    (compressed bitmap, required!)
  0A0h    12    Game Title       (uppercase ascii, max 12 characters)
  0ACh    4     Game Code        (uppercase ascii, 4 characters)
  0B0h    2     Maker Code       (uppercase ascii, 2 characters)
  0B2h    1     Fixed value      (must be 96h, required!)
  0B3h    1     Main unit code   (00h for current GBA models)
  0B4h    1     Device type      (usually 00h) (bit7=DACS/debug related)
  0B5h    7     Reserved Area    (should be zero filled)
  0BCh    1     Software version (usually 00h)
  0BDh    1     Complement check (header checksum, required!)
  0BEh    2     Reserved Area    (should be zero filled)
  --- Additional Multiboot Header Entries ---
  0C0h    4     RAM Entry Point  (32bit ARM branch opcode, eg. "B ram_start")
  0C4h    1     Boot mode        (init as 00h - BIOS overwrites this value!)
  0C5h    1     Slave ID Number  (init as 00h - BIOS overwrites this value!)
  0C6h    26    Not used         (seems to be unused)
  0E0h    4     JOYBUS Entry Pt. (32bit ARM branch opcode, eg. "B joy_start")
</code></pre></div></div>
<p>Note: With all entry points, the CPU is initially set into system mode.</p>
<h3 id=000h---entry-point-4-bytes>000h - Entry Point, 4 Bytes</h3>
<p>Space for a single 32bit ARM opcode that redirects to the actual startaddress
of the cartridge, this should be usually a “B &lt;start&gt;” instruction.</p>
<p>Note: This entry is ignored by Multiboot slave GBAs (in fact, the entry is then
overwritten and redirected to a separate Multiboot Entry Point, as described
below).</p>
<h3 id=004h09fh---nintendo-logo-156-bytes>004h..09Fh - Nintendo Logo, 156 Bytes</h3>
<p>Contains the Nintendo logo which is displayed during the boot procedure.
Cartridge won’t work if this data is missing or modified.</p>
<p>In detail: This area contains Huffman compression data (but excluding the
compression header which is hardcoded in the BIOS, so that it’d be probably not
possible to hack the GBA by producing de-compression buffer overflows).</p>
<p>A copy of the compression data is stored in the BIOS, the GBA will compare this
data and lock-up itself if the BIOS data isn’t exactly the same as in the
cartridge (or multiboot header). The only exception are the two entries below
which are allowed to have variable settings in some bits.</p>
<h3 id=09ch-bit-27---debugging-enable>09Ch Bit 2,7 - Debugging Enable</h3>
<p>This is part of the above Nintendo Logo area, and must be commonly set to 21h,
however, Bit 2 and Bit 7 may be set to other values.</p>
<p>When both bits are set (ie. A5h), the FIQ/Undefined Instruction handler in the
BIOS becomes unlocked, the handler then forwards these exceptions to the user
handler in cartridge ROM (entry point defined in 80000B4h, see below).</p>
<p>Other bit combinations currently do not seem to have special functions.</p>
<h3 id=09eh-bit-01---cartridge-key-number-msbs>09Eh Bit 0,1 - Cartridge Key Number MSBs</h3>
<p>This is part of the above Nintendo Logo area, and must be commonly set to F8h,
however, Bit 0-1 may be set to other values.</p>
<p>During startup, the BIOS performs some dummy-reads from a stream of pre-defined
addresses, even though these reads seem to be meaningless, they might be
intended to unlock a read-protection inside of commercial cartridge. There are
16 pre-defined address streams - selected by a 4bit key number - of which the
upper two bits are gained from 800009Eh Bit 0-1, and the lower two bits from a
checksum across header bytes 09Dh..0B7h (bytewise XORed, divided by 40h).</p>
<h3 id=0a0h---game-title-uppercase-ascii-max-12-characters>0A0h - Game Title, Uppercase Ascii, max 12 characters</h3>
<p>Space for the game title, padded with 00h (if less than 12 chars).</p>
<h3 id=0ach---game-code-uppercase-ascii-4-characters>0ACh - Game Code, Uppercase Ascii, 4 characters</h3>
<p>This is the same code as the AGB-UTTD code which is printed on the package and
sticker on (commercial) cartridges (excluding the leading “AGB-“ part).</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  U  Unique Code          (usually "A" or "B" or special meaning)
  TT Short Title          (eg. "PM" for Pac Man)
  D  Destination/Language (usually "J" or "E" or "P" or specific language)
</code></pre></div></div>
<p>The first character (U) is usually “A” or “B”, in detail:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  A  Normal game; Older titles (mainly 2001..2003)
  B  Normal game; Newer titles (2003..)
  C  Normal game; Not used yet, but might be used for even newer titles
  F  Famicom/Classic NES Series (software emulated NES games)
  K  Yoshi and Koro Koro Puzzle (acceleration sensor)
  P  e-Reader (dot-code scanner)
  R  Warioware Twisted (cartridge with rumble and z-axis gyro sensor)
  U  Boktai 1 and 2 (cartridge with RTC and solar sensor)
  V  Drill Dozer (cartridge with rumble)
</code></pre></div></div>
<p>The second/third characters (TT) are:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Usually an abbreviation of the game title (eg. "PM" for "Pac Man") (unless
  that gamecode was already used for another game, then TT is just random)
</code></pre></div></div>
<p>The fourth character (D) indicates Destination/Language:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  J  Japan             P  Europe/Elsewhere   F  French          S  Spanish
  E  USA/English       D  German             I  Italian
</code></pre></div></div>
<h3 id=0b0h---maker-code-uppercase-ascii-2-characters>0B0h - Maker code, Uppercase Ascii, 2 characters</h3>
<p>Identifies the (commercial) developer. For example, “01”=Nintendo.</p>
<h3 id=0b2h---fixed-value-1-byte>0B2h - Fixed value, 1 Byte</h3>
<p>Must be 96h.</p>
<h3 id=0b3h---main-unit-code-1-byte>0B3h - Main unit code, 1 Byte</h3>
<p>Identifies the required hardware. Should be 00h for current GBA models.</p>
<h3 id=0b4h---device-type-1-byte>0B4h - Device type, 1 Byte</h3>
<p>Normally, this entry should be zero. With Nintendo’s hardware debugger Bit 7
identifies the debugging handlers entry point and size of DACS (Debugging And
Communication System) memory: Bit7=0: 9FFC000h/8MBIT DACS, Bit7=1:
9FE2000h/1MBIT DACS. The debugging handler can be enabled in 800009Ch (see
above), normal cartridges do not have any memory (nor any mirrors) at these
addresses though.</p>
<h3 id=0b5h---reserved-area-7-bytes>0B5h - Reserved Area, 7 Bytes</h3>
<p>Reserved, zero filled.</p>
<h3 id=0bch---software-version-number>0BCh - Software version number</h3>
<p>Version number of the game. Usually zero.</p>
<h3 id=0bdh---complement-check-1-byte>0BDh - Complement check, 1 Byte</h3>
<p>Header checksum, cartridge won’t work if incorrect. Calculate as such:</p>
<p>chk=0:for i=0A0h to 0BCh:chk=chk-[i]:next:chk=(chk-19h) and 0FFh</p>
<h3 id=0beh---reserved-area-2-bytes>0BEh - Reserved Area, 2 Bytes</h3>
<p>Reserved, zero filled.</p>
<p>Below required for Multiboot/slave programs only. For Multiboot, the above 192
bytes are required to be transferred as header-block (loaded to
2000000h-20000BFh), and some additional header-information must be located at
the beginning of the actual program/data-block (loaded to 20000C0h and up).
This extended header consists of Multiboot Entry point(s) which must be set up
correctly, and of two reserved bytes which are overwritten by the boot
procedure:</p>
<h3 id=0c0h---normalmultiplay-mode-entry-point>0C0h - Normal/Multiplay mode Entry Point</h3>
<p>This entry is used only if the GBA has been booted by using Normal or Multiplay
transfer mode (but not by Joybus mode).</p>
<p>Typically deposit a ARM-32bit “B &lt;start&gt;” branch opcode at this location,
which is pointing to your actual initialization procedure.</p>
<h3 id=0c4h-byte---boot-mode>0C4h (BYTE) - Boot mode</h3>
<p>The slave GBA download procedure overwrites this byte by a value which is
indicating the used multiboot transfer mode.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Value  Expl.
  01h    Joybus mode
  02h    Normal mode
  03h    Multiplay mode
</code></pre></div></div>
<p>Typically set this byte to zero by inserting DCB 00h in your source.</p>
<p>Be sure that your uploaded program does not contain important program code or
data at this location, or at the ID-byte location below.</p>
<h3 id=0c5h-byte---slave-id-number>0C5h (BYTE) - Slave ID Number</h3>
<p>If the GBA has been booted in Normal or Multiplay mode, this byte becomes
overwritten by the slave ID number of the local GBA (that’d be always 01h for
normal mode).</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Value  Expl.
  01h    Slave #1
  02h    Slave #2
  03h    Slave #3
</code></pre></div></div>
<p>Typically set this byte to zero by inserting DCB 00h in your source.</p>
<p>When booted in Joybus mode, the value is NOT changed and remains the same as
uploaded from the master GBA.</p>
<h3 id=0c6h0dfh---not-used>0C6h..0DFh - Not used</h3>
<p>Appears to be unused.</p>
<h3 id=0e0h---joybus-mode-entry-point>0E0h - Joybus mode Entry Point</h3>
<p>If the GBA has been booted by using Joybus transfer mode, then the entry point
is located at this address rather than at 20000C0h. Either put your
initialization procedure directly at this address, or redirect to the actual
boot procedure by depositing a “B &lt;start&gt;” opcode here (either one using
32bit ARM code). Or, if you are not intending to support joybus mode (which is
probably rarely used), ignore this entry.</p>
<h2 id=--gba-cartridge-rom><a name=gbacartridgerom></a> GBA Cartridge ROM</h2>
<h3 id=rom-size>ROM Size</h3>
<p>The games F-ZERO and Super Mario Advance use ROMs of 4 MBytes each. Zelda uses
8 MBytes. Not sure if other sizes are manufactured.</p>
<h3 id=rom-waitstates>ROM Waitstates</h3>
<p>The GBA starts the cartridge with 4,2 waitstates (N,S) and prefetch disabled.
The program may change these settings by writing to WAITCNT, the games F-ZERO
and Super Mario Advance use 3,1 waitstates (N,S) each, with prefetch enabled.</p>
<p>Third-party flashcards are reportedly running unstable with these settings.
Also, prefetch and shorter waitstates are allowing to read more data and
opcodes from ROM is less time, the downside is that it increases the power
consumption.</p>
<h3 id=rom-chip>ROM Chip</h3>
<p>Because of how 24bit addresses are squeezed through the Gampak bus, the
cartridge must include a circuit that latches the lower 16 address bits on
non-sequential access, and that increments these bits on sequential access.
Nintendo includes this circuit directly in the ROM chip.</p>
<p>Also, the ROM must have 16bit data bus (or a circuit which converts two 8bit
data units into one 16bit unit - by not exceeding the waitstate timings).</p>
<h2 id=--gba-cart-backup-ids><a name=gbacartbackupids></a> GBA Cart Backup IDs</h2>
<p>Nintendo didn’t include a backup-type entry in the ROM header, however, the
required type can be detected by ID strings in the ROM-image. Nintendo’s tools
are automatically inserting these strings (as part of their library headers).
When using other tools, you may insert ID strings by hand.</p>
<h3 id=id-strings>ID Strings</h3>
<p>The ID string must be located at a word-aligned memory location, the string
length should be a multiple of 4 bytes (padded with zero’s).</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  EEPROM_Vnnn    EEPROM 512 bytes or 8 Kbytes (4Kbit or 64Kbit)
  SRAM_Vnnn      SRAM 32 Kbytes (256Kbit)
  FLASH_Vnnn     FLASH 64 Kbytes (512Kbit) (ID used in older files)
  FLASH512_Vnnn  FLASH 64 Kbytes (512Kbit) (ID used in newer files)
  FLASH1M_Vnnn   FLASH 128 Kbytes (1Mbit)
</code></pre></div></div>
<p>For Nintendo’s tools, “nnn” is a 3-digit library version number. When using
other tools, best keep it set to “nnn” rather than inserting numeric digits.</p>
<h3 id=notes-2>Notes</h3>
<p>No$gba does auto-detect most backup types, even without ID strings, except for
128K FLASH (without ID “FLASH1M_Vnnn”, the FLASH size defaults to 64K).
Ideally, for faster detection, the ID should be put into the first some bytes
of the ROM-image (ie. somewhere right after the ROM header).</p>
<h2 id=--gba-cart-backup-sramfram><a name=gbacartbackupsramfram></a> GBA Cart Backup SRAM/FRAM</h2>
<p>SRAM - 32 KBytes (256Kbit) Lifetime: Depends on back-up battery</p>
<p>FRAM - 32 KBytes (256Kbit) Lifetime: 10,000,000,000 read/write per bit</p>
<p>Hyundai GM76V256CLLFW10 SRAM (Static RAM) (eg. F-Zero)</p>
<p>Fujitsu MB85R256 FRAM (Ferroelectric RAM) (eg. Warioware Twisted)</p>
<h3 id=addressing-and-waitstates>Addressing and Waitstates</h3>
<p>SRAM/FRAM is mapped to E000000h-E007FFFh, it should be accessed with 8
waitstates (write a value of 3 into Bit0-1 of WAITCNT).</p>
<h3 id=databus-width>Databus Width</h3>
<p>The SRAM/FRAM databus is restricted to 8 bits, it should be accessed by LDRB,
LDRSB, and STRB opcodes only.</p>
<h3 id=reading-and-writing>Reading and Writing</h3>
<p>Reading from SRAM/FRAM should be performed by code executed in WRAM only (but
not by code executed in ROM). There is no such restriction for writing.</p>
<h3 id=preventing-data-loss>Preventing Data Loss</h3>
<p>The GBA SRAM/FRAM carts do not include a write-protect function (unlike older
8bit gameboy carts). This seems to be a problem and may cause data loss when a
cartridge is removed or inserted while the GBA is still turned on. As far as I
understand, this is not so much a hardware problem, but rather a software
problem, ie. theoretically you could remove/insert the cartridge as many times
as you want, but you should take care that your program does not crash (and
write blindly into memory).</p>
<h3 id=recommended-workaround>Recommended Workaround</h3>
<p>Enable the Gamepak Interrupt (it’ll most likely get triggered when removing the
cartridge), and hang-up the GBA in an endless loop when your interrupt handler
senses a Gamepak IRQ. For obvious reason, your interrupt handler should be
located in WRAM, ie. not in the (removed) ROM cartridge. The handler should
process Gamepak IRQs at highest priority. Periods during which interrupts are
disabled should be kept as short as possible, if necessary allow nested
interrupts.</p>
<h3 id=when-to-use-the-above-workaround>When to use the above Workaround</h3>
<p>A program that relies wholly on code and data in WRAM, and that does not crash
even when ROM is removed, may keep operating without having to use the above
mechanism.</p>
<p>Do NOT use the workaround for programs that run without a cartridge inserted
(ie. single gamepak/multiboot slaves), or for programs that use Gamepak IRQ/DMA
for other purposes.</p>
<p>All other programs should use it. It’d be eventually a good idea to include it
even in programs that do not use SRAM/FRAM themselves (eg. otherwise removing a
SRAM/FRAM-less cartridge may lock up the GBA, and may cause it to destroy
backup data when inserting a SRAM/FRAM cartridge).</p>
<h3 id=sram-vs-fram>SRAM vs FRAM</h3>
<p>FRAM (Ferroelectric RAM) is a newer technology, used in newer GBA carts, unlike
SRAM (Static RAM), it doesn’t require a battery to hold the data. At software
side, it is accessed exactly like SRAM, ie. unlike EEPROM/FLASH, it doesn’t
require any Write/Erase commands/delays.</p>
<h3 id=note-1>Note</h3>
<p>In SRAM/FRAM cartridges, the /REQ pin (Pin 31 of Gamepak bus) should be a
little bit shorter as than the other pins; when removing the cartridge, this
causes the gamepak IRQ signal to get triggered before the other pins are
disconnected.</p>
<h2 id=--gba-cart-backup-eeprom><a name=gbacartbackupeeprom></a> GBA Cart Backup EEPROM</h2>
<p>9853 - EEPROM 512 Bytes (0200h) (4Kbit) (eg. used by Super Mario Advance)</p>
<p>9854 - EEPROM 8 KBytes (2000h) (64Kbit) (eg. used by Boktai)</p>
<p>Lifetime: 100,000 writes per address</p>
<h3 id=addressing-and-waitstates-1>Addressing and Waitstates</h3>
<p>The eeprom is connected to Bit0 of the data bus, and to the upper 1 bit (or
upper 17 bits in case of large 32MB ROM) of the cartridge ROM address bus,
communication with the chip takes place serially.</p>
<p>The eeprom must be used with 8 waitstates (set WAITCNT=X3XXh; 8,8 clks in WS2
area), the eeprom can be then addressed at DFFFF00h..DFFFFFFh.</p>
<p>Respectively, with eeprom, ROM is restricted to 8000000h-9FFFeFFh (max.
1FFFF00h bytes = 32MB minus 256 bytes). On carts with 16MB or smaller ROM,
eeprom can be alternately accessed anywhere at D000000h-DFFFFFFh.</p>
<h3 id=data-and-address-width>Data and Address Width</h3>
<p>Data can be read from (or written to) the EEPROM in units of 64bits (8 bytes).
Writing automatically erases the old 64bits of data. Addressing works in units
of 64bits respectively, that is, for 512 Bytes EEPROMS: an address range of
0-3Fh, 6bit bus width; and for 8KByte EEPROMs: a range of 0-3FFh, 14bit bus
width (only the lower 10 address bits are used, upper 4 bits should be zero).</p>
<h3 id=set-address-for-reading>Set Address (For Reading)</h3>
<p>Prepare the following bitstream in memory:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  2 bits "11" (Read Request)
  n bits eeprom address (MSB first, 6 or 14 bits, depending on EEPROM)
  1 bit "0"
</code></pre></div></div>
<p>Then transfer the stream to eeprom by using DMA.</p>
<h3 id=read-data>Read Data</h3>
<p>Read a stream of 68 bits from EEPROM by using DMA,</p>
<p>then decipher the received data as follows:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  4 bits - ignore these
 64 bits - data (conventionally MSB first)
</code></pre></div></div>
<h3 id=write-data-to-address>Write Data to Address</h3>
<p>Prepare the following bitstream in memory, then transfer the stream to eeprom
by using DMA, it’ll take ca. 108368 clock cycles (ca. 6.5ms) until the old data
is erased and new data is programmed.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  2 bits "10" (Write Request)
  n bits eeprom address (MSB first, 6 or 14 bits, depending on EEPROM)
 64 bits data (conventionally MSB first)
  1 bit "0"
</code></pre></div></div>
<p>After the DMA, keep reading from the chip, by normal LDRH [DFFFF00h], until Bit
0 of the returned data becomes “1” (Ready). To prevent your program from
locking up in case of malfunction, generate a timeout if the chip does not
reply after 10ms or longer.</p>
<h3 id=using-dma>Using DMA</h3>
<p>Transferring a bitstream to/from the EEPROM by LDRH/STRH opcodes does not work,
this might be because of timing problems, or because how the GBA squeezes
non-sequential memory addresses through the external address/data bus.</p>
<p>For this reason, a buffer in memory must be used (that buffer would be
typically allocated temporarily on stack, one halfword for each bit, bit1-15 of
the halfwords are don’t care, only bit0 is of interest).</p>
<p>The buffer must be transfered as a whole to/from EEPROM by using DMA3 (only DMA
3 is valid to read &amp; write external memory), use 16bit transfer mode, both
source and destination address incrementing (ie. DMA3CNT=80000000h+length).</p>
<p>DMA channels of higher priority should be disabled during the transfer (ie.
H/V-Blank or Sound FIFO DMAs). And, of course any interrupts that might mess
with DMA registers should be disabled.</p>
<h3 id=pin-outs>Pin-Outs</h3>
<p>The EEPROM chips are having only 8 pins, these are connected, Pin 1..8, to
ROMCS, RD, WR, AD0, GND, GND, A23, VDD of the GamePak bus. Carts with 32MB ROM
must have A7..A22 logically ANDed with A23.</p>
<h3 id=notes-3>Notes</h3>
<p>There seems to be no autodection mechanism, so that a hardcoded bus width must
be used.</p>
<h2 id=--gba-cart-backup-flash-rom><a name=gbacartbackupflashrom></a> GBA Cart Backup Flash ROM</h2>
<p>64 KBytes - 512Kbits Flash ROM - Lifetime: 10,000 writes per sector</p>
<p>128 KBytes - 1Mbit Flash ROM - Lifetime: ??? writes per sector</p>
<h3 id=chip-identification-all-device-types>Chip Identification (all device types)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=90h  (enter ID mode)
  dev=[E000001h], man=[E000000h]                  (get device &amp; manufacturer)
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=F0h  (terminate ID mode)
</code></pre></div></div>
<p>Used to detect the type (and presence) of FLASH chips. See Device Types below.</p>
<h3 id=reading-data-bytes-all-device-types>Reading Data Bytes (all device types)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  dat=[E00xxxxh]                                  (read byte from address xxxx)
</code></pre></div></div>
<h3 id=erase-entire-chip-all-device-types>Erase Entire Chip (all device types)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=80h  (erase command)
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=10h  (erase entire chip)
  wait until [E000000h]=FFh (or timeout)
</code></pre></div></div>
<p>Erases all memory in chip, erased memory is FFh-filled.</p>
<h3 id=erase-4kbyte-sector-all-device-types-except-atmel>Erase 4Kbyte Sector (all device types, except Atmel)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=80h  (erase command)
  [E005555h]=AAh, [E002AAAh]=55h, [E00n000h]=30h  (erase sector n)
  wait until [E00n000h]=FFh (or timeout)
</code></pre></div></div>
<p>Erases memory at E00n000h..E00nFFFh, erased memory is FFh-filled.</p>
<h3 id=erase-and-write-128-bytes-sector-only-atmel-devices>Erase-and-Write 128 Bytes Sector (only Atmel devices)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  old=IME, IME=0                                  (disable interrupts)
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=A0h  (erase/write sector command)
  [E00xxxxh+00h..7Fh]=dat[00h..7Fh]               (write 128 bytes)
  IME=old                                         (restore old IME state)
  wait until [E00xxxxh+7Fh]=dat[7Fh] (or timeout)
</code></pre></div></div>
<p>Interrupts (and DMAs) should be disabled during command/write phase. Target
address must be a multiple of 80h.</p>
<h3 id=write-single-data-byte-all-device-types-except-atmel>Write Single Data Byte (all device types, except Atmel)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=A0h  (write byte command)
  [E00xxxxh]=dat                                  (write byte to address xxxx)
  wait until [E00xxxxh]=dat (or timeout)
</code></pre></div></div>
<p>The target memory location must have been previously erased.</p>
<h3 id=terminate-command-after-timeout-only-macronix-devices-id1cc2h>Terminate Command after Timeout (only Macronix devices, ID=1CC2h)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  [E005555h]=F0h                            (force end of write/erase command)
</code></pre></div></div>
<p>Use if timeout occurred during “wait until” periods, for Macronix devices only.</p>
<h3 id=bank-switching-devices-bigger-than-64k-only>Bank Switching (devices bigger than 64K only)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=B0h  (select bank command)
  [E000000h]=bnk                                  (write bank number 0..1)
</code></pre></div></div>
<p>Specifies 64K bank number for read/write/erase operations.</p>
<p>Required because gamepak flash/sram addressbus is limited to 16bit width.</p>
<h3 id=device-types>Device Types</h3>
<p>Nintendo puts different FLASH chips in commercial game cartridges. Developers
should thus detect &amp; support all chip types. For Atmel chips it’d be
recommended to simulate 4K sectors by software, though reportedly Nintendo
doesn’t use Atmel chips in newer games anymore. Also mind that different
timings should not disturb compatibility and performance.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  ID     Name       Size  Sectors  AverageTimings  Timeouts/ms   Waits
  D4BFh  SST        64K   16x4K    20us?,?,?       10,  40, 200  3,2
  1CC2h  Macronix   64K   16x4K    ?,?,?           10,2000,2000  8,3
  1B32h  Panasonic  64K   16x4K    ?,?,?           10, 500, 500  4,2
  3D1Fh  Atmel      64K   512x128  ?,?,?           ...40..,  40  8,8
  1362h  Sanyo      128K  ?        ?,?,?           ?    ?    ?    ?
  09C2h  Macronix   128K  ?        ?,?,?           ?    ?    ?    ?
</code></pre></div></div>
<p>Identification Codes MSB=Device Type, LSB=Manufacturer.</p>
<p>Size in bytes, and numbers of sectors * sector size in bytes.</p>
<p>Average medium Write, Erase Sector, Erase Chips timings are unknown?</p>
<p>Timeouts in milliseconds for Write, Erase Sector, Erase Chips.</p>
<p>Waitstates for Writes, and Reads in clock cycles.</p>
<h3 id=accessing-flash-memory>Accessing FLASH Memory</h3>
<p>FLASH memory is located in the “SRAM” area at E000000h..E00FFFFh, which is
restricted to 16bit address and 8bit data buswidths. Respectively, the memory
can be accessed &lt;only&gt; by 8bit read/write LDRB/STRB opcodes.</p>
<p>Also, reading anything (data or status/busy information) can be done
&lt;only&gt; by opcodes executed in WRAM (not from opcodes in ROM) (there’s no
such restriction for writing).</p>
<h3 id=flash-waitstates>FLASH Waitstates</h3>
<p>Use 8 clk waitstates for initial detection (WAITCNT Bits 0,1 both set). After
detection of certain device types smaller wait values may be used for
write/erase, and even smaller wait values for raw reading, see Device Types
table.</p>
<p>In practice, games seem to use smaller values only for write/erase (even though
those operations are slow anyways), whilst raw reads are always done at 8 clk
waits (even though reads could actually benefit slightly from smaller wait
values).</p>
<h3 id=verify-writeerase-and-retry>Verify Write/Erase and Retry</h3>
<p>Even though device signalizes the completion of write/erase operations, it’d be
recommended to read/confirm the content of the changed memory area by software.
In practice, Nintendo’s “erase-write-verify-retry” function typically repeats
the operation up to three times in case of errors.</p>
<p>Also, for SST devices only, the “erase-write” and “erase-write-verify-retry”
functions repeat the erase command up to 80 times, additionally followed by one
further erase command if no retries were needed, otherwise followed by six
further erase commands.</p>
<h3 id=note-2>Note</h3>
<p>FLASH (64Kbytes) is used by the game Sonic Advance, and possibly others.</p>
<h2 id=--gba-unpredictable-things><a name=gbaunpredictablethings></a> GBA Unpredictable Things</h2>
<h3 id=forward>Forward</h3>
<p>Most of the below is caused by ‘traces’ from previous operations which have
used the databus. No promises that the results are stable on all current or
future GBA models, and/or under all temperature and interference circumstances.</p>
<p>Also, below specifies 32bit data accesses only. When reading units less than
32bit, data is rotated depending on the alignment of the originally specified
address, and 8bit or 16bit are then isolated from the 32bit value as usually.</p>
<h3 id=reading-from-bios-memory-00000000-00003fff>Reading from BIOS Memory (00000000-00003FFF)</h3>
<p>The BIOS memory is protected against reading, the GBA allows to read opcodes or
data only if the program counter is located inside of the BIOS area. If the
program counter is not in the BIOS area, reading will return the most recent
successfully fetched BIOS opcode (eg. the opcode at [00DCh+8] after startup and
SoftReset, the opcode at [0134h+8] during IRQ execution, and opcode at
[013Ch+8] after IRQ execution, and opcode at [0188h+8] after SWI execution).</p>
<h3 id=reading-from-unused-memory-00004000-01ffffff10000000-ffffffff>Reading from Unused Memory (00004000-01FFFFFF,10000000-FFFFFFFF)</h3>
<p>Accessing unused memory at 00004000h-01FFFFFFh, and 10000000h-FFFFFFFFh (and
02000000h-03FFFFFFh when RAM is disabled via Port 4000800h) returns the
recently pre-fetched opcode. For ARM code this is simply:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  WORD = [$+8]
</code></pre></div></div>
<p>For THUMB code the result consists of two 16bit fragments and depends on the
address area and alignment where the opcode was stored.</p>
<p>For THUMB code in Main RAM, Palette Memory, VRAM, and Cartridge ROM this is:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  LSW = [$+4], MSW = [$+4]
</code></pre></div></div>
<p>For THUMB code in BIOS or OAM (and in 32K-WRAM on Original-NDS (in GBA mode)):</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  LSW = [$+4], MSW = [$+6]   ;for opcodes at 4-byte aligned locations
  LSW = [$+2], MSW = [$+4]   ;for opcodes at non-4-byte aligned locations
</code></pre></div></div>
<p>For THUMB code in 32K-WRAM on GBA, GBA SP, GBA Micro, NDS-Lite (but not NDS):</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  LSW = [$+4], MSW = OldHI   ;for opcodes at 4-byte aligned locations
  LSW = OldLO, MSW = [$+4]   ;for opcodes at non-4-byte aligned locations
</code></pre></div></div>
<p>Whereas OldLO/OldHI are usually:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  OldLO=[$+2], OldHI=[$+2]
</code></pre></div></div>
<p>Unless the previous opcode’s prefetch was overwritten; that can happen if the
previous opcode was itself an LDR opcode, ie. if it was itself reading data:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  OldLO=LSW(data), OldHI=MSW(data)
  Theoretically, this might also change if a DMA transfer occurs.
</code></pre></div></div>
<p>Note: Additionally, as usually, the 32bit data value will be rotated if the
data address wasn’t 4-byte aligned, and the upper bits of the 32bit value will
be masked in case of LDRB/LDRH reads.</p>
<p>Note: The opcode prefetch is caused by the prefetch pipeline in the CPU itself,
not by the external gamepak prefetch, ie. it works for code in ROM and RAM as
well.</p>
<h3 id=reading-from-unused-or-write-only-io-ports>Reading from Unused or Write-Only I/O Ports</h3>
<p>Works like above Unused Memory when the entire 32bit memory fragment is Unused
(eg. 0E0h) and/or Write-Only (eg. DMA0SAD). And otherwise, returns zero if the
lower 16bit fragment is readable (eg. 04Ch=MOSAIC, 04Eh=NOTUSED/ZERO).</p>
<h3 id=reading-from-gamepak-rom-when-no-cartridge-is-inserted>Reading from GamePak ROM when no Cartridge is inserted</h3>
<p>Because Gamepak uses the same signal-lines for both 16bit data and for lower
16bit halfword address, the entire gamepak ROM area is effectively filled by
incrementing 16bit values (Address/2 AND FFFFh).</p>
<h3 id=memory-mirrors>Memory Mirrors</h3>
<p>Most internal memory is mirrored across the whole 24bit/16MB address space in
which it is located: Slow On-board RAM at 2XXXXXX, Fast On-Chip RAM at
3XXXXXXh, Palette RAM at 5XXXXXXh, VRAM at 6XXXXXXh, and OAM at 7XXXXXXh. Even
though VRAM is sized 96K (64K+32K), it is repeated in steps of 128K
(64K+32K+32K, the two 32K blocks itself being mirrors of each other).</p>
<p>BIOS ROM, Normal ROM Cartridges, and I/O area are NOT mirrored, the only
exception is the undocumented I/O port at 4000800h (repeated each 64K).</p>
<p>The 64K SRAM area is mirrored across the whole 32MB area at E000000h-FFFFFFFh,
also, inside of the 64K SRAM field, 32K SRAM chips are repeated twice.</p>
<h3 id=writing-8bit-data-to-video-memory>Writing 8bit Data to Video Memory</h3>
<p>Video Memory (BG, OBJ, OAM, Palette) can be written to in 16bit and 32bit units
only. Attempts to write 8bit data (by STRB opcode) won’t work:</p>
<p>Writes to OBJ (6010000h-6017FFFh) (or 6014000h-6017FFFh in Bitmap mode) and to
OAM (7000000h-70003FFh) are ignored, the memory content remains unchanged.</p>
<p>Writes to BG (6000000h-600FFFFh) (or 6000000h-6013FFFh in Bitmap mode) and to
Palette (5000000h-50003FFh) are writing the new 8bit value to BOTH upper and
lower 8bits of the addressed halfword, ie. “[addr AND NOT 1]=data*101h”.</p>
<h3 id=using-invalid-tile-numbers>Using Invalid Tile Numbers</h3>
<p>In Text mode, large tile numbers (combined with a non-zero character base
setting in BGnCNT register) may exceed the available 64K of BG VRAM.</p>
<p>On GBA and GBA SP, such invalid tiles are displayed as if the character data is
filled by the 16bit BG Map entry value (ie. as vertically striped tiles). Above
applies only if there is only one BG layer enabled, with two or more layers,
things are getting much more complicated: tile-data is then somehow derived
from the other layers, depending on their priority order and scrolling offsets.</p>
<p>On NDS (in GBA mode), such invalid tiles are displayed as if the character data
is zero-filled (ie. as invisible/transparent tiles).</p>
<h3 id=accessing-sram-area-by-16bit32bit>Accessing SRAM Area by 16bit/32bit</h3>
<p>Reading retrieves 8bit value from specified address, multiplied by 0101h (LDRH)
or by 01010101h (LDR). Writing changes the 8bit value at the specified address
only, being set to LSB of (source_data ROR (address*8)).</p>
<h2 id=--arm-cpu-reference><a name=armcpureference></a> ARM CPU Reference</h2>
<h3 id=general-arm7tdmi-information-1>General ARM7TDMI Information</h3>
<ul>
 <li><a href=#armcpuoverview>ARM CPU Overview</a></li>
 <li><a href=#armcpuregisterset>ARM CPU Register Set</a></li>
 <li><a href=#armcpuflagsconditionfieldcond>ARM CPU Flags &amp; Condition Field (cond)</a></li>
 <li><a href=#armcpu26bitmemoryinterface>ARM CPU 26bit Memory Interface</a></li>
 <li><a href=#armcpuexceptions>ARM CPU Exceptions</a></li>
 <li><a href=#armcpumemoryalignments>ARM CPU Memory Alignments</a></li>
</ul>
<h3 id=arm-32bit-instruction-set-arm-code>ARM 32bit Instruction Set (ARM Code)</h3>
<ul>
 <li><a href=#arminstructionsummary>ARM Instruction Summary</a></li>
 <li><a href=#armopcodesbranchandbranchwithlinkbblbxblxswibkpt>ARM Opcodes: Branch and Branch with Link (B, BL, BX, BLX, SWI, BKPT)</a></li>
 <li><a href=#armopcodesdataprocessingalu>ARM Opcodes: Data Processing (ALU)</a></li>
 <li><a href=#armopcodesmultiplyandmultiplyaccumulatemulmla>ARM Opcodes: Multiply and Multiply-Accumulate (MUL, MLA)</a></li>
 <li><a href=#armopcodesspecialarm9instructionsclzqaddqsub>ARM Opcodes: Special ARM9 Instructions (CLZ, QADD/QSUB)</a></li>
 <li><a href=#armopcodespsrtransfermrsmsr>ARM Opcodes: PSR Transfer (MRS, MSR)</a></li>
 <li><a href=#armopcodesmemorysingledatatransferldrstrpld>ARM Opcodes: Memory: Single Data Transfer (LDR, STR, PLD)</a></li>
 <li><a href=#armopcodesmemoryhalfworddoublewordandsigneddatatransfer>ARM Opcodes: Memory: Halfword, Doubleword, and Signed Data Transfer</a></li>
 <li><a href=#armopcodesmemoryblockdatatransferldmstm>ARM Opcodes: Memory: Block Data Transfer (LDM, STM)</a></li>
 <li><a href=#armopcodesmemorysingledataswapswp>ARM Opcodes: Memory: Single Data Swap (SWP)</a></li>
 <li><a href=#armopcodescoprocessorinstructionsmrcmcrldcstccdpmcrrmrrc>ARM Opcodes: Coprocessor Instructions (MRC/MCR, LDC/STC, CDP, MCRR/MRRC)</a></li>
</ul>
<h3 id=arm-16bit-instruction-set-thumb-code>ARM 16bit Instruction Set (THUMB Code)</h3>
<p>When operating in THUMB state, cut-down 16bit opcodes are used.</p>
<p>THUMB is supported on T-variants of ARMv4 and up, ie. ARMv4T, ARMv5T, etc.</p>
<ul>
 <li><a href=#thumbinstructionsummary>THUMB Instruction Summary</a></li>
 <li><a href=#thumbopcodesregisteroperationsalubx>THUMB Opcodes: Register Operations (ALU, BX)</a></li>
 <li><a href=#thumbopcodesmemoryloadstoreldrstr>THUMB Opcodes: Memory Load/Store (LDR/STR)</a></li>
 <li><a href=#thumbopcodesmemoryaddressingaddpcsp>THUMB Opcodes: Memory Addressing (ADD PC/SP)</a></li>
 <li><a href=#thumbopcodesmemorymultipleloadstorepushpopandldmstm>THUMB Opcodes: Memory Multiple Load/Store (PUSH/POP and LDM/STM)</a></li>
 <li><a href=#thumbopcodesjumpsandcalls>THUMB Opcodes: Jumps and Calls</a></li>
</ul>
<h3 id=note-4>Note</h3>
<p>Switching between ARM and THUMB state can be done by using the Branch and
Exchange (BX) instruction.</p>
<h3 id=further-information-1>Further Information</h3>
<ul>
 <li><a href=#armpseudoinstructionsanddirectives>ARM Pseudo Instructions and Directives</a></li>
 <li><a href=#armcp15systemcontrolcoprocessor>ARM CP15 System Control Coprocessor</a></li>
 <li><a href=#armcpuinstructioncycletimes>ARM CPU Instruction Cycle Times</a></li>
 <li><a href=#armcpuversions>ARM CPU Versions</a></li>
 <li><a href=#armcpudatasheet>ARM CPU Data Sheet</a></li>
</ul>
<h2 id=--arm-cpu-overview><a name=armcpuoverview></a> ARM CPU Overview</h2>
<p>The ARM7TDMI is a 32bit RISC (Reduced Instruction Set Computer) CPU, designed
by ARM (Advanced RISC Machines), and designed for both high performance and low
power consumption.</p>
<h3 id=fast-execution>Fast Execution</h3>
<p>Depending on the CPU state, all opcodes are sized 32bit or 16bit (that’s
counting both the opcode bits and its parameters bits) providing fast decoding
and execution. Additionally, pipelining allows - (a) one instruction to be
executed while (b) the next instruction is decoded and (c) the next instruction
is fetched from memory - all at the same time.</p>
<h3 id=data-formats>Data Formats</h3>
<p>The CPU manages to deal with 8bit, 16bit, and 32bit data, that are called:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>   8bit - Byte
  16bit - Halfword
  32bit - Word
</code></pre></div></div>
<h3 id=the-two-cpu-states>The two CPU states</h3>
<p>As mentioned above, two CPU states exist:</p>
<ul>
 <li>
 <p>ARM state: Uses the full 32bit instruction set (32bit opcodes)</p>
 </li>
 <li>
 <p>THUMB state: Uses a cutdown 16bit instruction set (16bit opcodes)</p>
 </li>
</ul>
<p>Regardless of the opcode-width, both states are using 32bit registers, allowing
32bit memory addressing as well as 32bit arithmetic/logical operations.</p>
<h3 id=when-to-use-arm-state>When to use ARM state</h3>
<p>Basically, there are two advantages in ARM state:</p>
<ul>
 <li>
 <ul>
 <li>Each single opcode provides more functionality, resulting
 <ul>
 <li>in faster execution when using a 32bit bus memory system</li>
 <li>(such like opcodes stored in GBA Work RAM).</li>
 </ul>
 </li>
 </ul>
 </li>
 <li>
 <ul>
 <li>All registers R0-R15 can be accessed directly.</li>
 </ul>
 </li>
</ul>
<p>The downsides are:</p>
<ul>
 <li>
 <ul>
 <li>Not so fast when using 16bit memory system
 <ul>
 <li>(but it still works though).</li>
 </ul>
 </li>
 </ul>
 </li>
 <li>
 <ul>
 <li>Program code occupies more memory space.</li>
 </ul>
 </li>
</ul>
<h3 id=when-to-use-thumb-state>When to use THUMB state</h3>
<p>There are two major advantages in THUMB state:</p>
<ul>
 <li>
 <ul>
 <li>Faster execution up to approx 160% when using a 16bit bus
 <ul>
 <li>memory system (such like opcodes stored in GBA GamePak ROM).</li>
 </ul>
 </li>
 </ul>
 </li>
 <li>
 <ul>
 <li>Reduces code size, decreases memory overload down to approx 65%.</li>
 </ul>
 </li>
</ul>
<p>The disadvantages are:</p>
<ul>
 <li>
 <ul>
 <li>Not as multi-functional opcodes as in ARM state, so it will
 <ul>
 <li>be sometimes required use more than one opcode to gain a</li>
 <li>similar result as for a single opcode in ARM state.</li>
 </ul>
 </li>
 </ul>
 </li>
 <li>
 <ul>
 <li>Most opcodes allow only registers R0-R7 to be used directly.</li>
 </ul>
 </li>
</ul>
<h3 id=combining-arm-and-thumb-state>Combining ARM and THUMB state</h3>
<p>Switching between ARM and THUMB state is done by a normal branch (BX)
instruction which takes only a handful of cycles to execute (allowing to change
states as often as desired - with almost no overload).</p>
<p>Also, as both ARM and THUMB are using the same register set, it is possible to
pass data between ARM and THUMB mode very easily.</p>
<p>The best memory &amp; execution performance can be gained by combining both
states: THUMB for normal program code, and ARM code for timing critical
subroutines (such like interrupt handlers, or complicated algorithms).</p>
<p>Note: ARM and THUMB code cannot be executed simultaneously.</p>
<h3 id=automatic-state-changes>Automatic state changes</h3>
<p>Beside for the above manual state switching by using BX instructions, the
following situations involve automatic state changes:</p>
<ul>
 <li>
 <p>CPU switches to ARM state when executing an exception</p>
 </li>
 <li>
 <p>User switches back to old state when leaving an exception</p>
 </li>
</ul>
<h2 id=--arm-cpu-register-set><a name=armcpuregisterset></a> ARM CPU Register Set</h2>
<h3 id=overview-3>Overview</h3>
<p>The following table shows the ARM7TDMI register set which is available in each
mode. There’s a total of 37 registers (32bit each), 31 general registers (Rxx)
and 6 status registers (xPSR).</p>
<p>Note that only some registers are ‘banked’, for example, each mode has it’s own
R14 register: called R14, R14_fiq, R14_svc, etc. for each mode respectively.</p>
<p>However, other registers are not banked, for example, each mode is using the
same R0 register, so writing to R0 will always affect the content of R0 in
other modes also.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  System/User FIQ       Supervisor Abort     IRQ       Undefined
  --------------------------------------------------------------
  R0          R0        R0         R0        R0        R0
  R1          R1        R1         R1        R1        R1
  R2          R2        R2         R2        R2        R2
  R3          R3        R3         R3        R3        R3
  R4          R4        R4         R4        R4        R4
  R5          R5        R5         R5        R5        R5
  R6          R6        R6         R6        R6        R6
  R7          R7        R7         R7        R7        R7
  --------------------------------------------------------------
  R8          R8_fiq    R8         R8        R8        R8
  R9          R9_fiq    R9         R9        R9        R9
  R10         R10_fiq   R10        R10       R10       R10
  R11         R11_fiq   R11        R11       R11       R11
  R12         R12_fiq   R12        R12       R12       R12
  R13 (SP)    R13_fiq   R13_svc    R13_abt   R13_irq   R13_und
  R14 (LR)    R14_fiq   R14_svc    R14_abt   R14_irq   R14_und
  R15 (PC)    R15       R15        R15       R15       R15
  --------------------------------------------------------------
  CPSR        CPSR      CPSR       CPSR      CPSR      CPSR
  --          SPSR_fiq  SPSR_svc   SPSR_abt  SPSR_irq  SPSR_und
  --------------------------------------------------------------
</code></pre></div></div>
<h3 id=r0-r12-registers-general-purpose-registers>R0-R12 Registers (General Purpose Registers)</h3>
<p>These thirteen registers may be used for whatever general purposes. Basically,
each is having same functionality and performance, ie. there is no ‘fast
accumulator’ for arithmetic operations, and no ‘special pointer register’ for
memory addressing.</p>
<p>However, in THUMB mode only R0-R7 (Lo registers) may be accessed freely, while
R8-R12 and up (Hi registers) can be accessed only by some instructions.</p>
<h3 id=r13-register-sp>R13 Register (SP)</h3>
<p>This register is used as Stack Pointer (SP) in THUMB state. While in ARM state
the user may decided to use R13 and/or other register(s) as stack pointer(s),
or as general purpose register.</p>
<p>As shown in the table above, there’s a separate R13 register in each mode, and
(when used as SP) each exception handler may (and MUST!) use its own stack.</p>
<h3 id=r14-register-lr>R14 Register (LR)</h3>
<p>This register is used as Link Register (LR). That is, when calling to a
sub-routine by a Branch with Link (BL) instruction, then the return address
(ie. old value of PC) is saved in this register.</p>
<p>Storing the return address in the LR register is obviously faster than pushing
it into memory, however, as there’s only one LR register for each mode, the
user must manually push its content before issuing ‘nested’ subroutines.</p>
<p>Same happens when an exception is called, PC is saved in LR of new mode.</p>
<p>Note: In ARM mode, R14 may be used as general purpose register also, provided
that above usage as LR register isn’t required.</p>
<h3 id=r15-register-pc>R15 Register (PC)</h3>
<p>R15 is always used as program counter (PC). Note that when reading R15, this
will usually return a value of PC+nn because of read-ahead (pipelining),
whereas ‘nn’ depends on the instruction and on the CPU state (ARM or THUMB).</p>
<h3 id=cpsr-and-spsr-program-status-registers-armv3-and-up>CPSR and SPSR (Program Status Registers) (ARMv3 and up)</h3>
<p>The current condition codes (flags) and CPU control bits are stored in the CPSR
register. When an exception arises, the old CPSR is saved in the SPSR of the
respective exception-mode (much like PC is saved in LR).</p>
<p>For details refer to chapter about CPU Flags.</p>
<h2 id=--arm-cpu-flags--condition-field-cond><a name=armcpuflagsconditionfieldcond></a> ARM CPU Flags &amp; Condition Field (cond)</h2>
<h3 id=arm-condition-field-cond>ARM Condition Field {cond}</h3>
<p>The opcode {cond} suffixes can be used for conditionally executed code based on
the C,N,Z,V flags in CPSR register. For example: BEQ = Branch if Equal, MOVMI =
Move if Signed.</p>
<p>In ARM mode, {cond} can be used with all opcodes (except for a few newer ARMv5
instructions: BKPT, PLD, CDP2, LDC2, MCR2, MRC2, STC2, and BLX_imm are
nonconditional; however BLX_reg can be conditional).</p>
<p>In THUMB mode, {cond} can be used only for branch opcodes.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Code Suffix Flags         Meaning
  0:   EQ     Z=1           equal (zero) (same)
  1:   NE     Z=0           not equal (nonzero) (not same)
  2:   CS/HS  C=1           unsigned higher or same (carry set)
  3:   CC/LO  C=0           unsigned lower (carry cleared)
  4:   MI     N=1           negative (minus)
  5:   PL     N=0           positive or zero (plus)
  6:   VS     V=1           overflow (V set)
  7:   VC     V=0           no overflow (V cleared)
  8:   HI     C=1 and Z=0   unsigned higher
  9:   LS     C=0 or Z=1    unsigned lower or same
  A:   GE     N=V           greater or equal
  B:   LT     N&lt;&gt;V          less than
  C:   GT     Z=0 and N=V   greater than
  D:   LE     Z=1 or N&lt;&gt;V   less or equal
  E:   AL     -             always (the "AL" suffix can be omitted)
  F:   NV     -             never (ARMv1,v2 only) (Reserved ARMv3 and up)
</code></pre></div></div>
<p>Execution Time: If condition=false: 1S cycle. Otherwise: as specified for the
respective opcode.</p>
<h3 id=current-program-status-register-cpsr>Current Program Status Register (CPSR)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Expl.
  31    N - Sign Flag       (0=Not Signed, 1=Signed)               ;\
  30    Z - Zero Flag       (0=Not Zero, 1=Zero)                   ; Condition
  29    C - Carry Flag      (0=Borrow/No Carry, 1=Carry/No Borrow) ; Code Flags
  28    V - Overflow Flag   (0=No Overflow, 1=Overflow)            ;/
  27    Q - Sticky Overflow (1=Sticky Overflow, ARMv5TE and up only)
  26-8  Reserved            (For future use) - Do not change manually!
  7     I - IRQ disable     (0=Enable, 1=Disable)                     ;\
  6     F - FIQ disable     (0=Enable, 1=Disable)                     ; Control
  5     T - State Bit       (0=ARM, 1=THUMB) - Do not change manually!; Bits
  4-0   M4-M0 - Mode Bits   (See below)                               ;/
</code></pre></div></div>
<h3 id=bit-31-28-condition-code-flags-nzcv>Bit 31-28: Condition Code Flags (N,Z,C,V)</h3>
<p>These bits reflect results of logical or arithmetic instructions. In ARM mode,
it is often optionally whether an instruction should modify flags or not, for
example, it is possible to execute a SUB instruction that does NOT modify the
condition flags.</p>
<p>In ARM state, all instructions can be executed conditionally depending on the
settings of the flags, such like MOVEQ (Move if Z=1). While In THUMB state,
only Branch instructions (jumps) can be made conditionally.</p>
<h3 id=bit-27-sticky-overflow-flag-q---armv5te-and-armv5texp-and-up-only>Bit 27: Sticky Overflow Flag (Q) - ARMv5TE and ARMv5TExP and up only</h3>
<p>Used by QADD, QSUB, QDADD, QDSUB, SMLAxy, and SMLAWy only. These opcodes set
the Q-flag in case of overflows, but leave it unchanged otherwise. The Q-flag
can be tested/reset by MSR/MRS opcodes only.</p>
<h3 id=bit-27-8-reserved-bits-except-bit-27-on-armv5te-and-up-see-above>Bit 27-8: Reserved Bits (except Bit 27 on ARMv5TE and up, see above)</h3>
<p>These bits are reserved for possible future implementations. For best forwards
compatibility, the user should never change the state of these bits, and should
not expect these bits to be set to a specific value.</p>
<h3 id=bit-7-0-control-bits-iftm4-m0>Bit 7-0: Control Bits (I,F,T,M4-M0)</h3>
<p>These bits may change when an exception occurs. In privileged modes (non-user
modes) they may be also changed manually.</p>
<p>The interrupt bits I and F are used to disable IRQ and FIQ interrupts
respectively (a setting of “1” means disabled).</p>
<p>The T Bit signalizes the current state of the CPU (0=ARM, 1=THUMB), this bit
should never be changed manually - instead, changing between ARM and THUMB
state must be done by BX instructions.</p>
<p>The Mode Bits M4-M0 contain the current operating mode.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Binary Hex Dec  Expl.
  0xx00b 00h 0  - Old User       ;\26bit Backward Compatibility modes
  0xx01b 01h 1  - Old FIQ        ; (supported only on ARMv3, except ARMv3G,
  0xx10b 02h 2  - Old IRQ        ; and on some non-T variants of ARMv4)
  0xx11b 03h 3  - Old Supervisor ;/
  10000b 10h 16 - User (non-privileged)
  10001b 11h 17 - FIQ
  10010b 12h 18 - IRQ
  10011b 13h 19 - Supervisor (SWI)
  10111b 17h 23 - Abort
  11011b 1Bh 27 - Undefined
  11111b 1Fh 31 - System (privileged 'User' mode) (ARMv4 and up)
</code></pre></div></div>
<p>Writing any other values into the Mode bits is not allowed.</p>
<h3 id=saved-program-status-registers-spsr_mode>Saved Program Status Registers (SPSR_&lt;mode&gt;)</h3>
<p>Additionally to above CPSR, five Saved Program Status Registers exist:</p>
<p>SPSR_fiq, SPSR_svc, SPSR_abt, SPSR_irq, SPSR_und</p>
<p>Whenever the CPU enters an exception, the current status register (CPSR) is
copied to the respective SPSR_&lt;mode&gt; register. Note that there is only
one SPSR for each mode, so nested exceptions inside of the same mode are
allowed only if the exception handler saves the content of SPSR in memory.</p>
<p>For example, for an IRQ exception: IRQ-mode is entered, and CPSR is copied to
SPSR_irq. If the interrupt handler wants to enable nested IRQs, then it must
first push SPSR_irq before doing so.</p>
<h2 id=--arm-cpu-26bit-memory-interface><a name=armcpu26bitmemoryinterface></a> ARM CPU 26bit Memory Interface</h2>
<p>The 26bit Memory Interface was used by ARMv1 and ARMv2. The 32bit interface is
used by ARMv3 and newer, however, 26bit backward compatibility was included in
all ARMv3 (except ARMv3G), and optionally in some non-T variants of ARMv4.</p>
<h3 id=format-of-r15-in-26bit-mode-program-counter-register>Format of R15 in 26bit Mode (Program Counter Register)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit   Name     Expl.
  31-28 N,Z,C,V  Flags (Sign, Zero, Carry, Overflow)
  27-26 I,F      Interrupt Disable bits (IRQ, FIQ) (1=Disable)
  25-2  PC       Program Counter, 24bit, Step 4 (64M range)
  1-0   M1,M0    Mode (0=User, 1=FIQ, 2=IRQ, 3=Supervisor)
</code></pre></div></div>
<p>Branches with +/-32M range wrap the PC register, and can reach all 64M memory.</p>
<h3 id=reading-from-r15>Reading from R15</h3>
<p>If R15 is specified in bit16-19 of an opcode, then NZCVIF and M0,1 are masked
(zero), otherwise the full 32bits are used.</p>
<h3 id=writing-to-r15>Writing to R15</h3>
<p>ALU opcodes with S=1, and LDM opcodes with PSR=1 can write to all 32bits in R15
(in 26bit mode, that is allowed even in user mode, though it does then affect
only NZCF, not the write protected IFMM bits ???), other opcodes which write to
R15 will modify only the program counter bits. Also, special CMP/CMN/TST/TEQ{P}
opcodes can be used to write to the PSR bits in R15 without modifying the PC
bits.</p>
<h3 id=exceptions>Exceptions</h3>
<p>SWIs, Reset, Data/Prefetch Aborts and Undefined instructions enter Supervisor
mode. Interrupts enter IRQ and FIQ mode. Additionally, a special 26bit Address
Exception exists, which enters Supervisor mode on accesses to memory
addresses&gt;=64M as follows:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  R14_svc = PC ($+8, including old PSR bits)
  M1,M0 = 11b = supervisor mode, F=same, I=1, PC=14h,
  to continue at the fault location, return by SUBS PC,LR,8.
</code></pre></div></div>
<p>32bit CPUs with 26bit compatibility mode can be configured to switch into 32bit
mode when encountering exceptions.</p>
<h2 id=--arm-cpu-exceptions><a name=armcpuexceptions></a> ARM CPU Exceptions</h2>
<h3 id=exception-vectors>Exception Vectors</h3>
<p>The following are the exception vectors in memory. That is, when an exception
arises, CPU is switched into ARM state, and the program counter (PC) is loaded
by the respective address.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Address  Prio  Exception                  Mode on Entry      Interrupt Flags
  BASE+00h 1     Reset                      Supervisor (_svc)  I=1, F=1
  BASE+04h 7     Undefined Instruction      Undefined  (_und)  I=1, F=unchanged
  BASE+08h 6     Software Interrupt (SWI)   Supervisor (_svc)  I=1, F=unchanged
  BASE+0Ch 5     Prefetch Abort             Abort      (_abt)  I=1, F=unchanged
  BASE+10h 2     Data Abort                 Abort      (_abt)  I=1, F=unchanged
  BASE+14h ??    Address Exceeds 26bit      Supervisor (_svc)  I=1, F=unchanged
  BASE+18h 4     Normal Interrupt (IRQ)     IRQ        (_irq)  I=1, F=unchanged
  BASE+1Ch 3     Fast Interrupt (FIQ)       FIQ        (_fiq)  I=1, F=1
</code></pre></div></div>
<p>BASE is normally 00000000h, but may be optionally FFFF0000h in some ARM CPUs.
Priority for simultaneously occuring exceptions ranges from Prio=1=Highest to
Prio=7=Lowest.</p>
<p>As there’s only space for one ARM opcode at each of the above addresses, it’d
be usually recommended to deposit a Branch opcode into each vector, which’d
then redirect to the actual exception handlers address.</p>
<h3 id=actions-performed-by-cpu-when-entering-an-exception>Actions performed by CPU when entering an exception</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  - R14_&lt;new mode&gt;=PC+nn   ;save old PC, ie. return address
  - SPSR_&lt;new mode&gt;=CPSR   ;save old flags
  - CPSR new T,M bits      ;set to T=0 (ARM state), and M4-0=new mode
  - CPSR new I bit         ;IRQs disabled (I=1), done by ALL exceptions
  - CPSR new F bit         ;FIQs disabled (F=1), done by Reset and FIQ only
  - PC=exception_vector    ;see table above
</code></pre></div></div>
<p>Above “PC+nn” depends on the type of exception. Basically, in ARM state that
nn-offset is caused by pipelining, and in THUMB state an identical ARM-style
‘offset’ is generated (even though the ‘base address’ may be only
halfword-aligned).</p>
<h3 id=required-user-handler-actions-when-returning-from-an-exception>Required user-handler actions when returning from an exception</h3>
<p>Restore any general registers (R0-R14) which might have been modified by the
exception handler. Use return-instruction as listed in the respective
descriptions below, this will both restore PC and CPSR - that automatically
involves that the old CPU state (THUMB or ARM) as well as old state of FIQ and
IRQ disable flags are restored.</p>
<p>As mentioned above (see action on entering…), the return address is always
saved in ARM-style format, so that exception handler may use the same
return-instruction, regardless of whether the exception has been generated from
inside of ARM or THUMB state.</p>
<h3 id=fiq-fast-interrupt-request>FIQ (Fast Interrupt Request)</h3>
<p>This interrupt is generated by a LOW level on the nFIQ input. It is supposed to
process timing critical interrupts at a high priority, as fast as possible.</p>
<p>Additionally to the common banked registers (R13_fiq,R14_fiq), five extra
banked registers (R8_fiq-R12_fiq) are available in FIQ mode. The exception
handler may freely access these registers without modifying the main programs
R8-R12 registers (and without having to save that registers on stack).</p>
<p>In privileged (non-user) modes, FIQs may be also manually disabled by setting
the F Bit in CPSR.</p>
<h3 id=irq-normal-interrupt-request>IRQ (Normal Interrupt Request)</h3>
<p>This interrupt is generated by a LOW level on the nIRQ input. Unlike FIQ, the
IRQ mode is not having its own banked R8-R12 registers.</p>
<p>IRQ is having lower priority than FIQ, and IRQs are automatically disabled when
a FIQ exception becomes executed. In privileged (non-user) modes, IRQs may be
also manually disabled by setting the I Bit in CPSR.</p>
<p>To return from IRQ Mode (continuing at following opcode):</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  SUBS PC,R14,4   ;both PC=R14_irq-4, and CPSR=SPSR_irq
</code></pre></div></div>
<h3 id=software-interrupt>Software Interrupt</h3>
<p>Generated by a software interrupt instruction (SWI). Recommended to request a
supervisor (operating system) function. The SWI instruction may also contain a
parameter in the ‘comment field’ of the opcode:</p>
<p>In case that your main program issues SWIs from both inside of THUMB and ARM
states, then your exception handler must separate between 24bit comment fields
in ARM opcodes, and 8bit comment fields in THUMB opcodes (if necessary
determine old state by examining T Bit in SPSR_svc); However, in Little Endian
mode, you could use only the most significant 8bits of the 24bit ARM comment
field (as done in the GBA, for example) - the exception handler could then
process the BYTE at [R14-2], regardless of whether it’s been called from ARM or
THUMB state.</p>
<p>To return from Supervisor Mode (continuing at following opcode):</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  MOVS PC,R14   ;both PC=R14_svc, and CPSR=SPSR_svc
</code></pre></div></div>
<p>Note: Like all other exceptions, SWIs are always executed in ARM state, no
matter whether it’s been caused by an ARM or THUMB state SWI instruction.</p>
<h3 id=undefined-instruction-exception-supported-by-armv3-and-up>Undefined Instruction Exception (supported by ARMv3 and up)</h3>
<p>This exception is generated when the CPU comes across an instruction which it
cannot handle. Most likely signalizing that the program has locked up, and that
an errormessage should be displayed.</p>
<p>However, it might be also used to emulate custom functions, ie. as an
additional ‘SWI’ instruction (which’d use R14_und and SPSR_und though, and it’d
thus allow to execute the Undefined Instruction handler from inside of
Supervisor mode without having to save R14_svc and SPSR_svc).</p>
<p>To return from Undefined Mode (continuing at following opcode):</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  MOVS PC,R14   ;both PC=R14_und, and CPSR=SPSR_und
</code></pre></div></div>
<p>Note that not all unused opcodes are necessarily producing an exception, for
example, an ARM state Multiply instruction with Bit6=1 would be blindly
accepted as ‘legal’ opcode.</p>
<h3 id=abort-supported-by-armv3-and-up>Abort (supported by ARMv3 and up)</h3>
<p>Aborts (page faults) are mostly supposed for virtual memory systems (ie. not
used in GBA, as far as I know), otherwise they might be used just to display an
error message. Two types of aborts exists:</p>
<ul>
 <li>
 <p>Prefetch Abort (occurs during an instruction prefetch)</p>
 </li>
 <li>
 <p>Prefetch Abort (also occurs on BKPT opcodes, ARMv5 and up)</p>
 </li>
 <li>
 <p>Data Abort (occurs during a data access)</p>
 </li>
</ul>
<p>A virtual memory systems abort handler would then most likely determine the
fault address: For prefetch abort that’s just “R14_abt-4”. For Data abort, the
THUMB or ARM instruction at “R14_abt-8” needs to be ‘disassembled’ in order to
determine the addressed data in memory.</p>
<p>The handler would then fix the error by loading the respective memory page into
physical memory, and then retry to execute the SAME instruction again, by
returning as follows:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  prefetch abort: SUBS PC,R14,#4   ;PC=R14_abt-4, and CPSR=SPSR_abt
  data abort:     SUBS PC,R14,#8   ;PC=R14_abt-8, and CPSR=SPSR_abt
</code></pre></div></div>
<p>Separate exception vectors for prefetch/data abort exists, each should use the
respective return instruction as shown above.</p>
<h3 id=address-exceeds-26bit>Address Exceeds 26bit</h3>
<p>This exception can occur only on old ARM CPUs with 26bit address scheme (or in
26bit backwards compatibility mode).</p>
<h3 id=reset>Reset</h3>
<p>Forces PC=VVVV0000h, and forces control bits of CPSR to T=0 (ARM state), F=1
and I=1 (disable FIQ and IRQ), and M4-0=10011b (Supervisor mode).</p>
<h2 id=--arm-cpu-memory-alignments><a name=armcpumemoryalignments></a> ARM CPU Memory Alignments</h2>
<p>The CPU does NOT support accessing mis-aligned addresses (which would be rather
slow because it’d have to merge/split that data into two accesses).</p>
<p>When reading/writing code/data to/from memory, Words and Halfwords must be
located at well-aligned memory address, ie. 32bit words aligned by 4, and 16bit
halfwords aligned by 2.</p>
<h3 id=mis-aligned-strstrhstmldmldrdstrdpushpop-forced-align>Mis-aligned STR,STRH,STM,LDM,LDRD,STRD,PUSH,POP (forced align)</h3>
<p>The mis-aligned low bit(s) are ignored, the memory access goes to a forcibly
aligned (rounded-down) memory address.</p>
<p>For LDRD/STRD, it isn’t clearly defined if the address must be aligned by 8 (on
the NDS, align-4 seems to be okay) (align-8 may be required on other CPUs with
64bit databus).</p>
<h3 id=mis-aligned-ldrswp-rotated-read>Mis-aligned LDR,SWP (rotated read)</h3>
<p>Reads from forcibly aligned address “addr AND (NOT 3)”, and does then rotate
the data as “ROR (addr AND 3)*8”. That effect is internally used by LDRB and
LDRH opcodes (which do then mask-out the unused bits).</p>
<p>The SWP opcode works like a combination of LDR and STR, that means, it does
read-rotated, but does write-unrotated.</p>
<h3 id=mis-aligned-ldrhldrsh-does-or-does-not-do-strange-things>Mis-aligned LDRH,LDRSH (does or does not do strange things)</h3>
<p>On ARM9 aka ARMv5 aka NDS9:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  LDRH Rd,[odd]   --&gt;  LDRH Rd,[odd-1]        ;forced align
  LDRSH Rd,[odd]  --&gt;  LDRSH Rd,[odd-1]       ;forced align
</code></pre></div></div>
<p>On ARM7 aka ARMv4 aka NDS7/GBA:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  LDRH Rd,[odd]   --&gt;  LDRH Rd,[odd-1] ROR 8  ;read to bit0-7 and bit24-31
  LDRSH Rd,[odd]  --&gt;  LDRSB Rd,[odd]         ;sign-expand BYTE value
</code></pre></div></div>
<h3 id=mis-aligned-pcr15-branch-opcodes-or-movaluldr-with-rdr15>Mis-aligned PC/R15 (branch opcodes, or MOV/ALU/LDR with Rd=R15)</h3>
<p>For ARM code, the low bits of the target address should be usually zero,
otherwise, R15 is forcibly aligned by clearing the lower two bits.</p>
<p>For THUMB code, the low bit of the target address may/should/must be set, the
bit is (or is not) interpreted as thumb-bit (depending on the opcode), and R15
is then forcibly aligned by clearing the lower bit.</p>
<p>In short, R15 will be always forcibly aligned, so mis-aligned branches won’t
have effect on subsequent opcodes that use R15, or [R15+disp] as operand.</p>
<h2 id=--arm-instruction-summary><a name=arminstructionsummary></a> ARM Instruction Summary</h2>
<p>Modification of CPSR flags is optional for all {S} instructions.</p>
<h3 id=logical-alu-operations>Logical ALU Operations</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Instruction                      Cycles   Flags  Expl.
  MOV{cond}{S} Rd,Op2              1S+x+y    NZc-  Rd = Op2
  MVN{cond}{S} Rd,Op2              1S+x+y    NZc-  Rd = NOT Op2
  ORR{cond}{S} Rd,Rn,Op2           1S+x+y    NZc-  Rd = Rn OR Op2
  EOR{cond}{S} Rd,Rn,Op2           1S+x+y    NZc-  Rd = Rn XOR Op2
  AND{cond}{S} Rd,Rn,Op2           1S+x+y    NZc-  Rd = Rn AND Op2
  BIC{cond}{S} Rd,Rn,Op2           1S+x+y    NZc-  Rd = Rn AND NOT Op2
  TST{cond}{P}    Rn,Op2           1S+x      NZc-  Void = Rn AND Op2
  TEQ{cond}{P}    Rn,Op2           1S+x      NZc-  Void = Rn XOR Op2
</code></pre></div></div>
<p>Add x=1I cycles if Op2 shifted-by-register. Add y=1S+1N cycles if Rd=R15.</p>
<p>Carry flag affected only if Op2 contains a non-zero shift amount.</p>
<h3 id=arithmetic-alu-operations>Arithmetic ALU Operations</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Instruction                      Cycles   Flags  Expl.
  ADD{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Rn+Op2
  ADC{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Rn+Op2+Cy
  SUB{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Rn-Op2
  SBC{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Rn-Op2+Cy-1
  RSB{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Op2-Rn
  RSC{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Op2-Rn+Cy-1
  CMP{cond}{P}    Rn,Op2           1S+x      NZCV  Void = Rn-Op2
  CMN{cond}{P}    Rn,Op2           1S+x      NZCV  Void = Rn+Op2
</code></pre></div></div>
<p>Add x=1I cycles if Op2 shifted-by-register. Add y=1S+1N cycles if Rd=R15.</p>
<h3 id=multiply>Multiply</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Instruction                      Cycles   Flags  Expl.
  MUL{cond}{S} Rd,Rm,Rs            1S+mI     NZx-  Rd = Rm*Rs
  MLA{cond}{S} Rd,Rm,Rs,Rn         1S+mI+1I  NZx-  Rd = Rm*Rs+Rn
  UMULL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+1I  NZx-  RdHiLo = Rm*Rs
  UMLAL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+2I  NZx-  RdHiLo = Rm*Rs+RdHiLo
  SMULL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+1I  NZx-  RdHiLo = Rm*Rs
  SMLAL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+2I  NZx-  RdHiLo = Rm*Rs+RdHiLo
  SMLAxy{cond}  Rd,Rm,Rs,Rn     ARMv5TE(xP)  ----q Rd=HalfRm*HalfRs+Rn
  SMLAWy{cond}  Rd,Rm,Rs,Rn     ARMv5TE(xP)  ----q Rd=(Rm*HalfRs)/10000h+Rn
  SMULWy{cond}  Rd,Rm,Rs        ARMv5TE(xP)  ----  Rd=(Rm*HalfRs)/10000h
  SMLALxy{cond} RdLo,RdHi,Rm,Rs ARMv5TE(xP)  ----  RdHiLo=RdHiLo+HalfRm*HalfRs
  SMULxy{cond}  Rd,Rm,Rs        ARMv5TE(xP)  ----  Rd=HalfRm*HalfRs
</code></pre></div></div>
<h3 id=memory-loadstore>Memory Load/Store</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Instruction                      Cycles    Flags  Expl.
  LDR{cond}{B}{T} Rd,&lt;Address&gt;     1S+1N+1I+y ----  Rd=[Rn+/-&lt;offset&gt;]
  LDR{cond}H      Rd,&lt;Address&gt;     1S+1N+1I+y ----  Load Unsigned halfword
  LDR{cond}D      Rd,&lt;Address&gt;                ----  Load Dword ARMv5TE
  LDR{cond}SB     Rd,&lt;Address&gt;     1S+1N+1I+y ----  Load Signed byte
  LDR{cond}SH     Rd,&lt;Address&gt;     1S+1N+1I+y ----  Load Signed halfword
  LDM{cond}{amod} Rn{!},&lt;Rlist&gt;{^} nS+1N+1I+y ----  Load Multiple
  STR{cond}{B}{T} Rd,&lt;Address&gt;     2N         ----  [Rn+/-&lt;offset&gt;]=Rd
  STR{cond}H      Rd,&lt;Address&gt;     2N         ----  Store halfword
  STR{cond}D      Rd,&lt;Address&gt;                ----  Store Dword ARMv5TE
  STM{cond}{amod} Rn{!},&lt;Rlist&gt;{^} (n-1)S+2N  ----  Store Multiple
  SWP{cond}{B}    Rd,Rm,[Rn]       1S+2N+1I   ----  Rd=[Rn], [Rn]=Rm
  PLD             &lt;Address&gt;        1S         ----  Prepare Cache ARMv5TE
</code></pre></div></div>
<p>For LDR/LDM, add y=1S+1N if Rd=R15, or if R15 in Rlist.</p>
<h3 id=jumps-calls-cpsr-mode-and-others>Jumps, Calls, CPSR Mode, and others</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Instruction                  Cycles  Flags  Expl.
  B{cond}   label              2S+1N    ----  PC=$+8+/-32M
  BL{cond}  label              2S+1N    ----  PC=$+8+/-32M, LR=$+4
  BX{cond}  Rn                 2S+1N    ----  PC=Rn, T=Rn.0 (THUMB/ARM)
  BLX{cond} Rn                 2S+1N    ----  PC=Rn, T=Rn.0, LR=PC+4, ARM9
  BLX       label              2S+1N    ----  PC=PC+$+/-32M, LR=$+4, T=1, ARM9
  MRS{cond} Rd,Psr             1S       ----  Rd=Psr
  MSR{cond} Psr{_field},Op     1S      (psr)  Psr[field]=Op
  SWI{cond} Imm24bit           2S+1N    ----  PC=8, ARM Svc mode, LR=$+4
  BKPT      Imm16bit           ???      ----  PC=C, ARM Abt mode, LR=$+4 ARM9
  The Undefined Instruction    2S+1I+1N ----  PC=4, ARM Und mode, LR=$+4
  cond=false                   1S       ----  Any opcode with condition=false
  NOP                          1S       ----  R0=R0
</code></pre></div></div>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  CLZ{cond} Rd,Rm              ???      ----    Count Leading Zeros ARMv5
  QADD{cond} Rd,Rm,Rn                   ----q   Rd=Rm+Rn       ARMv5TE(xP)
  QSUB{cond} Rd,Rm,Rn                   ----q   Rd=Rm-Rn       ARMv5TE(xP)
  QDADD{cond} Rd,Rm,Rn                  ----q   Rd=Rm+Rn*2     ARMv5TE(xP)
  QDSUB{cond} Rd,Rm,Rn                  ----q   Rd=Rm-Rn*2     ARMv5TE(xP)
</code></pre></div></div>
<h3 id=coprocessor-functions-if-any>Coprocessor Functions (if any)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Instruction                         Cycles  Flags  Expl.
  CDP{cond} Pn,&lt;cpopc&gt;,Cd,Cn,Cm{,&lt;cp&gt;} 1S+bI   ----  Coprocessor specific
  STC{cond}{L} Pn,Cd,&lt;Address&gt;         (n-1)S+2N+bI  [address] = CRd
  LDC{cond}{L} Pn,Cd,&lt;Address&gt;         (n-1)S+2N+bI  CRd = [address]
  MCR{cond} Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;} 1S+bI+1C      CRn = Rn {&lt;op&gt; CRm}
  MRC{cond} Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;} 1S+(b+1)I+1C  Rn = CRn {&lt;op&gt; CRm}
  CDP2,STC2,LDC2,MCR2,MRC2 - ARMv5 Extensions similar above, without {cond}
  MCRR{cond} Pn,&lt;cpopc&gt;,Rd,Rn,Cm  ;write Rd,Rn to coproc ARMv5TE
  MRRC{cond} Pn,&lt;cpopc&gt;,Rd,Rn,Cm  ;read Rd,Rn from coproc ARMv5TE
</code></pre></div></div>
<h3 id=arm-binary-opcode-format>ARM Binary Opcode Format</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  |..3 ..................2 ..................1 ..................0|
  |1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0|
  |_Cond__|0_0_0|___Op__|S|__Rn___|__Rd___|__Shift__|Typ|0|__Rm___| DataProc
  |_Cond__|0_0_0|___Op__|S|__Rn___|__Rd___|__Rs___|0|Typ|1|__Rm___| DataProc
  |_Cond__|0_0_1|___Op__|S|__Rn___|__Rd___|_Shift_|___Immediate___| DataProc
  |_Cond__|0_0_1_1_0|P|1|0|_Field_|__Rd___|_Shift_|___Immediate___| PSR Imm
  |_Cond__|0_0_0_1_0|P|L|0|_Field_|__Rd___|0_0_0_0|0_0_0_0|__Rm___| PSR Reg
  |_Cond__|0_0_0_1_0_0_1_0_1_1_1_1_1_1_1_1_1_1_1_1|0_0|L|1|__Rn___| BX,BLX
  |1_1_1_0|0_0_0_1_0_0_1_0|_____immediate_________|0_1_1_1|_immed_| BKPT ARM9
  |_Cond__|0_0_0_1_0_1_1_0_1_1_1_1|__Rd___|1_1_1_1|0_0_0_1|__Rm___| CLZ  ARM9
  |_Cond__|0_0_0_1_0|Op_|0|__Rn___|__Rd___|0_0_0_0|0_1_0_1|__Rm___| QALU ARM9
  |_Cond__|0_0_0_0_0_0|A|S|__Rd___|__Rn___|__Rs___|1_0_0_1|__Rm___| Multiply
  |_Cond__|0_0_0_0_1|U|A|S|_RdHi__|_RdLo__|__Rs___|1_0_0_1|__Rm___| MulLong
  |_Cond__|0_0_0_1_0|Op_|0|Rd/RdHi|Rn/RdLo|__Rs___|1|y|x|0|__Rm___| MulHalfARM9
  |_Cond__|0_0_0_1_0|B|0_0|__Rn___|__Rd___|0_0_0_0|1_0_0_1|__Rm___| TransSwp12
  |_Cond__|0_0_0|P|U|0|W|L|__Rn___|__Rd___|0_0_0_0|1|S|H|1|__Rm___| TransReg10
  |_Cond__|0_0_0|P|U|1|W|L|__Rn___|__Rd___|OffsetH|1|S|H|1|OffsetL| TransImm10
  |_Cond__|0_1_0|P|U|B|W|L|__Rn___|__Rd___|_________Offset________| TransImm9
  |_Cond__|0_1_1|P|U|B|W|L|__Rn___|__Rd___|__Shift__|Typ|0|__Rm___| TransReg9
  |_Cond__|0_1_1|________________xxx____________________|1|__xxx__| Undefined
  |_Cond__|1_0_0|P|U|S|W|L|__Rn___|__________Register_List________| BlockTrans
  |_Cond__|1_0_1|L|___________________Offset______________________| B,BL,BLX
  |_Cond__|1_1_0|P|U|N|W|L|__Rn___|__CRd__|__CP#__|____Offset_____| CoDataTrans
  |_Cond__|1_1_0_0_0_1_0|L|__Rn___|__Rd___|__CP#__|_CPopc_|__CRm__| CoRR ARM9
  |_Cond__|1_1_1_0|_CPopc_|__CRn__|__CRd__|__CP#__|_CP__|0|__CRm__| CoDataOp
  |_Cond__|1_1_1_0|CPopc|L|__CRn__|__Rd___|__CP#__|_CP__|1|__CRm__| CoRegTrans
  |_Cond__|1_1_1_1|_____________Ignored_by_Processor______________| SWI
</code></pre></div></div>
<h2 id=--arm-opcodes-branch-and-branch-with-link-b-bl-bx-blx-swi-bkpt><a name=armopcodesbranchandbranchwithlinkbblbxblxswibkpt></a> ARM Opcodes: Branch and Branch with Link (B, BL, BX, BLX, SWI, BKPT)</h2>
<h3 id=branch-and-branch-with-link-b-bl-blx_imm>Branch and Branch with Link (B, BL, BLX_imm)</h3>
<p>Branch (B) is supposed to jump to a subroutine. Branch with Link is meant to be
used to call to a subroutine, return address is then saved in R14.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition (must be 1111b for BLX)
  27-25  Must be "101" for this instruction
  24     Opcode (0-1) (or Halfword Offset for BLX)
          0: B{cond} label    ;branch            PC=PC+8+nn*4
          1: BL{cond} label   ;branch/link       PC=PC+8+nn*4, LR=PC+4
          H: BLX label ;ARM9  ;branch/link/thumb PC=PC+8+nn*4+H*2, LR=PC+4, T=1
  23-0   nn - Signed Offset, step 4      (-32M..+32M in steps of 4)
</code></pre></div></div>
<p>Branch with Link can be used to ‘call’ to a sub-routine, which may then
‘return’ by MOV PC,R14 for example.</p>
<p>Execution Time: 2S + 1N</p>
<p>Return: No flags affected.</p>
<h3 id=branch-and-exchange-bx-blx_reg>Branch and Exchange (BX, BLX_reg)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition
  27-8   Must be "0001.0010.1111.1111.1111" for this instruction
  7-4    Opcode
          0001b: BX{cond}  Rn    ;PC=Rn, T=Rn.0  (ARMv4T and ARMv5 and up)
          0011b: BLX{cond} Rn    ;PC=Rn, T=Rn.0, LR=PC+4    (ARMv5 and up)
  3-0    Rn - Operand Register  (R0-R14)
</code></pre></div></div>
<p>Switching to THUMB Mode: Set Bit 0 of the value in Rn to 1, program continues
then at Rn-1 in THUMB mode.</p>
<p>Results in undefined behaviour if using R15 (PC+8 itself) as operand. Using BLX
R14 is possible (sets PC=Old_LR, and New_LR=retadr).</p>
<p>Execution Time: 2S + 1N</p>
<p>Return: No flags affected.</p>
<h3 id=branch-via-alu-ldr-ldm>Branch via ALU, LDR, LDM</h3>
<p>Most ALU, LDR, LDM opcodes can also change PC/R15.</p>
<h3 id=software-interrupt-swibkpt-svcabt-exceptions>Software Interrupt (SWI/BKPT) (svc/abt exceptions)</h3>
<p>SWI supposed for calls to the operating system - Enter Supervisor mode (SVC) in
ARM state. BKPT intended for debugging - enters Abort mode in ARM state via
Prefetch Abort vector.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition (must be 1110b for BKPT, ie. Condition=always)
  27-24  Opcode
          1111b: SWI{cond} nn   ;software interrupt
          0001b: BKPT      nn   ;breakpoint (ARMv5 and up)
  For SWI:
   23-0   nn - Comment Field, ignored by processor (24bit value)
  For BKPT:
   23-20  Must be 0010b for BKPT
   19-8   nn - upper 12bits of comment field, ignored by processor
   7-4    Must be 0111b for BKPT
   3-0    nn - lower 4bits of comment field, ignored by processor
</code></pre></div></div>
<p>Execution Time: 2S+1N</p>
<p>The exception handler may interprete the SWI Comment Field by examining the
lower 24bit of the 32bit opcode opcode at [R14_svc-4]. If your are also using
SWI’s from inside of THUMB, then the SWI handler must examine the T Bit
SPSR_svc in order to determine whether it’s been a THUMB SWI - and if so,
examine the lower 8bit of the 16bit opcode opcode at [R14_svc-2].</p>
<p>For Returning from SWI use “MOVS PC,R14”, that instruction does restore both PC
and CPSR, ie. PC=R14_svc, and CPSR=SPSR_svc.</p>
<p>Nesting SWIs: SPSR_svc and R14_svc should be saved on stack before either
invoking nested SWIs, or (if the IRQ handler uses SWIs) before enabling IRQs.</p>
<p>Execution SWI/BKPT:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  R14_svc=PC+4     R14_abt=PC+4   ;save return address
  SPSR_svc=CPSR    SPSR_abt=CPSR  ;save CPSR flags
  CPSR=&lt;changed&gt;   CPSR=&lt;changed&gt; ;Enter svc/abt, ARM state, IRQs disabled
  PC=VVVV0008h     PC=VVVV000Ch   ;jump to SWI/PrefetchAbort vector address
</code></pre></div></div>
<h3 id=undefined-instruction-und-exception>Undefined Instruction (und exception)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition
  27-25  Must be 011b for this instruction
  24-5   Reserved for future use
  4      Must be 1b for this instruction
  3-0    Reserved for future use
</code></pre></div></div>
<p>No assembler mnemonic exists, following bitstreams are (not) reserved.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  cond011xxxxxxxxxxxxxxxxxxxx1xxxx - reserved for future use (except below).
  cond01111111xxxxxxxxxxxx1111xxxx - free for user.
</code></pre></div></div>
<p>Execution time: 2S+1I+1N.</p>
<h2 id=--arm-opcodes-data-processing-alu><a name=armopcodesdataprocessingalu></a> ARM Opcodes: Data Processing (ALU)</h2>
<h3 id=opcode-format>Opcode Format</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition
  27-26  Must be 00b for this instruction
  25     I - Immediate 2nd Operand Flag (0=Register, 1=Immediate)
  24-21  Opcode (0-Fh)               ;*=Arithmetic, otherwise Logical
           0: AND{cond}{S} Rd,Rn,Op2    ;AND logical       Rd = Rn AND Op2
           1: EOR{cond}{S} Rd,Rn,Op2    ;XOR logical       Rd = Rn XOR Op2
           2: SUB{cond}{S} Rd,Rn,Op2 ;* ;subtract          Rd = Rn-Op2
           3: RSB{cond}{S} Rd,Rn,Op2 ;* ;subtract reversed Rd = Op2-Rn
           4: ADD{cond}{S} Rd,Rn,Op2 ;* ;add               Rd = Rn+Op2
           5: ADC{cond}{S} Rd,Rn,Op2 ;* ;add with carry    Rd = Rn+Op2+Cy
           6: SBC{cond}{S} Rd,Rn,Op2 ;* ;sub with carry    Rd = Rn-Op2+Cy-1
           7: RSC{cond}{S} Rd,Rn,Op2 ;* ;sub cy. reversed  Rd = Op2-Rn+Cy-1
           8: TST{cond}{P}    Rn,Op2    ;test            Void = Rn AND Op2
           9: TEQ{cond}{P}    Rn,Op2    ;test exclusive  Void = Rn XOR Op2
           A: CMP{cond}{P}    Rn,Op2 ;* ;compare         Void = Rn-Op2
           B: CMN{cond}{P}    Rn,Op2 ;* ;compare neg.    Void = Rn+Op2
           C: ORR{cond}{S} Rd,Rn,Op2    ;OR logical        Rd = Rn OR Op2
           D: MOV{cond}{S} Rd,Op2       ;move              Rd = Op2
           E: BIC{cond}{S} Rd,Rn,Op2    ;bit clear         Rd = Rn AND NOT Op2
           F: MVN{cond}{S} Rd,Op2       ;not               Rd = NOT Op2
  20     S - Set Condition Codes (0=No, 1=Yes) (Must be 1 for opcode 8-B)
  19-16  Rn - 1st Operand Register (R0..R15) (including PC=R15)
              Must be 0000b for MOV/MVN.
  15-12  Rd - Destination Register (R0..R15) (including PC=R15)
              Must be 0000b (or 1111b) for CMP/CMN/TST/TEQ{P}.
  When above Bit 25 I=0 (Register as 2nd Operand)
    When below Bit 4 R=0 - Shift by Immediate
      11-7   Is - Shift amount   (1-31, 0=Special/See below)
    When below Bit 4 R=1 - Shift by Register
      11-8   Rs - Shift register (R0-R14) - only lower 8bit 0-255 used
      7      Reserved, must be zero  (otherwise multiply or undefined opcode)
    6-5    Shift Type (0=LSL, 1=LSR, 2=ASR, 3=ROR)
    4      R - Shift by Register Flag (0=Immediate, 1=Register)
    3-0    Rm - 2nd Operand Register (R0..R15) (including PC=R15)
  When above Bit 25 I=1 (Immediate as 2nd Operand)
    11-8   Is - ROR-Shift applied to nn (0-30, in steps of 2)
    7-0    nn - 2nd Operand Unsigned 8bit Immediate
</code></pre></div></div>
<h3 id=second-operand-op2>Second Operand (Op2)</h3>
<p>This may be a shifted register, or a shifted immediate. See Bit 25 and 11-0.</p>
<p>Unshifted Register: Specify Op2 as “Rm”, assembler converts to “Rm,LSL#0”.</p>
<p>Shifted Register: Specify as “Rm,SSS#Is” or “Rm,SSS Rs” (SSS=LSL/LSR/ASR/ROR).</p>
<p>Immediate: Specify as 32bit value, for example: “#000NN000h”, assembler should
automatically convert into “#0NNh,ROR#0ssh” as far as possible (ie. as far as a
section of not more than 8bits of the immediate is non-zero).</p>
<h3 id=zero-shift-amount-shift-register-by-immediate-with-immediate0>Zero Shift Amount (Shift Register by Immediate, with Immediate=0)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  LSL#0: No shift performed, ie. directly Op2=Rm, the C flag is NOT affected.
  LSR#0: Interpreted as LSR#32, ie. Op2 becomes zero, C becomes Bit 31 of Rm.
  ASR#0: Interpreted as ASR#32, ie. Op2 and C are filled by Bit 31 of Rm.
  ROR#0: Interpreted as RRX#1 (RCR), like ROR#1, but Op2 Bit 31 set to old C.
</code></pre></div></div>
<p>In source code, LSR#32, ASR#32, and RRX#1 should be specified as such -
attempts to specify LSR#0, ASR#0, or ROR#0 will be internally converted to
LSL#0 by the assembler.</p>
<h3 id=using-r15-pc>Using R15 (PC)</h3>
<p>When using R15 as Destination (Rd), note below CPSR description and Execution
time description.</p>
<p>When using R15 as operand (Rm or Rn), the returned value depends on the
instruction: PC+12 if I=0,R=1 (shift by register), otherwise PC+8 (shift by
immediate).</p>
<h3 id=returned-cpsr-flags>Returned CPSR Flags</h3>
<p>If S=1, Rd&lt;&gt;R15, logical operations (AND,EOR,TST,TEQ,ORR,MOV,BIC,MVN):</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  V=not affected
  C=carryflag of shift operation (not affected if LSL#0 or Rs=00h)
  Z=zeroflag of result
  N=signflag of result (result bit 31)
</code></pre></div></div>
<p>If S=1, Rd&lt;&gt;R15, arithmetic operations (SUB,RSB,ADD,ADC,SBC,RSC,CMP,CMN):</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  V=overflowflag of result
  C=carryflag of result
  Z=zeroflag of result
  N=signflag of result (result bit 31)
</code></pre></div></div>
<p>IF S=1, with unused Rd bits=1111b, {P} opcodes (CMPP/CMNP/TSTP/TEQP):</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  R15=result  ;modify PSR bits in R15, ARMv2 and below only.
  In user mode only N,Z,C,V bits of R15 can be changed.
  In other modes additionally I,F,M1,M0 can be changed.
  The PC bits in R15 are left unchanged in all modes.
</code></pre></div></div>
<p>If S=1, Rd=R15; should not be used in user mode:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  CPSR = SPSR_&lt;current mode&gt;
  PC = result
  For example: MOVS PC,R14  ;return from SWI (PC=R14_svc, CPSR=SPSR_svc).
</code></pre></div></div>
<p>If S=0: Flags are not affected (not allowed for CMP,CMN,TEQ,TST).</p>
<p>The instruction “MOV R0,R0” is used as “NOP” opcode in 32bit ARM state.</p>
<p>Execution Time: (1+p)S+rI+pN. Whereas r=1 if I=0 and R=1 (ie. shift by
register); otherwise r=0. And p=1 if Rd=R15; otherwise p=0.</p>
<h2 id=--arm-opcodes-multiply-and-multiply-accumulate-mul-mla><a name=armopcodesmultiplyandmultiplyaccumulatemulmla></a> ARM Opcodes: Multiply and Multiply-Accumulate (MUL, MLA)</h2>
<h3 id=opcode-format-1>Opcode Format</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition
  27-25  Must be 000b for this instruction
  24-21  Opcode
          0000b: MUL{cond}{S}   Rd,Rm,Rs        ;multiply   Rd = Rm*Rs
          0001b: MLA{cond}{S}   Rd,Rm,Rs,Rn     ;mul.&amp; accumulate Rd = Rm*Rs+Rn
          0100b: UMULL{cond}{S} RdLo,RdHi,Rm,Rs ;multiply   RdHiLo=Rm*Rs
          0101b: UMLAL{cond}{S} RdLo,RdHi,Rm,Rs ;mul.&amp; acc. RdHiLo=Rm*Rs+RdHiLo
          0110b: SMULL{cond}{S} RdLo,RdHi,Rm,Rs ;sign.mul.  RdHiLo=Rm*Rs
          0111b: SMLAL{cond}{S} RdLo,RdHi,Rm,Rs ;sign.m&amp;a.  RdHiLo=Rm*Rs+RdHiLo
          1000b: SMLAxy{cond}   Rd,Rm,Rs,Rn     ;Rd=HalfRm*HalfRs+Rn
          1001b: SMLAWy{cond}   Rd,Rm,Rs,Rn     ;Rd=(Rm*HalfRs)/10000h+Rn
          1001b: SMULWy{cond}   Rd,Rm,Rs        ;Rd=(Rm*HalfRs)/10000h
          1010b: SMLALxy{cond}  RdLo,RdHi,Rm,Rs ;RdHiLo=RdHiLo+HalfRm*HalfRs
          1011b: SMULxy{cond}   Rd,Rm,Rs        ;Rd=HalfRm*HalfRs
  20     S - Set Condition Codes (0=No, 1=Yes) (Must be 0 for Halfword mul)
  19-16  Rd (or RdHi) - Destination Register (R0-R14)
  15-12  Rn (or RdLo) - Accumulate Register  (R0-R14) (Set to 0000b if unused)
  11-8   Rs - Operand Register               (R0-R14)
  For Non-Halfword Multiplies
    7-4  Must be 1001b for these instructions
  For Halfword Multiplies
    7    Must be 1 for these instructions
    6    y - Rs Top/Bottom flag (0=B=Lower 16bit, 1=T=Upper 16bit)
    5    x - Rm Top/Bottom flag (as above), or 0 for SMLAW, or 1 for SMULW
    4    Must be 0 for these instructions
  3-0    Rm - Operand Register               (R0-R14)
</code></pre></div></div>
<h3 id=multiply-and-multiply-accumulate-mul-mla>Multiply and Multiply-Accumulate (MUL, MLA)</h3>
<p>Restrictions: Rd may not be same as Rm. Rd,Rn,Rs,Rm may not be R15.</p>
<p>Note: Only the lower 32bit of the internal 64bit result are stored in Rd, thus
no sign/zero extension is required and MUL and MLA can be used for both signed
and unsigned calculations!</p>
<p>Execution Time: 1S+mI for MUL, and 1S+(m+1)I for MLA. Whereas ‘m’ depends on
whether/how many most significant bits of Rs are all zero or all one. That is
m=1 for Bit 31-8, m=2 for Bit 31-16, m=3 for Bit 31-24, and m=4 otherwise.</p>
<p>Flags (if S=1): Z=zeroflag, N=signflag, C=destroyed (ARMv4 and below) or C=not
affected (ARMv5 and up), V=not affected. MUL/MLA supported by ARMv2 and up.</p>
<h3 id=multiply-long-and-multiply-accumulate-long-mull-mlal>Multiply Long and Multiply-Accumulate Long (MULL, MLAL)</h3>
<p>Optionally supported, INCLUDED in ARMv3M, EXCLUDED in ARMv4xM/ARMv5xM.</p>
<p>Restrictions: RdHi,RdLo,Rm must be different registers. R15 may not be used.</p>
<p>Execution Time: 1S+(m+1)I for MULL, and 1S+(m+2)I for MLAL. Whereas ‘m’ depends
on whether/how many most significant bits of Rs are “all zero” (UMULL/UMLAL) or
“all zero or all one” (SMULL,SMLAL). That is m=1 for Bit31-8, m=2 for Bit31-16,
m=3 for Bit31-24, and m=4 otherwise.</p>
<p>Flags (if S=1): Z=zeroflag, N=signflag, C=destroyed (ARMv4 and below) or C=not
affected (ARMv5 and up), V=destroyed??? (ARMv4 and below???) or V=not affected
(ARMv5 and up).</p>
<h3 id=signed-halfword-multiply-smlaxysmlawysmlalxysmulxysmulwy>Signed Halfword Multiply (SMLAxy,SMLAWy,SMLALxy,SMULxy,SMULWy)</h3>
<p>Supported by E variants of ARMv5 and up, ie. ARMv5TE(xP).</p>
<p>Q-flag gets set on 32bit SMLAxy/SMLAWy addition overflows, however, the result
is NOT truncated (as it’d be done with QADD opcodes).</p>
<p>Q-flag is NOT affected on (rare) 64bit SMLALxy addition overflows.</p>
<p>SMULxy/SMULWy cannot overflow, and thus leave Q-flag unchanged as well.</p>
<p>NZCV-flags are not affected by Halfword multiplies.</p>
<p>Execution Time: 1S+Interlock (SMULxy,SMLAxy,SMULWx,SMLAWx)</p>
<p>Execution Time: 1S+1I+Interlock (SMLALxy)</p>
<h2 id=--arm-opcodes-special-arm9-instructions-clz-qaddqsub><a name=armopcodesspecialarm9instructionsclzqaddqsub></a> ARM Opcodes: Special ARM9 Instructions (CLZ, QADD/QSUB)</h2>
<h3 id=count-leading-zeros-clz>Count Leading Zeros (CLZ)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition
  27-16  Must be 0001.0110.1111b for this instruction
         Opcode (fixed)
           CLZ{cond} Rd,Rm  ;Rd=Number of leading zeros in Rm
  15-12  Rd - Destination Register              (R0-R14)
  11-4   Must be 1111.0001b for this instruction
  3-0    Rm - Source Register                   (R0-R14)
</code></pre></div></div>
<p>CLZ supported by ARMv5 and up. Execution time: 1S.</p>
<p>Return: No Flags affected. Rd=0..32.</p>
<h3 id=opcode-format-qaddqsub>Opcode Format (QADD/QSUB)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition
  27-24  Must be 0001b for this instruction
  23-20  Opcode
          0000b: QADD{cond}  Rd,Rm,Rn    ;Rd=Rm+Rn
          0010b: QSUB{cond}  Rd,Rm,Rn    ;Rd=Rm-Rn
          0100b: QDADD{cond} Rd,Rm,Rn    ;Rd=Rm+Rn*2 (doubled)
          0110b: QDSUB{cond} Rd,Rm,Rn    ;Rd=Rm-Rn*2 (doubled)
  19-16  Rn - Second Source Register            (R0-R14)
  15-12  Rd - Destination Register              (R0-R14)
  11-4   Must be 00000101b for this instruction
  3-0    Rm - First Source Register             (R0-R14)
</code></pre></div></div>
<p>Supported by E variants of ARMv5 and up, ie. ARMv5TE(xP).</p>
<p>Execution time: 1S+Interlock.</p>
<p>Results truncated to signed 32bit range in case of overflows, with the Q-flag
being set (and being left unchanged otherwise). NZCV flags are not affected.</p>
<p>Note: Rn*2 is internally processed first, and may get truncated - even if the
final result would fit into range.</p>
<h2 id=--arm-opcodes-psr-transfer-mrs-msr><a name=armopcodespsrtransfermrsmsr></a> ARM Opcodes: PSR Transfer (MRS, MSR)</h2>
<h3 id=opcode-format-2>Opcode Format</h3>
<p>These instructions occupy an unused area (TEQ,TST,CMP,CMN with S=0) of ALU
opcodes.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition
  27-26  Must be 00b for this instruction
  25     I - Immediate Operand Flag  (0=Register, 1=Immediate) (Zero for MRS)
  24-23  Must be 10b for this instruction
  22     Psr - Source/Destination PSR  (0=CPSR, 1=SPSR_&lt;current mode&gt;)
  21     Opcode
           0: MRS{cond} Rd,Psr          ;Rd = Psr
           1: MSR{cond} Psr{_field},Op  ;Psr[field] = Op
  20     Must be 0b for this instruction (otherwise TST,TEQ,CMP,CMN)
  For MRS:
    19-16   Must be 1111b for this instruction (otherwise SWP)
    15-12   Rd - Destination Register  (R0-R14)
    11-0    Not used, must be zero.
  For MSR:
    19      f  write to flags field     Bit 31-24 (aka _flg)
    18      s  write to status field    Bit 23-16 (reserved, don't change)
    17      x  write to extension field Bit 15-8  (reserved, don't change)
    16      c  write to control field   Bit 7-0   (aka _ctl)
    15-12   Not used, must be 1111b.
  For MSR Psr,Rm (I=0)
    11-4    Not used, must be zero. (otherwise BX)
    3-0     Rm - Source Register &lt;op&gt;  (R0-R14)
  For MSR Psr,Imm (I=1)
    11-8    Shift applied to Imm   (ROR in steps of two 0-30)
    7-0     Imm - Unsigned 8bit Immediate
    In source code, a 32bit immediate should be specified as operand.
    The assembler should then convert that into a shifted 8bit value.
</code></pre></div></div>
<p>MSR/MRS and CPSR/SPSR supported by ARMv3 and up.</p>
<p>ARMv2 and below contained PSR flags in R15, accessed by CMP/CMN/TST/TEQ{P}.</p>
<p>The field mask bits specify which bits of the destination Psr are write-able
(or write-protected), one or more of these bits should be set, for example,
CPSR_fsxc (aka CPSR aka CPSR_all) unlocks all bits (see below user mode
restriction though).</p>
<p>Restrictions:</p>
<p>In non-privileged mode (user mode): only condition code bits of CPSR can be
changed, control bits can’t.</p>
<p>Only the SPSR of the current mode can be accessed; In User and System modes no
SPSR exists.</p>
<p>The T-bit may not be changed; for THUMB/ARM switching use BX instruction.</p>
<p>Unused Bits in CPSR are reserved for future use and should never be changed
(except for unused bits in the flags field).</p>
<p>Execution Time: 1S.</p>
<p>Note: The A22i assembler recognizes MOV as alias for both MSR and MRS because
it is practically not possible to remember whether MSR or MRS was the load or
store opcode, and/or whether it does load to or from the Psr register.</p>
<h2 id=--arm-opcodes-memory-single-data-transfer-ldr-str-pld><a name=armopcodesmemorysingledatatransferldrstrpld></a> ARM Opcodes: Memory: Single Data Transfer (LDR, STR, PLD)</h2>
<h3 id=opcode-format-3>Opcode Format</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition (Must be 1111b for PLD)
  27-26  Must be 01b for this instruction
  25     I - Immediate Offset Flag (0=Immediate, 1=Shifted Register)
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     B - Byte/Word bit (0=transfer 32bit/word, 1=transfer 8bit/byte)
  When above Bit 24 P=0 (Post-indexing, write-back is ALWAYS enabled):
    21     T - Memory Management (0=Normal, 1=Force non-privileged access)
  When above Bit 24 P=1 (Pre-indexing, write-back is optional):
    21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     L - Load/Store bit (0=Store to memory, 1=Load from memory)
          0: STR{cond}{B}{T} Rd,&lt;Address&gt;   ;[Rn+/-&lt;offset&gt;]=Rd
          1: LDR{cond}{B}{T} Rd,&lt;Address&gt;   ;Rd=[Rn+/-&lt;offset&gt;]
         (1: PLD &lt;Address&gt; ;Prepare Cache for Load, see notes below)
          Whereas, B=Byte, T=Force User Mode (only for POST-Indexing)
  19-16  Rn - Base register               (R0..R15) (including R15=PC+8)
  15-12  Rd - Source/Destination Register (R0..R15) (including R15=PC+12)
  When above I=0 (Immediate as Offset)
    11-0   Unsigned 12bit Immediate Offset (0-4095, steps of 1)
  When above I=1 (Register shifted by Immediate as Offset)
    11-7   Is - Shift amount      (1-31, 0=Special/See below)
    6-5    Shift Type             (0=LSL, 1=LSR, 2=ASR, 3=ROR)
    4      Must be 0 (Reserved, see The Undefined Instruction)
    3-0    Rm - Offset Register   (R0..R14) (not including PC=R15)
</code></pre></div></div>
<h3 id=instruction-formats-for-address>Instruction Formats for &lt;Address&gt;</h3>
<p>An expression which generates an address:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  &lt;expression&gt;                  ;an immediate used as address
  ;*** restriction: must be located in range PC+/-4095+8, if so,
  ;*** assembler will calculate offset and use PC (R15) as base.
</code></pre></div></div>
<p>Pre-indexed addressing specification:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  [Rn]                          ;offset = zero
  [Rn, &lt;#{+/-}expression&gt;]{!}   ;offset = immediate
  [Rn, {+/-}Rm{,&lt;shift&gt;} ]{!}   ;offset = register shifted by immediate
</code></pre></div></div>
<p>Post-indexed addressing specification:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  [Rn], &lt;#{+/-}expression&gt;      ;offset = immediate
  [Rn], {+/-}Rm{,&lt;shift&gt;}       ;offset = register shifted by immediate
</code></pre></div></div>
<p>Whereas…</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  &lt;shift&gt;  immediate shift such like LSL#4, ROR#2, etc. (see ALU opcodes).
  {!}      exclamation mark ("!") indicates write-back (Rn will be updated).
</code></pre></div></div>
<h3 id=notes-7>Notes</h3>
<p>Shift amount 0 has special meaning, as described for ALU opcodes.</p>
<p>When writing a word (32bit) to memory, the address should be word-aligned.</p>
<p>When reading a byte from memory, upper 24 bits of Rd are zero-extended.</p>
<p>LDR PC,&lt;op&gt; on ARMv4 leaves CPSR.T unchanged.</p>
<p>LDR PC,&lt;op&gt; on ARMv5 sets CPSR.T to &lt;op&gt; Bit0, (1=Switch to Thumb).</p>
<p>When reading a word from a halfword-aligned address (which is located in the
middle between two word-aligned addresses), the lower 16bit of Rd will contain
[address] ie. the addressed halfword, and the upper 16bit of Rd will contain
[Rd-2] ie. more or less unwanted garbage. However, by isolating lower bits this
may be used to read a halfword from memory. (Above applies to little endian
mode, as used in GBA.)</p>
<p>In a virtual memory based environment (ie. not in the GBA), aborts (ie. page
faults) may take place during execution, if so, Rm and Rn should not specify
the same register when post-indexing is used, as the abort-handler might have
problems to reconstruct the original value of the register.</p>
<p>Return: CPSR flags are not affected.</p>
<p>Execution Time: For normal LDR: 1S+1N+1I. For LDR PC: 2S+2N+1I. For STR: 2N.</p>
<h3 id=pld-address-prepare-cache-for-load>PLD &lt;Address&gt; ;Prepare Cache for Load</h3>
<p>PLD must use following settings cond=1111b, P=1, B=1, W=0, L=1, Rd=1111b, the
address may not use post-indexing, and may not use writeback, the opcode is
encoded identical as LDRNVB R15,&lt;Address&gt;.</p>
<p>PLD signalizes to the memory system that a specific memory address will be soon
accessed, the memory system may use this hint to prepare caching/pipelining,
aside from that, PLD does not have any affect to the program logic, and behaves
identical as NOP.</p>
<p>PLD supported by ARMv5TE only, not ARMv5, not ARMv5TExP.</p>
<h2 id=--arm-opcodes-memory-halfword-doubleword-and-signed-data-transfer><a name=armopcodesmemoryhalfworddoublewordandsigneddatatransfer></a> ARM Opcodes: Memory: Halfword, Doubleword, and Signed Data Transfer</h2>
<h3 id=opcode-format-4>Opcode Format</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition
  27-25  Must be 000b for this instruction
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     I - Immediate Offset Flag (0=Register Offset, 1=Immediate Offset)
  When above Bit 24 P=0 (Post-indexing, write-back is ALWAYS enabled):
    21     Not used, must be zero (0)
  When above Bit 24 P=1 (Pre-indexing, write-back is optional):
    21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     L - Load/Store bit (0=Store to memory, 1=Load from memory)
  19-16  Rn - Base register                (R0-R15) (Including R15=PC+8)
  15-12  Rd - Source/Destination Register  (R0-R15) (Including R15=PC+12)
  11-8   When above Bit 22 I=0 (Register as Offset):
           Not used. Must be 0000b
         When above Bit 22 I=1 (immediate as Offset):
           Immediate Offset (upper 4bits)
  7      Reserved, must be set (1)
  6-5    Opcode (0-3)
         When Bit 20 L=0 (Store) (and Doubleword Load/Store):
          0: Reserved for SWP instruction
          1: STR{cond}H  Rd,&lt;Address&gt;  ;Store halfword   [a]=Rd
          2: LDR{cond}D  Rd,&lt;Address&gt;  ;Load Doubleword  R(d)=[a], R(d+1)=[a+4]
          3: STR{cond}D  Rd,&lt;Address&gt;  ;Store Doubleword [a]=R(d), [a+4]=R(d+1)
         When Bit 20 L=1 (Load):
          0: Reserved.
          1: LDR{cond}H  Rd,&lt;Address&gt;  ;Load Unsigned halfword (zero-extended)
          2: LDR{cond}SB Rd,&lt;Address&gt;  ;Load Signed byte (sign extended)
          3: LDR{cond}SH Rd,&lt;Address&gt;  ;Load Signed halfword (sign extended)
  4      Reserved, must be set (1)
  3-0    When above Bit 22 I=0:
           Rm - Offset Register            (R0-R14) (not including R15)
         When above Bit 22 I=1:
           Immediate Offset (lower 4bits)  (0-255, together with upper bits)
</code></pre></div></div>
<p>STRH,LDRH,LDRSB,LDRSH supported on ARMv4 and up.</p>
<p>STRD/LDRD supported on ARMv5TE only, not ARMv5, not ARMv5TExP.</p>
<p>STRD/LDRD: base writeback: Rn should not be same as R(d) or R(d+1).</p>
<p>STRD: index register: Rm should not be same as R(d) or R(d+1).</p>
<p>STRD/LDRD: Rd must be an even numbered register (R0,R2,R4,R6,R8,R10,R12).</p>
<p>STRD/LDRD: Address must be double-word aligned (multiple of eight).</p>
<h3 id=instruction-formats-for-address-1>Instruction Formats for &lt;Address&gt;</h3>
<p>An expression which generates an address:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  &lt;expression&gt;                  ;an immediate used as address
  ;*** restriction: must be located in range PC+/-255+8, if so,
  ;*** assembler will calculate offset and use PC (R15) as base.
</code></pre></div></div>
<p>Pre-indexed addressing specification:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  [Rn]                          ;offset = zero
  [Rn, &lt;#{+/-}expression&gt;]{!}   ;offset = immediate
  [Rn, {+/-}Rm]{!}              ;offset = register
</code></pre></div></div>
<p>Post-indexed addressing specification:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  [Rn], &lt;#{+/-}expression&gt;      ;offset = immediate
  [Rn], {+/-}Rm                 ;offset = register
</code></pre></div></div>
<p>Whereas…</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  {!}      exclamation mark ("!") indicates write-back (Rn will be updated).
</code></pre></div></div>
<p>Return: No Flags affected.</p>
<p>Execution Time: For Normal LDR, 1S+1N+1I. For LDR PC, 2S+2N+1I. For STRH 2N.</p>
<h2 id=--arm-opcodes-memory-block-data-transfer-ldm-stm><a name=armopcodesmemoryblockdatatransferldmstm></a> ARM Opcodes: Memory: Block Data Transfer (LDM, STM)</h2>
<h3 id=opcode-format-5>Opcode Format</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition
  27-25  Must be 100b for this instruction
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     S - PSR &amp; force user bit (0=No, 1=load PSR or force user mode)
  21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     L - Load/Store bit (0=Store to memory, 1=Load from memory)
          0: STM{cond}{amod} Rn{!},&lt;Rlist&gt;{^}  ;Store (Push)
          1: LDM{cond}{amod} Rn{!},&lt;Rlist&gt;{^}  ;Load  (Pop)
          Whereas, {!}=Write-Back (W), and {^}=PSR/User Mode (S)
  19-16  Rn - Base register                (R0-R14) (not including R15)
  15-0   Rlist - Register List
  (Above 'offset' is meant to be the number of words specified in Rlist.)
</code></pre></div></div>
<p>Return: No Flags affected.</p>
<p>Execution Time: For normal LDM, nS+1N+1I. For LDM PC, (n+1)S+2N+1I. For STM
(n-1)S+2N. Where n is the number of words transferred.</p>
<h3 id=addressing-modes-amod>Addressing Modes {amod}</h3>
<p>The IB,IA,DB,DA suffixes directly specify the desired U and P bits:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  IB  increment before          ;P=1, U=1
  IA  increment after           ;P=0, U=1
  DB  decrement before          ;P=1, U=0
  DA  decrement after           ;P=0, U=0
</code></pre></div></div>
<p>Alternately, FD,ED,FA,EA could be used, mostly to simplify mnemonics for stack
transfers.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  ED  empty stack, descending   ;LDM: P=1, U=1  ;STM: P=0, U=0
  FD  full stack,  descending   ;     P=0, U=1  ;     P=1, U=0
  EA  empty stack, ascending    ;     P=1, U=0  ;     P=0, U=1
  FA  full stack,  ascending    ;     P=0, U=0  ;     P=1, U=1
</code></pre></div></div>
<p>Ie. the following expressions are aliases for each other:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  STMFD=STMDB=PUSH   STMED=STMDA   STMFA=STMIB   STMEA=STMIA
  LDMFD=LDMIA=POP    LDMED=LDMIB   LDMFA=LDMDA   LDMEA=LDMDB
</code></pre></div></div>
<p>Note: The equivalent THUMB functions use fixed organization:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  PUSH/POP: full descending     ;base register SP (R13)
  LDM/STM:  increment after     ;base register R0..R7
</code></pre></div></div>
<p>Descending is common stack organization as used in 80x86 and Z80 CPUs, SP is
decremented when pushing/storing data, and incremented when popping/loading
data.</p>
<h3 id=when-s-bit-is-set-s1>When S Bit is set (S=1)</h3>
<p>If instruction is LDM and R15 is in the list: (Mode Changes)</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  While R15 loaded, additionally: CPSR=SPSR_&lt;current mode&gt;
</code></pre></div></div>
<p>Otherwise: (User bank transfer)</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Rlist is referring to User Bank Registers, R0-R15 (rather than
  register related to the current mode, such like R14_svc etc.)
  Base write-back should not be used for User bank transfer.
  Caution - When instruction is LDM:
  If the following instruction reads from a banked register (eg. R14_svc),
  then CPU might still read R14 instead; if necessary insert a dummy NOP.
</code></pre></div></div>
<h3 id=notes-8>Notes</h3>
<p>The base address should be usually word-aligned.</p>
<p>LDM Rn,…,PC on ARMv4 leaves CPSR.T unchanged.</p>
<p>LDR Rn,…,PC on ARMv5 sets CPSR.T to &lt;op&gt; Bit0, (1=Switch to Thumb).</p>
<h3 id=transfer-order>Transfer Order</h3>
<p>The lowest Register in Rlist (R0 if its in the list) will be loaded/stored
to/from the lowest memory address.</p>
<p>Internally, the rlist register are always processed with INCREASING addresses
(ie. for DECREASING addressing modes, the CPU does first calculate the lowest
address, and does then process rlist with increasing addresses; this detail can
be important when accessing memory mapped I/O ports).</p>
<h3 id=strange-effects-on-invalid-rlists>Strange Effects on Invalid Rlist’s</h3>
<p>Empty Rlist: R15 loaded/stored (ARMv4 only), and Rb=Rb+/-40h (ARMv4-v5).</p>
<p>Writeback with Rb included in Rlist: Store OLD base if Rb is FIRST entry in
Rlist, otherwise store NEW base (STM/ARMv4), always store OLD base (STM/ARMv5),
no writeback (LDM/ARMv4), writeback if Rb is “the ONLY register, or NOT the
LAST register” in Rlist (LDM/ARMv5).</p>
<h2 id=--arm-opcodes-memory-single-data-swap-swp><a name=armopcodesmemorysingledataswapswp></a> ARM Opcodes: Memory: Single Data Swap (SWP)</h2>
<h3 id=opcode-format-6>Opcode Format</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition
  27-23  Must be 00010b for this instruction
         Opcode (fixed)
           SWP{cond}{B} Rd,Rm,[Rn]      ;Rd=[Rn], [Rn]=Rm
  22     B - Byte/Word bit (0=swap 32bit/word, 1=swap 8bit/byte)
  21-20  Must be 00b for this instruction
  19-16  Rn - Base register                     (R0-R14)
  15-12  Rd - Destination Register              (R0-R14)
  11-4   Must be 00001001b for this instruction
  3-0    Rm - Source Register                   (R0-R14)
</code></pre></div></div>
<p>SWP/SWPB supported by ARMv2a and up.</p>
<p>Swap works properly including if Rm and Rn specify the same register.</p>
<p>R15 may not be used for either Rn,Rd,Rm. (Rn=R15 would be MRS opcode).</p>
<p>Upper bits of Rd are zero-expanded when using Byte quantity. For info about
byte and word data memory addressing, read LDR and STR opcode description.</p>
<p>Execution Time: 1S+2N+1I. That is, 2N data cycles, 1S code cycle, plus 1I.</p>
<h2 id=--arm-opcodes-coprocessor-instructions-mrcmcr-ldcstc-cdp-mcrrmrrc><a name=armopcodescoprocessorinstructionsmrcmcrldcstccdpmcrrmrrc></a> ARM Opcodes: Coprocessor Instructions (MRC/MCR, LDC/STC, CDP, MCRR/MRRC)</h2>
<h3 id=coprocessor-register-transfers-mrc-mcr-with-arm-register-readwrite>Coprocessor Register Transfers (MRC, MCR) (with ARM Register read/write)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition (or 1111b for MRC2/MCR2 opcodes on ARMv5 and up)
  27-24  Must be 1110b for this instruction
  23-21  CP Opc - Coprocessor operation code         (0-7)
  20     ARM-Opcode (0-1)
          0: MCR{cond} Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;}   ;move from ARM to CoPro
          0: MCR2      Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;}   ;move from ARM to CoPro
          1: MRC{cond} Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;}   ;move from CoPro to ARM
          1: MRC2      Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;}   ;move from CoPro to ARM
  19-16  Cn     - Coprocessor source/dest. Register  (C0-C15)
  15-12  Rd     - ARM source/destination Register    (R0-R15)
  11-8   Pn     - Coprocessor number                 (P0-P15)
  7-5    CP     - Coprocessor information            (0-7)
  4      Reserved, must be one (1) (otherwise CDP opcode)
  3-0    Cm     - Coprocessor operand Register       (C0-C15)
</code></pre></div></div>
<p>MCR/MRC supported by ARMv2 and up, MCR2/MRC2 by ARMv5 and up.</p>
<p>A22i syntax allows to use MOV with Rd specified as first (dest), or last
(source) operand. Native MCR/MRC syntax uses Rd as middle operand, &lt;cp&gt;
can be ommited if &lt;cp&gt; is zero.</p>
<p>When using MCR with R15: Coprocessor will receive a data value of PC+12.</p>
<p>When using MRC with R15: Bit 31-28 of data are copied to Bit 31-28 of CPSR (ie.
N,Z,C,V flags), other data bits are ignored, CPSR Bit 27-0 are not affected,
R15 (PC) is not affected.</p>
<p>Execution time: 1S+bI+1C for MCR, 1S+(b+1)I+1C for MRC.</p>
<p>Return: For MRC only: Either R0-R14 modified, or flags affected (see above).</p>
<p>For details refer to original ARM docs. The opcodes irrelevant for GBA/NDS7
because no coprocessor exists (except for a dummy CP14 unit). However, NDS9
includes a working CP15 unit.</p>
<ul>
 <li><a href=#armcp14icebreakerdebugcommunicationschannel>ARM CP14 ICEbreaker Debug Communications Channel</a></li>
 <li><a href=#armcp15systemcontrolcoprocessor>ARM CP15 System Control Coprocessor</a></li>
</ul>
<h3 id=coprocessor-data-transfers-ldc-stc-with-memory-readwrite>Coprocessor Data Transfers (LDC, STC) (with Memory read/write)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition (or 1111b for LDC2/STC2 opcodes on ARMv5 and up)
  27-25  Must be 110b for this instruction
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     N - Transfer length (0-1, interpretation depends on co-processor)
  21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     Opcode (0-1)
          0: STC{cond}{L} Pn,Cd,&lt;Address&gt;  ;Store to memory (from coprocessor)
          0: STC2{L}      Pn,Cd,&lt;Address&gt;  ;Store to memory (from coprocessor)
          1: LDC{cond}{L} Pn,Cd,&lt;Address&gt;  ;Read from memory (to coprocessor)
          1: LDC2{L}      Pn,Cd,&lt;Address&gt;  ;Read from memory (to coprocessor)
          whereas {L} indicates long transfer (Bit 22: N=1)
  19-16  Rn     - ARM Base Register              (R0-R15)     (R15=PC+8)
  15-12  Cd     - Coprocessor src/dest Register  (C0-C15)
  11-8   Pn     - Coprocessor number             (P0-P15)
  7-0    Offset - Unsigned Immediate, step 4     (0-1020, in steps of 4)
</code></pre></div></div>
<p>LDC/STC supported by ARMv2 and up, LDC2/STC2 by ARMv5 and up.</p>
<p>Execution time: (n-1)S+2N+bI, n=number of words transferred.</p>
<p>For details refer to original ARM docs, irrelevant in GBA because no
coprocessor exists.</p>
<h3 id=coprocessor-data-operations-cdp-without-memory-or-arm-register-operand>Coprocessor Data Operations (CDP) (without Memory or ARM Register operand)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition (or 1111b for CDP2 opcode on ARMv5 and up)
  27-24  Must be 1110b for this instruction
         ARM-Opcode (fixed)
           CDP{cond} Pn,&lt;cpopc&gt;,Cd,Cn,Cm{,&lt;cp&gt;}
           CDP2      Pn,&lt;cpopc&gt;,Cd,Cn,Cm{,&lt;cp&gt;}
  23-20  CP Opc - Coprocessor operation code       (0-15)
  19-16  Cn     - Coprocessor operand Register     (C0-C15)
  15-12  Cd     - Coprocessor destination Register (C0-C15)
  11-8   Pn     - Coprocessor number               (P0-P15)
  7-5    CP     - Coprocessor information          (0-7)
  4      Reserved, must be zero (otherwise MCR/MRC opcode)
  3-0    Cm     - Coprocessor operand Register     (C0-C15)
</code></pre></div></div>
<p>CDP supported by ARMv2 and up, CDP2 by ARMv5 and up.</p>
<p>Execution time: 1S+bI, b=number of cycles in coprocessor busy-wait loop.</p>
<p>Return: No flags affected, no ARM-registers used/modified.</p>
<p>For details refer to original ARM docs, irrelevant in GBA because no
coprocessor exists.</p>
<h3 id=coprocessor-double-register-transfer-mcrr-mrrc---armv5te-only>Coprocessor Double-Register Transfer (MCRR, MRRC) - ARMv5TE only</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Bit    Expl.
  31-28  Condition
  27-21  Must be 1100010b for this instruction
  20     L - Opcode (Load/Store)
          0: MCRR{cond} Pn,opcode,Rd,Rn,Cm  ;write Rd,Rn to coproc
          1: MRRC{cond} Pn,opcode,Rd,Rn,Cm  ;read Rd,Rn from coproc
  19-16  Rn - Second source/dest register      (R0-R14)
  15-12  Rd - First source/dest register       (R0-R14)
  11-8   Pn     - Coprocessor number           (P0-P15)
  7-4    CP Opc - Coprocessor operation code   (0-15)
  3-0    Cm     - Coprocessor operand Register (C0-C15)
</code></pre></div></div>
<p>Supported by ARMv5TE only, not ARMv5, not ARMv5TExP.</p>
<h2 id=--thumb-instruction-summary><a name=thumbinstructionsummary></a> THUMB Instruction Summary</h2>
<p>The table below lists all THUMB mode instructions with clock cycles, affected
CPSR flags, Format/chapter number, and description.</p>
<p>Only register R0..R7 can be used in thumb mode (unless R8-15,SP,PC are
explicitly mentioned).</p>
<h3 id=logical-operations>Logical Operations</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Instruction        Cycles Flags Format Expl.
  MOV Rd,Imm8bit      1S     NZ--  3   Rd=nn
  MOV Rd,Rs           1S     NZ00  2   Rd=Rs+0
  MOV R0..14,R8..15   1S     ----  5   Rd=Rs
  MOV R8..14,R0..15   1S     ----  5   Rd=Rs
  MOV R15,R0..15      2S+1N  ----  5   PC=Rs
  MVN Rd,Rs           1S     NZ--  4   Rd=NOT Rs
  AND Rd,Rs           1S     NZ--  4   Rd=Rd AND Rs
  TST Rd,Rs           1S     NZ--  4 Void=Rd AND Rs
  BIC Rd,Rs           1S     NZ--  4   Rd=Rd AND NOT Rs
  ORR Rd,Rs           1S     NZ--  4   Rd=Rd OR Rs
  EOR Rd,Rs           1S     NZ--  4   Rd=Rd XOR Rs
  LSL Rd,Rs,Imm5bit   1S     NZc-  1   Rd=Rs SHL nn
  LSL Rd,Rs           1S+1I  NZc-  4   Rd=Rd SHL (Rs AND 0FFh)
  LSR Rd,Rs,Imm5bit   1S     NZc-  1   Rd=Rs SHR nn
  LSR Rd,Rs           1S+1I  NZc-  4   Rd=Rd SHR (Rs AND 0FFh)
  ASR Rd,Rs,Imm5bit   1S     NZc-  1   Rd=Rs SAR nn
  ASR Rd,Rs           1S+1I  NZc-  4   Rd=Rd SAR (Rs AND 0FFh)
  ROR Rd,Rs           1S+1I  NZc-  4   Rd=Rd ROR (Rs AND 0FFh)
  NOP                 1S     ----  5   R8=R8
</code></pre></div></div>
<p>Carry flag affected only if shift amount is non-zero.</p>
<h3 id=arithmetic-operations-and-multiply>Arithmetic Operations and Multiply</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Instruction        Cycles Flags Format Expl.
  ADD Rd,Rs,Imm3bit   1S     NZCV  2   Rd=Rs+nn
  ADD Rd,Imm8bit      1S     NZCV  3   Rd=Rd+nn
  ADD Rd,Rs,Rn        1S     NZCV  2   Rd=Rs+Rn
  ADD R0..14,R8..15   1S     ----  5   Rd=Rd+Rs
  ADD R8..14,R0..15   1S     ----  5   Rd=Rd+Rs
  ADD R15,R0..15      2S+1N  ----  5   PC=Rd+Rs
  ADD Rd,PC,Imm8bit*4 1S     ---- 12   Rd=(($+4) AND NOT 2)+nn
  ADD Rd,SP,Imm8bit*4 1S     ---- 12   Rd=SP+nn
  ADD SP,Imm7bit*4    1S     ---- 13   SP=SP+nn
  ADD SP,-Imm7bit*4   1S     ---- 13   SP=SP-nn
  ADC Rd,Rs           1S     NZCV  4   Rd=Rd+Rs+Cy
  SUB Rd,Rs,Imm3Bit   1S     NZCV  2   Rd=Rs-nn
  SUB Rd,Imm8bit      1S     NZCV  3   Rd=Rd-nn
  SUB Rd,Rs,Rn        1S     NZCV  2   Rd=Rs-Rn
  SBC Rd,Rs           1S     NZCV  4   Rd=Rd-Rs-NOT Cy
  NEG Rd,Rs           1S     NZCV  4   Rd=0-Rs
  CMP Rd,Imm8bit      1S     NZCV  3 Void=Rd-nn
  CMP Rd,Rs           1S     NZCV  4 Void=Rd-Rs
  CMP R0-15,R8-15     1S     NZCV  5 Void=Rd-Rs
  CMP R8-15,R0-15     1S     NZCV  5 Void=Rd-Rs
  CMN Rd,Rs           1S     NZCV  4 Void=Rd+Rs
  MUL Rd,Rs           1S+mI  NZx-  4   Rd=Rd*Rs
</code></pre></div></div>
<h3 id=jumps-and-calls>Jumps and Calls</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Instruction        Cycles    Flags Format Expl.
  B disp              2S+1N     ---- 18  PC=$+/-2048
  BL disp             3S+1N     ---- 19  PC=$+/-4M, LR=$+5
  B{cond=true} disp   2S+1N     ---- 16  PC=$+/-0..256
  B{cond=false} disp  1S        ---- 16  N/A
  BX R0..15           2S+1N     ----  5  PC=Rs, ARM/THUMB (Rs bit0)
  SWI Imm8bit         2S+1N     ---- 17  PC=8, ARM SVC mode, LR=$+2
  BKPT Imm8bit        ???       ---- 17  ??? ARM9 Prefetch Abort
  BLX disp            ???       ---- ??? ??? ARM9
  BLX R0..R14         ???       ---- ??? ??? ARM9
  POP {Rlist,}PC   (n+1)S+2N+1I ---- 14
  MOV R15,R0..15      2S+1N     ----  5  PC=Rs
  ADD R15,R0..15      2S+1N     ----  5  PC=Rd+Rs
</code></pre></div></div>
<p>The thumb BL instruction occupies two 16bit opcodes, 32bit in total.</p>
<h3 id=memory-loadstore-1>Memory Load/Store</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Instruction        Cycles    Flags Format Expl.
  LDR  Rd,[Rb,5bit*4] 1S+1N+1I  ----  9  Rd = WORD[Rb+nn]
  LDR  Rd,[PC,8bit*4] 1S+1N+1I  ----  6  Rd = WORD[PC+nn]
  LDR  Rd,[SP,8bit*4] 1S+1N+1I  ---- 11  Rd = WORD[SP+nn]
  LDR  Rd,[Rb,Ro]     1S+1N+1I  ----  7  Rd = WORD[Rb+Ro]
  LDRB Rd,[Rb,5bit*1] 1S+1N+1I  ----  9  Rd = BYTE[Rb+nn]
  LDRB Rd,[Rb,Ro]     1S+1N+1I  ----  7  Rd = BYTE[Rb+Ro]
  LDRH Rd,[Rb,5bit*2] 1S+1N+1I  ---- 10  Rd = HALFWORD[Rb+nn]
  LDRH Rd,[Rb,Ro]     1S+1N+1I  ----  8  Rd = HALFWORD[Rb+Ro]
  LDSB Rd,[Rb,Ro]     1S+1N+1I  ----  8  Rd = SIGNED_BYTE[Rb+Ro]
  LDSH Rd,[Rb,Ro]     1S+1N+1I  ----  8  Rd = SIGNED_HALFWORD[Rb+Ro]
  STR  Rd,[Rb,5bit*4] 2N        ----  9  WORD[Rb+nn] = Rd
  STR  Rd,[SP,8bit*4] 2N        ---- 11  WORD[SP+nn] = Rd
  STR  Rd,[Rb,Ro]     2N        ----  7  WORD[Rb+Ro] = Rd
  STRB Rd,[Rb,5bit*1] 2N        ----  9  BYTE[Rb+nn] = Rd
  STRB Rd,[Rb,Ro]     2N        ----  7  BYTE[Rb+Ro] = Rd
  STRH Rd,[Rb,5bit*2] 2N        ---- 10  HALFWORD[Rb+nn] = Rd
  STRH Rd,[Rb,Ro]     2N        ----  8  HALFWORD[Rb+Ro]=Rd
  PUSH {Rlist}{LR}    (n-1)S+2N ---- 14
  POP  {Rlist}{PC}              ---- 14  (ARM9: with mode switch)
  STMIA Rb!,{Rlist}   (n-1)S+2N ---- 15
  LDMIA Rb!,{Rlist}   nS+1N+1I  ---- 15
</code></pre></div></div>
<h3 id=thumb-binary-opcode-format>THUMB Binary Opcode Format</h3>
<p>This table summarizes the position of opcode/parameter bits for THUMB mode
instructions, Format 1-19.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code> Form|_15|_14|_13|_12|_11|_10|_9_|_8_|_7_|_6_|_5_|_4_|_3_|_2_|_1_|_0_|
 __1_|_0___0___0_|__Op___|_______Offset______|____Rs_____|____Rd_____|Shifted
 __2_|_0___0___0___1___1_|_I,_Op_|___Rn/nn___|____Rs_____|____Rd_____|ADD/SUB
 __3_|_0___0___1_|__Op___|____Rd_____|_____________Offset____________|Immedi.
 __4_|_0___1___0___0___0___0_|______Op_______|____Rs_____|____Rd_____|AluOp
 __5_|_0___1___0___0___0___1_|__Op___|Hd_|Hs_|____Rs_____|____Rd_____|HiReg/BX
 __6_|_0___1___0___0___1_|____Rd_____|_____________Word______________|LDR PC
 __7_|_0___1___0___1_|__Op___|_0_|___Ro______|____Rb_____|____Rd_____|LDR/STR
 __8_|_0___1___0___1_|__Op___|_1_|___Ro______|____Rb_____|____Rd_____|""H/SB/SH
 __9_|_0___1___1_|__Op___|_______Offset______|____Rb_____|____Rd_____|""{B}
 _10_|_1___0___0___0_|Op_|_______Offset______|____Rb_____|____Rd_____|""H
 _11_|_1___0___0___1_|Op_|____Rd_____|_____________Word______________|"" SP
 _12_|_1___0___1___0_|Op_|____Rd_____|_____________Word______________|ADD PC/SP
 _13_|_1___0___1___1___0___0___0___0_|_S_|___________Word____________|ADD SP,nn
 _14_|_1___0___1___1_|Op_|_1___0_|_R_|____________Rlist______________|PUSH/POP
 _17_|_1___0___1___1___1___1___1___0_|___________User_Data___________|BKPT ARM9
 _15_|_1___1___0___0_|Op_|____Rb_____|____________Rlist______________|STM/LDM
 _16_|_1___1___0___1_|_____Cond______|_________Signed_Offset_________|B{cond}
 _U__|_1___1___0___1___1___1___1___0_|_____________var_______________|UndefARM9
 _17_|_1___1___0___1___1___1___1___1_|___________User_Data___________|SWI
 _18_|_1___1___1___0___0_|________________Offset_____________________|B
 _19_|_1___1___1___0___1_|_________________________var___________|_0_|BLX.ARM9
 _U__|_1___1___1___0___1_|_________________________var___________|_1_|UndefARM9
 _19_|_1___1___1___1_|_H_|______________Offset_Low/High______________|BL,BLX
</code></pre></div></div>
<p>Further UNDEFS ??? ARM9?</p>
<ul>
 <li>1011 0001 xxxxxxxx (reserved)</li>
 <li>1011 0x1x xxxxxxxx (reserved)</li>
 <li>1011 10xx xxxxxxxx (reserved)</li>
 <li>1011 1111 xxxxxxxx (reserved)</li>
 <li>1101 1110 xxxxxxxx (free for user)</li>
</ul>
<h2 id=--thumb-opcodes-register-operations-alu-bx><a name=thumbopcodesregisteroperationsalubx></a> THUMB Opcodes: Register Operations (ALU, BX)</h2>
<h3 id=thumb1-move-shifted-register>THUMB.1: move shifted register</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-13  Must be 000b for 'move shifted register' instructions
  12-11  Opcode
           00b: LSL Rd,Rs,#Offset   (logical/arithmetic shift left)
           01b: LSR Rd,Rs,#Offset   (logical    shift right)
           10b: ASR Rd,Rs,#Offset   (arithmetic shift right)
           11b: Reserved (used for add/subtract instructions)
  10-6   Offset                     (0-31)
  5-3    Rs - Source register       (R0..R7)
  2-0    Rd - Destination register  (R0..R7)
</code></pre></div></div>
<p>Example: LSL Rd,Rs,#nn ; Rd = Rs &lt;&lt; nn ; ARM equivalent: MOVS Rd,Rs,LSL
#nn</p>
<p>Zero shift amount is having special meaning (same as for ARM shifts), LSL#0
performs no shift (the carry flag remains unchanged), LSR/ASR#0 are interpreted
as LSR/ASR#32. Attempts to specify LSR/ASR#0 in source code are automatically
redirected as LSL#0, and source LSR/ASR#32 is redirected as opcode LSR/ASR#0.</p>
<p>Execution Time: 1S</p>
<p>Flags: Z=zeroflag, N=sign, C=carry (except LSL#0: C=unchanged), V=unchanged.</p>
<h3 id=thumb2-addsubtract>THUMB.2: add/subtract</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-11  Must be 00011b for 'add/subtract' instructions
  10-9   Opcode (0-3)
           0: ADD Rd,Rs,Rn   ;add register        Rd=Rs+Rn
           1: SUB Rd,Rs,Rn   ;subtract register   Rd=Rs-Rn
           2: ADD Rd,Rs,#nn  ;add immediate       Rd=Rs+nn
           3: SUB Rd,Rs,#nn  ;subtract immediate  Rd=Rs-nn
         Pseudo/alias opcode with Imm=0:
           2: MOV Rd,Rs      ;move (affects cpsr) Rd=Rs+0
  8-6    For Register Operand:
           Rn - Register Operand (R0..R7)
         For Immediate Operand:
           nn - Immediate Value  (0-7)
  5-3    Rs - Source register       (R0..R7)
  2-0    Rd - Destination register  (R0..R7)
</code></pre></div></div>
<p>Return: Rd contains result, N,Z,C,V affected (including MOV).</p>
<p>Execution Time: 1S</p>
<h3 id=thumb3-movecompareaddsubtract-immediate>THUMB.3: move/compare/add/subtract immediate</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-13  Must be 001b for this type of instructions
  12-11  Opcode
           00b: MOV Rd,#nn      ;move     Rd   = #nn
           01b: CMP Rd,#nn      ;compare  Void = Rd - #nn
           10b: ADD Rd,#nn      ;add      Rd   = Rd + #nn
           11b: SUB Rd,#nn      ;subtract Rd   = Rd - #nn
  10-8   Rd - Destination Register  (R0..R7)
  7-0    nn - Unsigned Immediate    (0-255)
</code></pre></div></div>
<p>ARM equivalents for MOV/CMP/ADD/SUB are MOVS/CMP/ADDS/SUBS same format.</p>
<p>Execution Time: 1S</p>
<p>Return: Rd contains result (except CMP), N,Z,C,V affected (for MOV only N,Z).</p>
<h3 id=thumb4-alu-operations>THUMB.4: ALU operations</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-10  Must be 010000b for this type of instructions
  9-6    Opcode (0-Fh)
           0: AND Rd,Rs     ;AND logical       Rd = Rd AND Rs
           1: EOR Rd,Rs     ;XOR logical       Rd = Rd XOR Rs
           2: LSL Rd,Rs     ;log. shift left   Rd = Rd &lt;&lt; (Rs AND 0FFh)
           3: LSR Rd,Rs     ;log. shift right  Rd = Rd &gt;&gt; (Rs AND 0FFh)
           4: ASR Rd,Rs     ;arit shift right  Rd = Rd SAR (Rs AND 0FFh)
           5: ADC Rd,Rs     ;add with carry    Rd = Rd + Rs + Cy
           6: SBC Rd,Rs     ;sub with carry    Rd = Rd - Rs - NOT Cy
           7: ROR Rd,Rs     ;rotate right      Rd = Rd ROR (Rs AND 0FFh)
           8: TST Rd,Rs     ;test            Void = Rd AND Rs
           9: NEG Rd,Rs     ;negate            Rd = 0 - Rs
           A: CMP Rd,Rs     ;compare         Void = Rd - Rs
           B: CMN Rd,Rs     ;neg.compare     Void = Rd + Rs
           C: ORR Rd,Rs     ;OR logical        Rd = Rd OR Rs
           D: MUL Rd,Rs     ;multiply          Rd = Rd * Rs
           E: BIC Rd,Rs     ;bit clear         Rd = Rd AND NOT Rs
           F: MVN Rd,Rs     ;not               Rd = NOT Rs
  5-3    Rs - Source Register       (R0..R7)
  2-0    Rd - Destination Register  (R0..R7)
</code></pre></div></div>
<p>ARM equivalent for NEG would be RSBS.</p>
<p>Return: Rd contains result (except TST,CMP,CMN),</p>
<p>Affected Flags:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  N,Z,C,V for  ADC,SBC,NEG,CMP,CMN
  N,Z,C   for  LSL,LSR,ASR,ROR (carry flag unchanged if zero shift amount)
  N,Z,C   for  MUL on ARMv4 and below: carry flag destroyed
  N,Z     for  MUL on ARMv5 and above: carry flag unchanged
  N,Z     for  AND,EOR,TST,ORR,BIC,MVN
</code></pre></div></div>
<p>Execution Time:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  1S      for  AND,EOR,ADC,SBC,TST,NEG,CMP,CMN,ORR,BIC,MVN
  1S+1I   for  LSL,LSR,ASR,ROR
  1S+mI   for  MUL on ARMv4 (m=1..4; depending on MSBs of incoming Rd value)
  1S+mI   for  MUL on ARMv5 (m=3; fucking slow, no matter of MSBs of Rd value)
</code></pre></div></div>
<h3 id=thumb5-hi-register-operationsbranch-exchange>THUMB.5: Hi register operations/branch exchange</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-10  Must be 010001b for this type of instructions
  9-8    Opcode (0-3)
           0: ADD Rd,Rs   ;add        Rd = Rd+Rs
           1: CMP Rd,Rs   ;compare  Void = Rd-Rs  ;CPSR affected
           2: MOV Rd,Rs   ;move       Rd = Rs
           2: NOP         ;nop        R8 = R8
           3: BX  Rs      ;jump       PC = Rs     ;may switch THUMB/ARM
           3: BLX Rs      ;call       PC = Rs     ;may switch THUMB/ARM (ARM9)
  7      MSBd - Destination Register most significant bit (or BL/BLX flag)
  6      MSBs - Source Register most significant bit
  5-3    Rs - Source Register        (together with MSBs: R0..R15)
  2-0    Rd - Destination Register   (together with MSBd: R0..R15)
</code></pre></div></div>
<p>Restrictions: For ADD/CMP/MOV, MSBs and/or MSBd must be set, ie. it is not
allowed that both are cleared.</p>
<p>When using R15 (PC) as operand, the value will be the address of the
instruction plus 4 (ie. $+4). Except for BX R15: CPU switches to ARM state, and
PC is auto-aligned as (($+4) AND NOT 2).</p>
<p>For BX, MSBs may be 0 or 1, MSBd must be zero, Rd is not used/zero.</p>
<p>For BLX, MSBs may be 0 or 1, MSBd must be set, Rd is not used/zero.</p>
<p>For BX/BLX, when Bit 0 of the value in Rs is zero:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Processor will be switched into ARM mode!
  If so, Bit 1 of Rs must be cleared (32bit word aligned).
  Thus, BX PC (switch to ARM) may be issued from word-aligned address
  only, the destination is PC+4 (ie. the following halfword is skipped).
</code></pre></div></div>
<p>BLX may not use R15. BLX saves the return address as LR=PC+3 (with thumb bit).</p>
<p>Using BLX R14 is possible (sets PC=Old_LR, and New_LR=retadr).</p>
<p>Assemblers/Disassemblers should use MOV R8,R8 as NOP (in THUMB mode).</p>
<p>Return: Only CMP affects CPSR condition flags!</p>
<p>Execution Time:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code> 1S     for ADD/MOV/CMP
 2S+1N  for ADD/MOV with Rd=R15, and for BX
</code></pre></div></div>
<h2 id=--thumb-opcodes-memory-loadstore-ldrstr><a name=thumbopcodesmemoryloadstoreldrstr></a> THUMB Opcodes: Memory Load/Store (LDR/STR)</h2>
<h3 id=thumb6-load-pc-relative-for-loading-immediates-from-literal-pool>THUMB.6: load PC-relative (for loading immediates from literal pool)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-11  Must be 01001b for this type of instructions
  N/A    Opcode (fixed)
           LDR Rd,[PC,#nn]      ;load 32bit    Rd = WORD[PC+nn]
  10-8   Rd - Destination Register   (R0..R7)
  7-0    nn - Unsigned offset        (0-1020 in steps of 4)
</code></pre></div></div>
<p>The value of PC will be interpreted as (($+4) AND NOT 2).</p>
<p>Return: No flags affected, data loaded into Rd.</p>
<p>Execution Time: 1S+1N+1I</p>
<h3 id=thumb7-loadstore-with-register-offset>THUMB.7: load/store with register offset</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-12  Must be 0101b for this type of instructions
  11-10  Opcode (0-3)
          0: STR  Rd,[Rb,Ro]   ;store 32bit data  WORD[Rb+Ro] = Rd
          1: STRB Rd,[Rb,Ro]   ;store  8bit data  BYTE[Rb+Ro] = Rd
          2: LDR  Rd,[Rb,Ro]   ;load  32bit data  Rd = WORD[Rb+Ro]
          3: LDRB Rd,[Rb,Ro]   ;load   8bit data  Rd = BYTE[Rb+Ro]
  9      Must be zero (0) for this type of instructions
  8-6    Ro - Offset Register              (R0..R7)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
</code></pre></div></div>
<p>Return: No flags affected, data loaded either into Rd or into memory.</p>
<p>Execution Time: 1S+1N+1I for LDR, or 2N for STR</p>
<h3 id=thumb8-loadstore-sign-extended-bytehalfword>THUMB.8: load/store sign-extended byte/halfword</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-12  Must be 0101b for this type of instructions
  11-10  Opcode (0-3)
          0: STRH Rd,[Rb,Ro]  ;store 16bit data          HALFWORD[Rb+Ro] = Rd
          1: LDSB Rd,[Rb,Ro]  ;load sign-extended 8bit   Rd = BYTE[Rb+Ro]
          2: LDRH Rd,[Rb,Ro]  ;load zero-extended 16bit  Rd = HALFWORD[Rb+Ro]
          3: LDSH Rd,[Rb,Ro]  ;load sign-extended 16bit  Rd = HALFWORD[Rb+Ro]
  9      Must be set (1) for this type of instructions
  8-6    Ro - Offset Register              (R0..R7)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
</code></pre></div></div>
<p>Return: No flags affected, data loaded either into Rd or into memory.</p>
<p>Execution Time: 1S+1N+1I for LDR, or 2N for STR</p>
<h3 id=thumb9-loadstore-with-immediate-offset>THUMB.9: load/store with immediate offset</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-13  Must be 011b for this type of instructions
  12-11  Opcode (0-3)
          0: STR  Rd,[Rb,#nn]  ;store 32bit data   WORD[Rb+nn] = Rd
          1: LDR  Rd,[Rb,#nn]  ;load  32bit data   Rd = WORD[Rb+nn]
          2: STRB Rd,[Rb,#nn]  ;store  8bit data   BYTE[Rb+nn] = Rd
          3: LDRB Rd,[Rb,#nn]  ;load   8bit data   Rd = BYTE[Rb+nn]
  10-6   nn - Unsigned Offset              (0-31 for BYTE, 0-124 for WORD)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
</code></pre></div></div>
<p>Return: No flags affected, data loaded either into Rd or into memory.</p>
<p>Execution Time: 1S+1N+1I for LDR, or 2N for STR</p>
<h3 id=thumb10-loadstore-halfword>THUMB.10: load/store halfword</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-12  Must be 1000b for this type of instructions
  11     Opcode (0-1)
          0: STRH Rd,[Rb,#nn]  ;store 16bit data   HALFWORD[Rb+nn] = Rd
          1: LDRH Rd,[Rb,#nn]  ;load  16bit data   Rd = HALFWORD[Rb+nn]
  10-6   nn - Unsigned Offset              (0-62, step 2)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
</code></pre></div></div>
<p>Return: No flags affected, data loaded either into Rd or into memory.</p>
<p>Execution Time: 1S+1N+1I for LDR, or 2N for STR</p>
<h3 id=thumb11-loadstore-sp-relative>THUMB.11: load/store SP-relative</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-12  Must be 1001b for this type of instructions
  11     Opcode (0-1)
          0: STR  Rd,[SP,#nn]  ;store 32bit data   WORD[SP+nn] = Rd
          1: LDR  Rd,[SP,#nn]  ;load  32bit data   Rd = WORD[SP+nn]
  10-8   Rd - Source/Destination Register  (R0..R7)
  7-0    nn - Unsigned Offset              (0-1020, step 4)
</code></pre></div></div>
<p>Return: No flags affected, data loaded either into Rd or into memory.</p>
<p>Execution Time: 1S+1N+1I for LDR, or 2N for STR</p>
<h2 id=--thumb-opcodes-memory-addressing-add-pcsp><a name=thumbopcodesmemoryaddressingaddpcsp></a> THUMB Opcodes: Memory Addressing (ADD PC/SP)</h2>
<h3 id=thumb12-get-relative-address>THUMB.12: get relative address</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-12  Must be 1010b for this type of instructions
  11     Opcode/Source Register (0-1)
          0: ADD  Rd,PC,#nn    ;Rd = (($+4) AND NOT 2) + nn
          1: ADD  Rd,SP,#nn    ;Rd = SP + nn
  10-8   Rd - Destination Register         (R0..R7)
  7-0    nn - Unsigned Offset              (0-1020, step 4)
</code></pre></div></div>
<p>Return: No flags affected, result in Rd.</p>
<p>Execution Time: 1S</p>
<h3 id=thumb13-add-offset-to-stack-pointer>THUMB.13: add offset to stack pointer</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-8   Must be 10110000b for this type of instructions
  7      Opcode/Sign
          0: ADD  SP,#nn       ;SP = SP + nn
          1: ADD  SP,#-nn      ;SP = SP - nn
  6-0    nn - Unsigned Offset    (0-508, step 4)
</code></pre></div></div>
<p>Return: No flags affected, SP adjusted.</p>
<p>Execution Time: 1S</p>
<h2 id=--thumb-opcodes-memory-multiple-loadstore-pushpop-and-ldmstm><a name=thumbopcodesmemorymultipleloadstorepushpopandldmstm></a> THUMB Opcodes: Memory Multiple Load/Store (PUSH/POP and LDM/STM)</h2>
<h3 id=thumb14-pushpop-registers>THUMB.14: push/pop registers</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-12  Must be 1011b for this type of instructions
  11     Opcode (0-1)
          0: PUSH {Rlist}{LR}   ;store in memory, decrements SP (R13)
          1: POP  {Rlist}{PC}   ;load from memory, increments SP (R13)
  10-9   Must be 10b for this type of instructions
  8      PC/LR Bit (0-1)
          0: No
          1: PUSH LR (R14), or POP PC (R15)
  7-0    Rlist - List of Registers (R7..R0)
</code></pre></div></div>
<p>In THUMB mode stack is always meant to be ‘full descending’, ie. PUSH is
equivalent to ‘STMFD/STMDB’ and POP to ‘LDMFD/LDMIA’ in ARM mode.</p>
<p>Examples:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code> PUSH {R0-R3}     ;push R0,R1,R2,R3
 PUSH {R0,R2,LR}  ;push R0,R2,LR
 POP  {R4,R7}     ;pop R4,R7
 POP  {R2-R4,PC}  ;pop R2,R3,R4,PC
</code></pre></div></div>
<p>Note: When calling to a sub-routine, the return address is stored in LR
register, when calling further sub-routines, PUSH {LR} must be used to save
higher return address on stack. If so, POP {PC} can be later used to return
from the sub-routine.</p>
<p>POP {PC} ignores the least significant bit of the return address (processor
remains in thumb state even if bit0 was cleared), when intending to return with
optional mode switch, use a POP/BX combination (eg. POP {R3} / BX R3).</p>
<p>ARM9: POP {PC} copies the LSB to thumb bit (switches to ARM if bit0=0).</p>
<p>Return: No flags affected, SP adjusted, registers loaded/stored.</p>
<p>Execution Time: nS+1N+1I (POP), (n+1)S+2N+1I (POP PC), or (n-1)S+2N (PUSH).</p>
<h3 id=thumb15-multiple-loadstore>THUMB.15: multiple load/store</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-12  Must be 1100b for this type of instructions
  11     Opcode (0-1)
          0: STMIA Rb!,{Rlist}   ;store in memory, increments Rb
          1: LDMIA Rb!,{Rlist}   ;load from memory, increments Rb
  10-8   Rb - Base register (modified) (R0-R7)
  7-0    Rlist - List of Registers     (R7..R0)
</code></pre></div></div>
<p>Both STM and LDM are incrementing the Base Register.</p>
<p>The lowest register in the list (ie. R0, if it’s in the list) is stored/loaded
at the lowest memory address.</p>
<p>Examples:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code> STMIA R7!,{R0-R2}  ;store R0,R1,R2
 LDMIA R0!,{R1,R5}  ;store R1,R5
</code></pre></div></div>
<p>Return: No flags affected, Rb adjusted, registers loaded/stored.</p>
<p>Execution Time: nS+1N+1I for LDM, or (n-1)S+2N for STM.</p>
<h3 id=strange-effects-on-invalid-rlists-1>Strange Effects on Invalid Rlist’s</h3>
<p>Empty Rlist: R15 loaded/stored (ARMv4 only), and Rb=Rb+40h (ARMv4-v5).</p>
<p>Writeback with Rb included in Rlist: Store OLD base if Rb is FIRST entry in
Rlist, otherwise store NEW base (STM/ARMv4), always store OLD base (STM/ARMv5),
no writeback (LDM/ARMv4/ARMv5; at this point, THUMB opcodes work different than
ARM opcodes).</p>
<h2 id=--thumb-opcodes-jumps-and-calls><a name=thumbopcodesjumpsandcalls></a> THUMB Opcodes: Jumps and Calls</h2>
<h3 id=thumb16-conditional-branch>THUMB.16: conditional branch</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-12  Must be 1101b for this type of instructions
  11-8   Opcode/Condition (0-Fh)
          0: BEQ label        ;Z=1         ;equal (zero) (same)
          1: BNE label        ;Z=0         ;not equal (nonzero) (not same)
          2: BCS/BHS label    ;C=1         ;unsigned higher or same (carry set)
          3: BCC/BLO label    ;C=0         ;unsigned lower (carry cleared)
          4: BMI label        ;N=1         ;negative (minus)
          5: BPL label        ;N=0         ;positive or zero (plus)
          6: BVS label        ;V=1         ;overflow (V set)
          7: BVC label        ;V=0         ;no overflow (V cleared)
          8: BHI label        ;C=1 and Z=0 ;unsigned higher
          9: BLS label        ;C=0 or Z=1  ;unsigned lower or same
          A: BGE label        ;N=V         ;greater or equal
          B: BLT label        ;N&lt;&gt;V        ;less than
          C: BGT label        ;Z=0 and N=V ;greater than
          D: BLE label        ;Z=1 or N&lt;&gt;V ;less or equal
          E: Undefined, should not be used
          F: Reserved for SWI instruction (see SWI opcode)
  7-0    Signed Offset, step 2 ($+4-256..$+4+254)
</code></pre></div></div>
<p>Destination address must by halfword aligned (ie. bit 0 cleared)</p>
<p>Return: No flags affected, PC adjusted if condition true</p>
<p>Execution Time:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  2S+1N   if condition true (jump executed)
  1S      if condition false
</code></pre></div></div>
<h3 id=bx-and-addmov-pc>BX and ADD/MOV PC</h3>
<p>See also THUMB.5: BX Rs, and ADD/MOV PC,Rs.</p>
<h3 id=thumb18-unconditional-branch>THUMB.18: unconditional branch</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-11  Must be 11100b for this type of instructions
  N/A    Opcode (fixed)
          B label   ;branch (jump)
  10-0   Signed Offset, step 2 ($+4-2048..$+4+2046)
</code></pre></div></div>
<p>Return: No flags affected, PC adjusted.</p>
<p>Execution Time: 2S+1N</p>
<h3 id=thumb19-long-branch-with-link>THUMB.19: long branch with link</h3>
<p>This may be used to call (or jump) to a subroutine, return address is saved in
LR (R14).</p>
<p>Unlike all other THUMB mode instructions, this instruction occupies 32bit of
memory which are split into two 16bit THUMB opcodes.</p>
<ul>
 <li>First Instruction - LR = PC+4+(nn SHL 12)
 <ul>
 <li>15-11 Must be 11110b for BL/BLX type of instructions</li>
 <li>10-0 nn - Upper 11 bits of Target Address</li>
 </ul>
 </li>
 <li>Second Instruction - PC = LR + (nn SHL 1), and LR = PC+2 OR 1 (and BLX: T=0)
 <ul>
 <li>15-11 Opcode
 - 11111b: BL label ;branch long with link
 - 11101b: BLX label ;branch long with link switch to ARM mode (ARM9)</li>
 <li>10-0 nn - Lower 11 bits of Target Address (BLX: Bit0 Must be zero)</li>
 </ul>
 </li>
</ul>
<p>The destination address range is (PC+4)-400000h..+3FFFFEh, ie. PC+/-4M.</p>
<p>Target must be halfword-aligned. As Bit 0 in LR is set, it may be used to
return by a BX LR instruction (keeping CPU in THUMB mode).</p>
<p>Return: No flags affected, PC adjusted, return address in LR.</p>
<p>Execution Time: 3S+1N (first opcode 1S, second opcode 2S+1N).</p>
<p>Note: Exceptions may or may not occur between first and second opcode, this is
“implementation defined” (unknown how this is implemented in GBA and NDS).</p>
<p>Using only the 2nd half of BL as “BL LR+imm” is possible (for example, Mario
Golf Advance Tour for GBA uses opcode F800h as “BL LR+0”).</p>
<h3 id=thumb17-software-interrupt-and-breakpoint>THUMB.17: software interrupt and breakpoint</h3>
<p>SWI supposed for calls to the operating system - Enter Supervisor mode (SVC) in
ARM state. BKPT intended for debugging - enters Abort mode in ARM state via
Prefetch Abort vector.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  15-8   Opcode
          11011111b: SWI nn   ;software interrupt
          10111110b: BKPT nn  ;software breakpoint (ARMv5 and up)
  7-0    nn - Comment Field, ignored by processor (8bit value) (0-255)
</code></pre></div></div>
<p>Execution Time: 2S+1N</p>
<p>The exception handler may interprete the SWI Comment Field by examining the
lower 8bit of the 16bit opcode opcode at [R14_svc-2].</p>
<p>If your are also using SWI’s from inside of ARM mode, then the SWI handler must
examine the T Bit SPSR_svc in order to determine whether it’s been a ARM SWI -
and if so, examine the lower 24bit of the 32bit opcode opcode at [R14_svc-4].</p>
<p>For Returning from SWI use “MOVS PC,R14”, that instruction does restore both PC
and CPSR, ie. PC=R14_svc, and CPSR=SPSR_svc, and (as called from THUMB mode),
it’ll also restore THUMB mode.</p>
<p>Nesting SWIs: SPSR_svc and R14_svc should be saved on stack before either
invoking nested SWIs, or (if the IRQ handler uses SWIs) before enabling IRQs.</p>
<p>Execution SWI/BKPT:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  R14_svc=PC+2     R14_abt=PC+4   ;save return address
  SPSR_svc=CPSR    SPSR_abt=CPSR  ;save CPSR flags
  CPSR=&lt;changed&gt;   CPSR=&lt;changed&gt; ;Enter svc/abt, ARM state, IRQs disabled
  PC=VVVV0008h     PC=VVVV000Ch   ;jump to SWI/PrefetchAbort vector address
</code></pre></div></div>
<h2 id=--arm-pseudo-instructions-and-directives><a name=armpseudoinstructionsanddirectives></a> ARM Pseudo Instructions and Directives</h2>
<h3 id=arm-pseudo-instructions>ARM Pseudo Instructions</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  nop              mov r0,r0
  ldr Rd,=Imm      ldr Rd,[r15,disp] ;use .pool as parameter field
  add Rd,=addr     add/sub Rd,r15,disp
  adr Rd,addr      add/sub Rd,r15,disp
  adrl Rd,addr     two add/sub opcodes with disp=xx00h+00yyh
  mov Rd,Imm       mvn Rd,NOT Imm    ;or vice-versa
  and Rd,Rn,Imm    bic Rd,Rn,NOT Imm ;or vice-versa
  cmp Rd,Rn,Imm    cmn Rd,Rn,-Imm    ;or vice-versa
  add Rd,Rn,Imm    sub Rd,Rn,-Imm    ;or vice-versa
</code></pre></div></div>
<p>All above opcodes may be made conditional by specifying a {cond} field.</p>
<h3 id=thumb-pseudo-instructions>THUMB Pseudo Instructions</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  nop              mov r8,r8
  ldr Rd,=Imm      ldr Rd,[r15,disp] ;use .pool as parameter field
  add Rd,=addr     add Rd,r15,disp
  adr Rd,addr      add Rd,r15,disp
  mov Rd,Rs        add Rd,Rs,0       ;with Rd,Rs in range r0-r7 each
</code></pre></div></div>
<h3 id=a22i-directives>A22i Directives</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  org  adr     assume following code from this address on
  .gba         indicate GBA program
  .nds         indicate NDS program
  .dsi         indicate DSi program
  .fix         fix GBA/NDS/DSi header checksum
  .ereader_create_bmp      create GBA e-Reader dotcode .BMP file(s) (bitmaps)
  .ereader_create_raw      create GBA e-Reader dotcode .RAW file (useless)
  .ereader_create_bin      create GBA e-Reader dotcode .BIN file (smallest)
  .ereader_japan_plus      japanese/plus     (default is non-japanese)
  .ereader_japan_original  japanese/original (with Z80-stub for GBA-code)
  .title 'Txt' defines a title (used for e-Reader dotcodes)
  .teak        select TeakLiteII instruction set (for DSi DSP)
  .xtensa      select Xtensa instruction set (for DSi Atheros Wifi)
  .norewrite   do not delete existing output file (keep following data in file)
  .data?       following defines RAM data structure (assembled to nowhere)
  .code        following is normal ROM code/data (assembled to ROM image)
  .include     includes specified source code file (no nesting/error handling)
  .import      imports specified binary file (optional parameters: ,begin,len)
  .radix nn    changes default numeric format (nn=2,8,10,16 = bin/oct/dec/hex)
  .errif expr  generates an error message if expression is nonzero
  .if expr     assembles following code only if expression is nonzero
  .else        invert previous .if condition
  .endif       terminate .if/.ifdef/.ifndef
  .ifdef sym   assemble following only if symbol is defined
  .ifndef sym  assemble following only if symbol is not defined
  .align nn    aligns to an address divisible-by-nn, inserts 00's
  .msg         defines a no$gba debugmessage string, such like .msg 'Init Okay'
  .brk         defines a no$gba source code break opcode
  l equ n      l=n
  l:   [cmd]   l=$   (global label)
  @@l: [cmd]   @@l=$ (local label, all locals are reset at next global label)
  end          end of source code
  db ...       define 8bit data (bytes)
  dw ...       define 16bit data (halfwords)
  dd ...       define 32bit data (words)
  defs nn      define nn bytes space (zero-filled)
  ;...         defines a comment (ignored by the assembler)
  //           alias for CRLF, eg. allows &lt;db 'Text',0 // dw addr&gt; in one line
</code></pre></div></div>
<h3 id=a22i-alias-directives-for-compatibility-with-other-assemblers>A22i Alias Directives (for compatibility with other assemblers)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  align        .align 4          code16    .thumb
  align nn     .align nn         .code 16  .thumb
  % nn         defs nn           code32    .arm
  .space nn    defs nn           .code 32  .arm
  ..ds nn      defs nn           ltorg     .pool
  x=n          x equ n           .ltorg    .pool
  .equ x,n     x equ n           ..ltorg   .pool
  .define x n  x equ n           dcb       db (8bit data)
  incbin       .import           defb      db (8bit data)
  @@@...       ;comment          .byte     db (8bit data)
  @ ...        ;comment          .ascii    db (8bit string)
  @*...        ;comment          dcw       dw (16bit data)
  @...         ;comment          defw      dw (16bit data)
  .text        .code             .hword    dw (16bit data)
  .bss         .data?            dcd       dd (32bit data)
  .global      (ignored)         defd      dd (32bit data)
  .extern      (ignored)         .long     dd (32bit data)
  .thumb_func  (ignored)         .word     dw/dd, don't use
  #directive   .directive        .end      end
  .fill nn,1,0 defs nn
</code></pre></div></div>
<h3 id=alias-conditions-opcodes-operands>Alias Conditions, Opcodes, Operands</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  hs   cs   ;condition higher or same = carry set
  lo   cc   ;condition lower = carry cleared
  asl  lsl  ;arithmetic shift left = logical shift left
</code></pre></div></div>
<h3 id=a22i-numeric-formats--dialects>A22i Numeric Formats &amp; Dialects</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Type          Normal       Alias
  Decimal       85           #85  &amp;d85
  Hexadecimal   55h          #55h  0x55  #0x55  $55  &amp;h55
  Octal         125o         0o125  &amp;o125
  Ascii         'U'          "U"
  Binary        01010101b    %01010101  0b01010101  &amp;b01010101
  Roman         &amp;rLXXXV      (very useful for arrays of kings and chapters)
</code></pre></div></div>
<p>Note: The default numeric format can be changed by the .radix directive
(usually 10=decimal). For example, with radix 16, values like “85” and “0101b”
are treated as hexadecimal numbers (in that case, decimal and binary numbers
can be still defined with prefixes &amp;d and &amp;b).</p>
<h3 id=a22i-numeric-operators-priority>A22i Numeric Operators Priority</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Prio  Operator           Aliases
  8     (,) brackets
  7     +,- sign
  6     *,/,MOD,SHL,SHR    MUL,DIV,&lt;&lt;,&gt;&gt;
  5     +,- operation
  4     EQ,GE,GT,LE,LT,NE  =,&gt;=,&gt;,&lt;=,&lt;,&lt;&gt;,==,!=
  3     NOT
  2     AND
  1     OR,XOR             EOR
</code></pre></div></div>
<p>Operators of same priority are processed from left to right.</p>
<p>Boolean operators (priority 4) return 1=TRUE, 0=FALSE.</p>
<h3 id=a22i-nocash-syntax>A22i Nocash Syntax</h3>
<p>Even though A22i does recognize the official ARM syntax, it’s also allowing to
use friendly code:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  mov   r0,0ffh         ;no C64-style "#", and no C-style "0x" required
  stmia [r7]!,r0,r4-r5  ;square [base] brackets, no fancy {rlist} brackets
  mov   r0,cpsr         ;no confusing MSR and MRS (whatever which is which)
  mov   r0,p0,0,c0,c0,0 ;no confusing MCR and MRC (whatever which is which)
  ldr   r0,[score]      ;allows to use clean brackets for relative addresses
  push  rlist           ;alias for stmfd [r13]!,rlist (and same for pop/ldmfd)
  label:                ;label definitions recommended to use ":" colons
</code></pre></div></div>
<p>[A22i is the no$gba debug version’s built-in source code assembler.]</p>
<h2 id=--arm-cpu-instruction-cycle-times><a name=armcpuinstructioncycletimes></a> ARM CPU Instruction Cycle Times</h2>
<p>Instruction Cycle Summary</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Instruction      Cycles      Additional
  ---------------------------------------------------------------------
  ALU              1S          +1S+1N if R15 loaded, +1I if SHIFT(Rs)
  MSR,MRS          1S
  LDR              1S+1N+1I    +1S+1N if R15 loaded
  STR              2N
  LDM              nS+1N+1I    +1S+1N if R15 loaded
  STM              (n-1)S+2N
  SWP              1S+2N+1I
  BL (THUMB)       3S+1N
  B,BL             2S+1N
  SWI,trap         2S+1N
  MUL              1S+ml
  MLA              1S+(m+1)I
  MULL             1S+(m+1)I
  MLAL             1S+(m+2)I
  CDP              1S+bI
  LDC,STC          (n-1)S+2N+bI
  MCR              1N+bI+1C
  MRC              1S+(b+1)I+1C
  {cond} false     1S
</code></pre></div></div>
<p>ARM9:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Q{D}ADD/SUB      1S+Interlock.
  CLZ              1S.
  LDR              1S+1N+1L
  LDRB,LDRH,LDRmis 1S+1N+2L
  LDR PC ...
  STR              1S+1N        (not 2N, and both in parallel)
</code></pre></div></div>
<p>Execution Time: 1S+Interlock (SMULxy,SMLAxy,SMULWx,SMLAWx)</p>
<p>Execution Time: 1S+1I+Interlock (SMLALxy)</p>
<p>Whereas,</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  n = number of words transferred
  b = number of cycles spent in coprocessor busy-wait loop
  m = depends on most significant byte(s) of multiplier operand
</code></pre></div></div>
<p>Above ‘trap’ is meant to be the execution time for exceptions. And ‘{cond}
false’ is meant to be the execution time for conditional instructions which
haven’t been actually executed because the condition has been false.</p>
<p>The separate meaning of the N,S,I,C cycles is:</p>
<h3 id=n---non-sequential-cycle>N - Non-sequential cycle</h3>
<p>Requests a transfer to/from an address which is NOT related to the address used
in the previous cycle. (Called 1st Access in GBA language).</p>
<p>The execution time for 1N is 1 clock cycle (plus non-sequential access
waitstates).</p>
<h3 id=s---sequential-cycle>S - Sequential cycle</h3>
<p>Requests a transfer to/from an address which is located directly after the
address used in the previous cycle. Ie. for 16bit or 32bit accesses at
incrementing addresses, the first access is Non-sequential, the following
accesses are sequential. (Called 2nd Access in GBA language).</p>
<p>The execution time for 1S is 1 clock cycle (plus sequential access waitstates).</p>
<h3 id=i---internal-cycle>I - Internal Cycle</h3>
<p>CPU is just too busy, not even requesting a memory transfer for now.</p>
<p>The execution time for 1I is 1 clock cycle (without any waitstates).</p>
<h3 id=c---coprocessor-cycle>C - Coprocessor Cycle</h3>
<p>The CPU uses the data bus to communicate with the coprocessor (if any), but no
memory transfers are requested.</p>
<h3 id=memory-waitstates>Memory Waitstates</h3>
<p>Ideally, memory may be accessed free of waitstates (1N and 1S are then equal to
1 clock cycle each). However, a memory system may generate waitstates for
several reasons: The memory may be just too slow. Memory is currently accessed
by DMA, eg. sound, video, memory transfers, etc. Or when data is squeezed
through a 16bit data bus (in that special case, 32bit access may have more
waitstates than 8bit and 16bit accesses). Also, the memory system may separate
between S and N cycles (if so, S cycles would be typically faster than N
cycles).</p>
<h3 id=memory-waitstates-for-different-memory-areas>Memory Waitstates for Different Memory Areas</h3>
<p>Different memory areas (eg. ROM and RAM) may have different waitstates. When
executing code in one area which accesses data in another area, then the S+N
cycles must be split into code and data accesses: 1N is used for data access,
plus (n-1)S for LDM/STM, the remaining S+N are code access. If an instruction
jumps to a different memory area, then all code cycles for that opcode are
having waitstate characteristics of the NEW memory area (except Thumb BL which
still executes 1S in OLD area).</p>
<h2 id=--arm-cpu-versions><a name=armcpuversions></a> ARM CPU Versions</h2>
<h3 id=version-numbers>Version Numbers</h3>
<p>ARM CPUs are distributed by name ARM#, and are described as ARMv# in
specifications, whereas “#” is NOT the same than “v#”, for example, ARM7TDMI is
ARMv4TM. That is so confusing, that ARM didn’t even attempt to clarify the
relationship between the various “#” and “v#” values.</p>
<h3 id=version-variants>Version Variants</h3>
<p>Suffixes like “M” (long multiply), “T” (Thumb support), “E” (Enhanced DSP)
indicate presence of special features, additionally to the standard instruction
set of a given version, or, when preceded by an “x”, indicate the absence of
that features.</p>
<h3 id=armv1-aka-arm1>ARMv1 aka ARM1</h3>
<p>Some sort of a beta version, according to ARM never been used in any commercial
products.</p>
<h3 id=armv2-and-up>ARMv2 and up</h3>
<p>MUL,MLA</p>
<p>CDP,LDC,MCR,MRC,STC</p>
<p>SWP/SWPB (ARMv2a and up only)</p>
<p>Two new FIQ registers</p>
<h3 id=armv3-and-up>ARMv3 and up</h3>
<p>MRS,MSR opcodes (instead CMP/CMN/TST/TEQ{P} opcodes)</p>
<p>CPSR,SPSR registers (instead PSR bits in R15)</p>
<p>Removed never condition, cond=NV no longer valid</p>
<p>32bit addressing (instead 26bit addressing in older versions)</p>
<p>26bit addressing backwards comptibility mode (except v3G)</p>
<p>Abt and Und modes (instead handling aborts/undefined in Svc mode)</p>
<p>SMLAL,SMULL,UMLAL,UMULL (optionally, INCLUDED in v3M, EXCLUDED in v4xM/v5xM)</p>
<h3 id=armv4-aka-arm7-and-up>ARMv4 aka ARM7 and up</h3>
<p>LDRH,LDRSB,LDRSH,STRH</p>
<p>Sys mode (privileged user mode)</p>
<p>BX (only ARMv4T, and any ARMv5 or ARMv5T and up)</p>
<p>THUMB code (only T variants, ie. ARMv4T, ARMv5T)</p>
<h3 id=armv5-aka-arm9-and-up>ARMv5 aka ARM9 and up</h3>
<p>BKPT,BLX,CLZ (BKPT,BLX also in THUMB mode)</p>
<p>LDM/LDR/POP PC with mode switch (POP PC also in THUMB mode)</p>
<p>CDP2,LDC2,MCR2,MRC2,STC2 (new coprocessor opcodes)</p>
<p>C-flag unchanged by MUL (instead undefined flag value)</p>
<p>changed instruction cycle timings / interlock ??? or not ???</p>
<p>QADD,QDADD,QDSUB,QSUB opcodes, CPSR.Q flag (v5TE and V5TExP only)</p>
<p>SMLAxy,SMLALxy,SMLAWy,SMULxy,SMULWy (v5TE and V5TExP only)</p>
<p>LDRD,STRD,PLD,MCRR,MRRC (v5TE only, not v5, not v5TExP)</p>
<h3 id=armv6>ARMv6</h3>
<p>No public specifications available.</p>
<h3 id=a-milestone-in-computer-history>A Milestone in Computer History</h3>
<p>Original ARMv2 has been used in the relative rare and expensive Archimedes
deluxe home computers in the late eighties, the Archimedes has caught a lot of
attention, particularly for being the first home computer that used a BIOS
being programmed in BASIC language - which has been a absolutely revolutionary
decadency at that time.</p>
<p>Inspired, programmers all over the world have successfully developed even
slower and much more inefficient programming languages, which are nowadays
consequently used by nearly all ARM programmers, and by most non-ARM
programmers as well.</p>
<h2 id=--arm-cpu-data-sheet><a name=armcpudatasheet></a> ARM CPU Data Sheet</h2>
<p>This present document is an attempt to supply a brief ARM7TDMI reference,
hopefully including all information which is relevant for programmers.</p>
<p>Some details that I have treated as meaningless for GBA programming aren’t
included - such like Big Endian format, and Virtual Memory data aborts, and
most of the chapters listed below.</p>
<p>Have a look at the complete data sheet (URL see below) for more detailed
verbose information about ARM7TDMI instructions. That document also includes:</p>
<ul>
 <li>Signal Description</li>
</ul>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Pins of the original CPU, probably other for GBA.
</code></pre></div></div>
<ul>
 <li>Memory Interface</li>
</ul>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Optional virtual memory circuits, etc. not for GBA.
</code></pre></div></div>
<ul>
 <li>Coprocessor Interface</li>
</ul>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  As far as I know, none such in GBA.
</code></pre></div></div>
<ul>
 <li>Debug Interface</li>
</ul>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  For external hardware-based debugging.
</code></pre></div></div>
<ul>
 <li>ICEBreaker Module</li>
</ul>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  For external hardware-based debugging also.
</code></pre></div></div>
<ul>
 <li>Instruction Cycle Operations</li>
</ul>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Detailed: What happens during each cycle of each instruction.
</code></pre></div></div>
<ul>
 <li>
 <p>DC Parameters (Power supply)</p>
 </li>
 <li>
 <p>AC Parameters (Signal timings)</p>
 </li>
</ul>
<p>The official ARM7TDMI data sheet can be downloaded from ARMs webpage,</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  http://www.arm.com/Documentation/UserMans/PDF/ARM7TDMI.html
</code></pre></div></div>
<p>Be prepared for bloated PDF Format, approx 1.3 MB, about 200 pages.</p>
<h2 id=--bios-functions><a name=biosfunctions></a> BIOS Functions</h2>
<p>The BIOS includes several System Call Functions which can be accessed by SWI
instructions. Incoming parameters are usually passed through registers
R0,R1,R2,R3. Outgoing registers R0,R1,R3 are typically containing either
garbage, or return value(s). All other registers (R2,R4-R14) are kept
unchanged.</p>
<h3 id=caution>Caution</h3>
<p>When invoking SWIs from inside of ARM state specify SWI NN*10000h, instead of
SWI NN as in THUMB state.</p>
<h3 id=overview-4>Overview</h3>
<ul>
 <li><a href=#biosfunctionsummary>BIOS Function Summary</a></li>
 <li><a href=#biosdifferencesbetweengbaandndsfunctions>BIOS Differences between GBA and NDS functions</a></li>
</ul>
<h3 id=all-functions-described>All Functions Described</h3>
<ul>
 <li><a href=#biosarithmeticfunctions>BIOS Arithmetic Functions</a></li>
 <li><a href=#biosrotationscalingfunctions>BIOS Rotation/Scaling Functions</a></li>
 <li><a href=#biosdecompressionfunctions>BIOS Decompression Functions</a></li>
 <li><a href=#biosmemorycopy>BIOS Memory Copy</a></li>
 <li><a href=#bioshaltfunctions>BIOS Halt Functions</a></li>
 <li><a href=#biosresetfunctions>BIOS Reset Functions</a></li>
 <li><a href=#biosmiscfunctions>BIOS Misc Functions</a></li>
 <li><a href=#biosmultibootsinglegamepak>BIOS Multi Boot (Single Game Pak)</a></li>
 <li><a href=#biossoundfunctions>BIOS Sound Functions</a></li>
 <li><a href=#biossha1functionsdsionly>BIOS SHA1 Functions (DSi only)</a></li>
 <li><a href=#biosrsafunctionsdsionly>BIOS RSA Functions (DSi only)</a></li>
</ul>
<h3 id=how-bios-processes-swis>How BIOS Processes SWIs</h3>
<p>SWIs can be called from both within THUMB and ARM mode. In ARM mode, only the
upper 8bit of the 24bit comment field are interpreted.</p>
<p>Each time when calling a BIOS function 4 words (SPSR, R11, R12, R14) are saved
on Supervisor stack (_svc). Once it has saved that data, the SWI handler
switches into System mode, so that all further stack operations are using user
stack.</p>
<p>In some cases the BIOS may allow interrupts to be executed from inside of the
SWI procedure. If so, and if the interrupt handler calls further SWIs, then
care should be taken that the Supervisor Stack does not overflow.</p>
<h2 id=--bios-function-summary><a name=biosfunctionsummary></a> BIOS Function Summary</h2>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  GBA  NDS7 NDS9 DSi7 DSi9 Basic Functions
  00h  00h  00h  -    -    SoftReset
  01h  -    -    -    -    RegisterRamReset
  02h  06h  06h  06h  06h  Halt
  03h  07h  -    07h  -    Stop/Sleep
  04h  04h  04h  04h  04h  IntrWait       ;DSi7/DSi9: both bugged?
  05h  05h  05h  05h  05h  VBlankIntrWait ;DSi7/DSi9: both bugged?
  06h  09h  09h  09h  09h  Div
  07h  -    -    -    -    DivArm
  08h  0Dh  0Dh  0Dh  0Dh  Sqrt
  09h  -    -    -    -    ArcTan
  0Ah  -    -    -    -    ArcTan2
  0Bh  0Bh  0Bh  0Bh  0Bh  CpuSet
  0Ch  0Ch  0Ch  0Ch  0Ch  CpuFastSet
  0Dh  -    -    -    -    GetBiosChecksum
  0Eh  -    -    -    -    BgAffineSet
  0Fh  -    -    -    -    ObjAffineSet
  GBA  NDS7 NDS9 DSi7 DSi9 Decompression Functions
  10h  10h  10h  10h  10h  BitUnPack
  11h  11h  11h  11h  11h  LZ77UnCompReadNormalWrite8bit   ;"Wram"
  12h  -    -    -    -    LZ77UnCompReadNormalWrite16bit  ;"Vram"
  -    -    -    01h  01h  LZ77UnCompReadByCallbackWrite8bit
  -    12h  12h  02h  02h  LZ77UnCompReadByCallbackWrite16bit
  -    -    -    19h  19h  LZ77UnCompReadByCallbackWrite16bit (same as above)
  13h  -    -    -    -    HuffUnCompReadNormal
  -    13h  13h  13h  13h  HuffUnCompReadByCallback
  14h  14h  14h  14h  14h  RLUnCompReadNormalWrite8bit     ;"Wram"
  15h  -    -    -    -    RLUnCompReadNormalWrite16bit    ;"Vram"
  -    15h  15h  15h  15h  RLUnCompReadByCallbackWrite16bit
  16h  -    16h  -    16h  Diff8bitUnFilterWrite8bit       ;"Wram"
  17h  -    -    -    -    Diff8bitUnFilterWrite16bit      ;"Vram"
  18h  -    18h  -    18h  Diff16bitUnFilter
  GBA  NDS7 NDS9 DSi7 DSi9 Sound (and Multiboot/HardReset/CustomHalt)
  19h  08h  -    08h  -    SoundBias
  1Ah  -    -    -    -    SoundDriverInit
  1Bh  -    -    -    -    SoundDriverMode
  1Ch  -    -    -    -    SoundDriverMain
  1Dh  -    -    -    -    SoundDriverVSync
  1Eh  -    -    -    -    SoundChannelClear
  1Fh  -    -    -    -    MidiKey2Freq
  20h  -    -    -    -    SoundWhatever0
  21h  -    -    -    -    SoundWhatever1
  22h  -    -    -    -    SoundWhatever2
  23h  -    -    -    -    SoundWhatever3
  24h  -    -    -    -    SoundWhatever4
  25h  -    -    -    -    MultiBoot
  26h  -    -    -    -    HardReset
  27h  1Fh  -    1Fh  -    CustomHalt
  28h  -    -    -    -    SoundDriverVSyncOff
  29h  -    -    -    -    SoundDriverVSyncOn
  2Ah  -    -    -    -    SoundGetJumpList
  GBA  NDS7 NDS9 DSi7 DSi9 New NDS Functions
  -    03h  03h  03h  03h  WaitByLoop
  -    0Eh  0Eh  0Eh  0Eh  GetCRC16
  -    0Fh  0Fh  -    -    IsDebugger
  -    1Ah  -    1Ah  -    GetSineTable
  -    1Bh  -    1Bh  -    GetPitchTable (DSi7: bugged)
  -    1Ch  -    1Ch  -    GetVolumeTable
  -    1Dh  -    1Dh  -    GetBootProcs (DSi7: only 1 proc)
  -    -    1Fh  -    1Fh  CustomPost
  GBA  NDS7 NDS9 DSi7 DSi9 New DSi Functions (RSA/SHA1)
  -    -    -    20h  20h  RSA_Init_crypto_heap
  -    -    -    21h  21h  RSA_Decrypt
  -    -    -    22h  22h  RSA_Decrypt_Unpad
  -    -    -    23h  23h  RSA_Decrypt_Unpad_OpenPGP_SHA1
  -    -    -    24h  24h  SHA1_Init
  -    -    -    25h  25h  SHA1_Update
  -    -    -    26h  26h  SHA1_Finish
  -    -    -    27h  27h  SHA1_Init_update_fin
  -    -    -    28h  28h  SHA1_Compare_20_bytes
  -    -    -    29h  29h  SHA1_Random_maybe
  GBA  NDS7 NDS9 DSi7 DSi9 Invalid Functions
  2Bh+ 20h+ 20h+ -    -    Crash (SWI xxh..FFh do jump to garbage addresses)
  -    xxh  xxh  -    -    Jump to 0   (on any SWI numbers not listed above)
  -    -    -    12h  12h  No function (ignored)
  -    -    -    2Bh  2Bh  No function (ignored)
  -    -    -    40h+ 40h+ Mirror      (SWI 40h..FFh mirror to 00h..3Fh)
  -    -    -    xxh  xxh  Hang        (on any SWI numbers not listed above)
</code></pre></div></div>
<p>Invalid NDS functions: NDS7 SWI 01h, 02h, 0Ah, 16h-19h, 1Eh, and NDS9 SWI 01h,
02h, 07h, 08h, 0Ah, 17h, 19h-1Eh will jump to zero (ie. to the NDS7 reset
vector, or to NDS9 unused (usually PU-locked ITCM) memory, which will be both
redirected to the debug handler, if any).</p>
<p>Invalid DSi functions: DSi9 SWI 00h, 07h-08h, 0Ah, 0Fh, 17h, 1Ah-1Eh, 2Ah,
2Ch-3Fh do hang in endless loop.</p>
<h2 id=--bios-differences-between-gba-and-nds-functions><a name=biosdifferencesbetweengbaandndsfunctions></a> BIOS Differences between GBA and NDS functions</h2>
<h3 id=differences-between-gba-and-nds-bios-functions>Differences between GBA and NDS BIOS functions</h3>
<ul>
 <li> <p>SoftReset uses different addresses</p> </li>
 <li> <p>SWI numbers for Halt, Stop/Sleep, Div, Sqrt have changed</p> </li>
 <li> <p>Halt destroys r0 on NDS9, IntrWait bugged on NDS9</p> </li>
 <li> <p>CpuFastSet allows 4-byte blocks (nice), but…</p> </li>
 <li> <p>CpuFastSet works very SLOW because of a programming bug (uncool)</p> </li>
 <li> <p>Some of the decompression functions are now using callbacks</p> </li>
 <li> <p>SoundBias uses new delay parameter</p> </li>
</ul>
<p>And, a number of GBA functions have been removed, and some new NDS functions
have been added, see:</p>
<ul>
 <li><a href=#biosfunctionsummary>BIOS Function Summary</a></li>
</ul>
<h2 id=--bios-arithmetic-functions><a name=biosarithmeticfunctions></a> BIOS Arithmetic Functions</h2>
<p>Div</p>
<p>DivArm</p>
<p>Sqrt</p>
<p>ArcTan</p>
<p>ArcTan2</p>
<h3 id=swi-06h-gba-or-swi-09h-nds7nds9dsi7dsi9---div>SWI 06h (GBA) or SWI 09h (NDS7/NDS9/DSi7/DSi9) - Div</h3>
<p>Signed Division, r0/r1.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  signed 32bit Number
  r1  signed 32bit Denom
</code></pre></div></div>
<p>Return:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Number DIV Denom ;signed
  r1  Number MOD Denom ;signed
  r3  ABS (Number DIV Denom) ;unsigned
</code></pre></div></div>
<p>For example, incoming -1234, 10 should return -123, -4, +123.</p>
<p>The function usually gets caught in an endless loop upon division by zero.</p>
<p>Note: The NDS9 and DSi9 additionally support hardware division, by math
coprocessor, accessed via I/O Ports, however, the SWI function is a raw
software division.</p>
<h3 id=swi-07h-gba---divarm>SWI 07h (GBA) - DivArm</h3>
<p>Same as above (SWI 06h Div), but incoming parameters are exchanged, r1/r0
(r0=Denom, r1=number). For compatibility with ARM’s library. Slightly slower (3
clock cycles) than SWI 06h.</p>
<h3 id=swi-08h-gba-or-swi-0dh-nds7nds9dsi7dsi9---sqrt>SWI 08h (GBA) or SWI 0Dh (NDS7/NDS9/DSi7/DSi9) - Sqrt</h3>
<p>Calculate square root.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0   unsigned 32bit number
</code></pre></div></div>
<p>Return:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0   unsigned 16bit number
</code></pre></div></div>
<p>The result is an integer value, so Sqrt(2) would return 1, to avoid this
inaccuracy, shift left incoming number by 2*N as much as possible (the result
is then shifted left by 1*N). Ie. Sqrt(2 shl 30) would return 1.41421 shl 15.</p>
<p>Note: The NDS9 and DSi9 additionally support hardware square root calculation,
by math coprocessor, accessed via I/O Ports, however, the SWI function is a raw
software calculation.</p>
<h3 id=swi-09h-gba---arctan>SWI 09h (GBA) - ArcTan</h3>
<p>Calculates the arc tangent.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0   Tan, 16bit (1bit sign, 1bit integral part, 14bit decimal part)
</code></pre></div></div>
<p>Return:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0   "-PI/2&lt;THETA/&lt;PI/2" in a range of C000h-4000h.
</code></pre></div></div>
<p>Note: there is a problem in accuracy with “THETA&lt;-PI/4, PI/4&lt;THETA”.</p>
<h3 id=swi-0ah-gba---arctan2>SWI 0Ah (GBA) - ArcTan2</h3>
<p>Calculates the arc tangent after correction processing.</p>
<p>Use this in normal situations.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0   X, 16bit (1bit sign, 1bit integral part, 14bit decimal part)
  r1   Y, 16bit (1bit sign, 1bit integral part, 14bit decimal part)
</code></pre></div></div>
<p>Return:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0   0000h-FFFFh for 0&lt;=THETA&lt;2PI.
</code></pre></div></div>
<h2 id=--bios-rotationscaling-functions><a name=biosrotationscalingfunctions></a> BIOS Rotation/Scaling Functions</h2>
<p>BgAffineSet</p>
<p>ObjAffineSet</p>
<h3 id=swi-0eh-gba---bgaffineset>SWI 0Eh (GBA) - BgAffineSet</h3>
<p>Used to calculate BG Rotation/Scaling parameters.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0   Pointer to Source Data Field with entries as follows:
        s32  Original data's center X coordinate (8bit fractional portion)
        s32  Original data's center Y coordinate (8bit fractional portion)
        s16  Display's center X coordinate
        s16  Display's center Y coordinate
        s16  Scaling ratio in X direction (8bit fractional portion)
        s16  Scaling ratio in Y direction (8bit fractional portion)
        u16  Angle of rotation (8bit fractional portion) Effective Range 0-FFFF
  r1   Pointer to Destination Data Field with entries as follows:
        s16  Difference in X coordinate along same line
        s16  Difference in X coordinate along next line
        s16  Difference in Y coordinate along same line
        s16  Difference in Y coordinate along next line
        s32  Start X coordinate
        s32  Start Y coordinate
  r2   Number of Calculations
</code></pre></div></div>
<p>Return: No return value, Data written to destination address.</p>
<h3 id=swi-0fh-gba---objaffineset>SWI 0Fh (GBA) - ObjAffineSet</h3>
<p>Calculates and sets the OBJ’s affine parameters from the scaling ratio and
angle of rotation.</p>
<p>The affine parameters are calculated from the parameters set in Srcp.</p>
<p>The four affine parameters are set every Offset bytes, starting from the Destp
address.</p>
<p>If the Offset value is 2, the parameters are stored contiguously. If the value
is 8, they match the structure of OAM.</p>
<p>When Srcp is arrayed, the calculation can be performed continuously by
specifying Num.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0   Source Address, pointing to data structure as such:
        s16  Scaling ratio in X direction (8bit fractional portion)
        s16  Scaling ratio in Y direction (8bit fractional portion)
        u16  Angle of rotation (8bit fractional portion) Effective Range 0-FFFF
  r1   Destination Address, pointing to data structure as such:
        s16  Difference in X coordinate along same line
        s16  Difference in X coordinate along next line
        s16  Difference in Y coordinate along same line
        s16  Difference in Y coordinate along next line
  r2   Number of calculations
  r3   Offset in bytes for parameter addresses (2=continuous, 8=OAM)
</code></pre></div></div>
<p>Return: No return value, Data written to destination address.</p>
<p>For both Bg- and ObjAffineSet, Rotation angles are specified as 0-FFFFh
(covering a range of 360 degrees), however, the GBA BIOS recurses only the
upper 8bit; the lower 8bit may contain a fractional portion, but it is ignored
by the BIOS.</p>
<h2 id=--bios-decompression-functions><a name=biosdecompressionfunctions></a> BIOS Decompression Functions</h2>
<p>BitUnPack</p>
<p>Diff8bitUnFilter</p>
<p>HuffUnComp</p>
<p>LZ77UnComp</p>
<p>RLUnComp</p>
<h3 id=decompression-readwrite-variants>Decompression Read/Write Variants</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  ReadNormal:      Fast (src must be memory mapped)
  ReadByCallback:  Slow (src can be non-memory, eg. serial Firmware SPI bus)
  Write8bitUnits:  Fast (dest must support 8bit writes, eg. not VRAM)
  Write16bitUnits: Slow (dest must be halfword-aligned) (for VRAM)
</code></pre></div></div>
<h3 id=bitunpack---swi-10h-gbands7nds9dsi7dsi9>BitUnPack - SWI 10h (GBA/NDS7/NDS9/DSi7/DSi9)</h3>
<p>Used to increase the color depth of bitmaps or tile data. For example, to
convert a 1bit monochrome font into 4bit or 8bit GBA tiles. The Unpack Info is
specified separately, allowing to convert the same source data into different
formats.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Source Address      (no alignment required)
  r1  Destination Address (must be 32bit-word aligned)
  r2  Pointer to UnPack information:
       16bit  Length of Source Data in bytes     (0-FFFFh)
       8bit   Width of Source Units in bits      (only 1,2,4,8 supported)
       8bit   Width of Destination Units in bits (only 1,2,4,8,16,32 supported)
       32bit  Data Offset (Bit 0-30), and Zero Data Flag (Bit 31)
      The Data Offset is always added to all non-zero source units.
      If the Zero Data Flag was set, it is also added to zero units.
</code></pre></div></div>
<p>Data is written in 32bit units, Destination can be Wram or Vram. The size of
unpacked data must be a multiple of 4 bytes. The width of source units (plus
the offset) should not exceed the destination width.</p>
<p>Return: No return value, Data written to destination address.</p>
<h3 id=diff8bitunfilterwrite8bit-wram---swi-16h-gbands9dsi9>Diff8bitUnFilterWrite8bit (Wram) - SWI 16h (GBA/NDS9/DSi9)</h3>
<h3 id=diff8bitunfilterwrite16bit-vram---swi-17h-gba>Diff8bitUnFilterWrite16bit (Vram) - SWI 17h (GBA)</h3>
<h3 id=diff16bitunfilter---swi-18h-gbands9dsi9>Diff16bitUnFilter - SWI 18h (GBA/NDS9/DSi9)</h3>
<p>These aren’t actually real decompression functions, destination data will have
exactly the same size as source data. However, assume a bitmap or wave form to
contain a stream of increasing numbers such like 10..19, the
filtered/unfiltered data would be:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  unfiltered:   10  11  12  13  14  15  16  17  18  19
  filtered:     10  +1  +1  +1  +1  +1  +1  +1  +1  +1
</code></pre></div></div>
<p>In this case using filtered data (combined with actual compression algorithms)
will obviously produce better compression results.</p>
<p>Data units may be either 8bit or 16bit used with Diff8bit or Diff16bit
functions respectively.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Source address (must be aligned by 4) pointing to data as follows:
       Data Header (32bit)
         Bit 0-3   Data size (must be 1 for Diff8bit, 2 for Diff16bit)
         Bit 4-7   Type (must be 8 for DiffFiltered)
         Bit 8-31  24bit size after decompression
       Data Units (each 8bit or 16bit depending on used SWI function)
         Data0          ;original data
         Data1-Data0    ;difference data
         Data2-Data1    ;...
         Data3-Data2
         ...
  r1  Destination address
</code></pre></div></div>
<p>Return: No return value, Data written to destination address.</p>
<h3 id=huffuncompreadnormal---swi-13h-gba>HuffUnCompReadNormal - SWI 13h (GBA)</h3>
<h3 id=huffuncompreadbycallback---swi-13h-ndsdsi>HuffUnCompReadByCallback - SWI 13h (NDS/DSi)</h3>
<p>The decoder starts in root node, the separate bits in the bitstream specify if
the next node is node0 or node1, if that node is a data node, then the data is
stored in memory, and the decoder is reset to the root node. The most often
used data should be as close to the root node as possible. For example, the
4-byte string “Huff” could be compressed to 6 bits: 10-11-0-0, with root.0
pointing directly to data “f”, and root.1 pointing to a child node, whose nodes
point to data “H” and data “u”.</p>
<p>Data is written in units of 32bits, if the size of the compressed data is not a
multiple of 4, please adjust it as much as possible by padding with 0.</p>
<p>Align the source address to a 4Byte boundary.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Source Address, aligned by 4, pointing to:
       Data Header (32bit)
         Bit0-3   Data size in bit units (normally 4 or 8)
         Bit4-7   Compressed type (must be 2 for Huffman)
         Bit8-31  24bit size of decompressed data in bytes
       Tree Size (8bit)
         Bit0-7   Size of Tree Table/2-1 (ie. Offset to Compressed Bitstream)
       Tree Table (list of 8bit nodes, starting with the root node)
        Root Node and Non-Data-Child Nodes are:
         Bit0-5   Offset to next child node,
                  Next child node0 is at (CurrentAddr AND NOT 1)+Offset*2+2
                  Next child node1 is at (CurrentAddr AND NOT 1)+Offset*2+2+1
         Bit6     Node1 End Flag (1=Next child node is data)
         Bit7     Node0 End Flag (1=Next child node is data)
        Data nodes are (when End Flag was set in parent node):
         Bit0-7   Data (upper bits should be zero if Data Size is less than 8)
       Compressed Bitstream (stored in units of 32bits)
         Bit0-31  Node Bits (Bit31=First Bit)  (0=Node0, 1=Node1)
  r1  Destination Address
  r2  Callback temp buffer      ;\for NDS/DSi "ReadByCallback" variants only
  r3  Callback structure        ;/(see Callback notes below)
</code></pre></div></div>
<p>Return: No return value, Data written to destination address.</p>
<h3 id=lz77uncompreadnormalwrite8bit-wram---swi-11h-gbands7nds9dsi7dsi9>LZ77UnCompReadNormalWrite8bit (Wram) - SWI 11h (GBA/NDS7/NDS9/DSi7/DSi9)</h3>
<h3 id=lz77uncompreadnormalwrite16bit-vram---swi-12h-gba>LZ77UnCompReadNormalWrite16bit (Vram) - SWI 12h (GBA)</h3>
<h3 id=lz77uncompreadbycallbackwrite8bit---swi-01h-dsi7dsi9>LZ77UnCompReadByCallbackWrite8bit - SWI 01h (DSi7/DSi9)</h3>
<h3 id=lz77uncompreadbycallbackwrite16bit---swi-12h-nds-swi-02h-or-19h-dsi>LZ77UnCompReadByCallbackWrite16bit - SWI 12h (NDS), SWI 02h or 19h (DSi)</h3>
<p>Expands LZ77-compressed data. The Wram function is faster, and writes in units
of 8bits. For the Vram function the destination must be halfword aligned, data
is written in units of 16bits.</p>
<p>CAUTION: Writing 16bit units to [dest-1] instead of 8bit units to [dest] means
that reading from [dest-1] won’t work, ie. the “Vram” function works only with
disp=001h..FFFh, but not with disp=000h.</p>
<p>If the size of the compressed data is not a multiple of 4, please adjust it as
much as possible by padding with 0. Align the source address to a 4-Byte
boundary.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Source address, pointing to data as such:
       Data header (32bit)
         Bit 0-3   Reserved
         Bit 4-7   Compressed type (must be 1 for LZ77)
         Bit 8-31  Size of decompressed data
       Repeat below. Each Flag Byte followed by eight Blocks.
       Flag data (8bit)
         Bit 0-7   Type Flags for next 8 Blocks, MSB first
       Block Type 0 - Uncompressed - Copy 1 Byte from Source to Dest
         Bit 0-7   One data byte to be copied to dest
       Block Type 1 - Compressed - Copy N+3 Bytes from Dest-Disp-1 to Dest
         Bit 0-3   Disp MSBs
         Bit 4-7   Number of bytes to copy (minus 3)
         Bit 8-15  Disp LSBs
  r1  Destination address
  r2  Callback parameter        ;\for NDS/DSi "ReadByCallback" variants only
  r3  Callback structure        ;/(see Callback notes below)
</code></pre></div></div>
<p>Return: No return value.</p>
<h3 id=rluncompreadnormalwrite8bit-wram---swi-14h-gbands7nds9dsi7dsi9>RLUnCompReadNormalWrite8bit (Wram) - SWI 14h (GBA/NDS7/NDS9/DSi7/DSi9)</h3>
<h3 id=rluncompreadnormalwrite16bit-vram---swi-15h-gba>RLUnCompReadNormalWrite16bit (Vram) - SWI 15h (GBA)</h3>
<h3 id=rluncompreadbycallbackwrite16bit---swi-15h-nds7nds9dsi7dsi9>RLUnCompReadByCallbackWrite16bit - SWI 15h (NDS7/NDS9/DSi7/DSi9)</h3>
<p>Expands run-length compressed data. The Wram function is faster, and writes in
units of 8bits. For the Vram function the destination must be halfword aligned,
data is written in units of 16bits.</p>
<p>If the size of the compressed data is not a multiple of 4, please adjust it as
much as possible by padding with 0. Align the source address to a 4Byte
boundary.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Source Address, pointing to data as such:
       Data header (32bit)
         Bit 0-3   Reserved
         Bit 4-7   Compressed type (must be 3 for run-length)
         Bit 8-31  Size of decompressed data
       Repeat below. Each Flag Byte followed by one or more Data Bytes.
       Flag data (8bit)
         Bit 0-6   Expanded Data Length (uncompressed N-1, compressed N-3)
         Bit 7     Flag (0=uncompressed, 1=compressed)
       Data Byte(s) - N uncompressed bytes, or 1 byte repeated N times
  r1  Destination Address
  r2  Callback parameter        ;\for NDS/DSi "ReadByCallback" variants only
  r3  Callback structure        ;/(see Callback notes below)
</code></pre></div></div>
<p>Return: No return value, Data written to destination address.</p>
<h2 id=--bios-memory-copy><a name=biosmemorycopy></a> BIOS Memory Copy</h2>
<p>CpuFastSet</p>
<p>CpuSet</p>
<h3 id=swi-0ch-gbands7nds9dsi7dsi9---cpufastset>SWI 0Ch (GBA/NDS7/NDS9/DSi7/DSi9) - CpuFastSet</h3>
<p>Memory copy/fill in units of 32 bytes. Memcopy is implemented as repeated
LDMIA/STMIA [Rb]!,r2-r9 instructions. Memfill as single LDR followed by
repeated STMIA [Rb]!,r2-r9.</p>
<p>After processing all 32-byte-blocks, the NDS/DSi additonally processes the
remaining words as 4-byte blocks. BUG: The NDS/DSi uses the fast 32-byte-block
processing only for the first N bytes (not for the first N words), so only the
first quarter of the memory block is FAST, the remaining three quarters are
SLOWLY copied word-by-word.</p>
<p>The length is specifed as wordcount, ie. the number of bytes divided by 4.</p>
<p>On the GBA, the length should be a multiple of 8 words (32 bytes) (otherwise
the GBA is forcefully rounding-up the length). On NDS/DSi, the length may be
any number of words (4 bytes).</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0    Source address        (must be aligned by 4)
  r1    Destination address   (must be aligned by 4)
  r2    Length/Mode
          Bit 0-20  Wordcount (GBA: rounded-up to multiple of 8 words)
          Bit 24    Fixed Source Address (0=Copy, 1=Fill by WORD[r0])
</code></pre></div></div>
<p>Return: No return value, Data written to destination address.</p>
<h3 id=swi-0bh-gbands7nds9dsi7dsi9---cpuset>SWI 0Bh (GBA/NDS7/NDS9/DSi7/DSi9) - CpuSet</h3>
<p>Memory copy/fill in units of 4 bytes or 2 bytes. Memcopy is implemented as
repeated LDMIA/STMIA [Rb]!,r3 or LDRH/STRH r3,[r0,r5] instructions. Memfill as
single LDMIA or LDRH followed by repeated STMIA [Rb]!,r3 or STRH r3,[r0,r5].</p>
<p>The length must be a multiple of 4 bytes (32bit mode) or 2 bytes (16bit mode).
The (half)wordcount in r2 must be length/4 (32bit mode) or length/2 (16bit
mode), ie. length in word/halfword units rather than byte units.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0    Source address        (must be aligned by 4 for 32bit, by 2 for 16bit)
  r1    Destination address   (must be aligned by 4 for 32bit, by 2 for 16bit)
  r2    Length/Mode
          Bit 0-20  Wordcount (for 32bit), or Halfwordcount (for 16bit)
          Bit 24    Fixed Source Address (0=Copy, 1=Fill by {HALF}WORD[r0])
          Bit 26    Datasize (0=16bit, 1=32bit)
</code></pre></div></div>
<p>Return: No return value, Data written to destination address.</p>
<p>Note: On GBA, NDS7 and DSi7, these two functions will silently reject to do
anything if the source start or end addresses are reaching into the BIOS area.
The NDS9 and DSi9 don’t have such read-proctections.</p>
<h2 id=--bios-halt-functions><a name=bioshaltfunctions></a> BIOS Halt Functions</h2>
<p>Halt</p>
<p>IntrWait</p>
<p>VBlankIntrWait</p>
<p>Stop/Sleep</p>
<p>CustomHalt</p>
<h3 id=swi-02h-gba-or-swi-06h-nds7nds9dsi7dsi9---halt>SWI 02h (GBA) or SWI 06h (NDS7/NDS9/DSi7/DSi9) - Halt</h3>
<p>Halts the CPU until an interrupt request occurs. The CPU is switched into
low-power mode, all other circuits (video, sound, timers, serial, keypad,
system clock) are kept operating.</p>
<p>Halt mode is terminated when any enabled interrupts are requested, that is when
(IE AND IF) is not zero, the GBA locks up if that condition doesn’t get true.
However, the state of CPUs IRQ disable bit in CPSR register, and the IME
register are don’t care, Halt passes through even if either one has disabled
interrupts.</p>
<p>On GBA and NDS7/DSi7, Halt is implemented by writing to HALTCNT, Port 4000301h.
On NDS9/DSi9, Halt is implemted by writing to System Control Coprocessor (mov
p15,0,c7,c0,4,r0 opcode), this opcode hangs if IME=0.</p>
<p>No parameters, no return value.</p>
<p>(GBA/NDS7/DSi7: all registers unchanged, NDS9/DSi9: R0 destroyed)</p>
<h3 id=swi-04h-gbands7nds9dsi7dsi9---intrwait-dsi7dsi9bugged>SWI 04h (GBA/NDS7/NDS9/DSi7/DSi9) - IntrWait ;DSi7/DSi9=bugged?</h3>
<p>Continues to wait in Halt state until one (or more) of the specified
interrupt(s) do occur. The function forcefully sets IME=1. When using multiple
interrupts at the same time, this function is having less overhead than
repeatedly calling the Halt function.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0    0=Return immediately if an old flag was already set (NDS9: bugged!)
        1=Discard old flags, wait until a NEW flag becomes set
  r1    Interrupt flag(s) to wait for (same format as IE/IF registers)
  r2    DSi7 only: Extra flags (same format as DSi7's IE2/IF2 registers)
</code></pre></div></div>
<p>Caution: When using IntrWait or VBlankIntrWait, the user interrupt handler MUST
update the BIOS Interrupt Flags value in RAM; when acknowleding processed
interrupt(s) by writing a value to the IF register, the same value should be
also ORed to the BIOS Interrupt Flags value, at following memory location:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Host     GBA (16bit)  NDS7 (32bit)  NDS9 (32bit)  DSi7-IF2 (32bit)
  Address  [3007FF8h]   [380FFF8h]    [DTCM+3FF8h]  [380FFC0h]
</code></pre></div></div>
<p>NDS9: BUG: No Discard (r0=0) doesn’t work. The function always waits for at
least one IRQ to occur (no matter which, including IRQs that are not selected
in r1), even if the desired flag was already set. NB. the same bug is also
found in the GBA/NDS7 functions, but it’s compensated by a second bug, ie. the
GBA/NDS7 functions are working okay because their “bug doesn’t work”.</p>
<p>Return: No return value, the selected flag(s) are automatically reset in BIOS
Interrupt Flags value in RAM upon return.</p>
<p>DSi9: BUG: The function tries to enter Halt state via Port 4000301h (which
would be okay on ARM7, but it’s probably ignored on ARM9, which should normally
use CP15 to enter Halt state; if Port 4000301h is really ignored, then the
function will “successfully” wait for interrupts, but without actually entering
any kind of low power mode).</p>
<p>DSi7: BUG: The function tries to wait for IF and IF2 interrupts, but it does
accidently ignore the old IF interrupts, and works only with new IF2 ones.</p>
<h3 id=swi-05h-gbands7nds9dsi7dsi9---vblankintrwait-dsi7dsi9bugged>SWI 05h (GBA/NDS7/NDS9/DSi7/DSi9) - VBlankIntrWait ;DSi7/DSi9=bugged?</h3>
<p>Continues to wait in Halt status until a new V-Blank interrupt occurs.</p>
<p>The function sets r0=1 and r1=1 (plus r2=0 on DSi7) and does then execute
IntrWait (SWI 04h), see IntrWait for details.</p>
<p>No parameters, no return value.</p>
<h3 id=swi-03h-gba---stop>SWI 03h (GBA) - Stop</h3>
<p>Switches the GBA into very low power mode (to be used similar as a
screen-saver). The CPU, System Clock, Sound, Video, SIO-Shift Clock, DMAs, and
Timers are stopped.</p>
<p>Stop state can be terminated by the following interrupts only (as far as
enabled in IE register): Joypad, Game Pak, or General-Purpose-SIO.</p>
<p>“The system clock is stopped so the IF flag is not set.”</p>
<p>Preparation for Stop:</p>
<p>Disable Video before implementing Stop (otherwise Video just freezes, but still
keeps consuming battery power). Possibly required to disable Sound also?
Obviously, it’d be also recommended to disable any external hardware (such like
Rumble or Infra-Red) as far as possible.</p>
<p>No parameters, no return value.</p>
<h3 id=swi-07h-nds7dsi7---sleep>SWI 07h (NDS7/DSi7) - Sleep</h3>
<p>No info, probably similar as GBA SWI 03h (Stop). Sleep is implemented for ARM7
only, not for ARM9. But maybe the ARM7 function does stop &lt;both&gt; ARM7 and
ARM9 (?)</p>
<h3 id=swi-27h-gba-or-swi-1fh-nds7dsi7---customhalt-undocumented>SWI 27h (GBA) or SWI 1Fh (NDS7/DSi7) - CustomHalt (Undocumented)</h3>
<p>Writes the 8bit parameter value to HALTCNT, below values are equivalent to Halt
and Stop/Sleep functions, other values reserved, purpose unknown.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r2  8bit parameter (GBA: 00h=Halt, 80h=Stop) (NDS7/DSi7: 80h=Halt, C0h=Sleep)
</code></pre></div></div>
<p>No return value.</p>
<h2 id=--bios-reset-functions><a name=biosresetfunctions></a> BIOS Reset Functions</h2>
<p>SoftReset</p>
<p>RegisterRamReset</p>
<p>HardReset</p>
<h3 id=swi-00h-gbands7nds9---softreset>SWI 00h (GBA/NDS7/NDS9) - SoftReset</h3>
<p>Clears 200h bytes of RAM (containing stacks, and BIOS IRQ vector/flags),
initializes system, supervisor, and irq stack pointers, sets R0-R12, LR_svc,
SPSR_svc, LR_irq, and SPSR_irq to zero, and enters system mode.</p>
<p>Note that the NDS9 stack registers are hardcoded (the DTCM base should be set
to the default setting of 0800000h). The NDS9 function additionally flushes
caches and write buffer, and sets the CP15 control register to 12078h.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Host  sp_svc    sp_irq    sp_sys    zerofilled area       return address
  GBA   3007FE0h  3007FA0h  3007F00h  [3007E00h..3007FFFh]  Flag[3007FFAh]
  NDS7  380FFDCh  380FFB0h  380FF00h  [380FE00h..380FFFFh]  Addr[27FFE34h]
  NDS9  0803FC0h  0803FA0h  0803EC0h  [DTCM+3E00h..3FFFh]   Addr[27FFE24h]
</code></pre></div></div>
<p>The NDS7/NDS9 return addresses at [27FFE34h/27FFE24h] are usually containing
copies of Cartridge Header [034h/024h] entry points, which may select ARM/THUMB
state via bit0. The GBA return address 8bit flag is interpreted as 00h=8000000h
(ROM), or 01h-FFh=2000000h (RAM), entered in ARM state.</p>
<p>Note: The reset is applied only to the CPU that has executed the SWI (ie. on
the NDS, the other CPU will remain unaffected).</p>
<p>Return: Does not return to calling procedure, instead, loads the above return
address into R14, and then jumps to that address by a “BX R14” opcode.</p>
<h3 id=swi-01h-gba---registerramreset>SWI 01h (GBA) - RegisterRamReset</h3>
<p>Resets the I/O registers and RAM specified in ResetFlags. However, it does not
clear the CPU internal RAM area from 3007E00h-3007FFFh.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  ResetFlags
       Bit   Expl.
       0     Clear 256K on-board WRAM  ;-don't use when returning to WRAM
       1     Clear 32K on-chip WRAM    ;-excluding last 200h bytes
       2     Clear Palette
       3     Clear VRAM
       4     Clear OAM              ;-zerofilled! does NOT disable OBJs!
       5     Reset SIO registers    ;-switches to general purpose mode!
       6     Reset Sound registers
       7     Reset all other registers (except SIO, Sound)
</code></pre></div></div>
<p>Return: No return value.</p>
<p>Bug: LSBs of SIODATA32 are always destroyed, even if Bit5 of R0 was cleared.</p>
<p>The function always switches the screen into forced blank by setting
DISPCNT=0080h (regardless of incoming R0, screen becomes white).</p>
<h3 id=swi-26h-gba---hardreset-undocumented>SWI 26h (GBA) - HardReset (Undocumented)</h3>
<p>This function reboots the GBA (including for getting through the time-consuming
nintendo intro, which is making the function particularly useless and
annoying).</p>
<p>Parameters: None. Return: Never/Reboot.</p>
<p>Execution Time: About 2 seconds (!)</p>
<h2 id=--bios-misc-functions><a name=biosmiscfunctions></a> BIOS Misc Functions</h2>
<p>GetBiosChecksum</p>
<p>WaitByLoop</p>
<p>GetCRC16</p>
<p>IsDebugger</p>
<p>GetSineTable</p>
<p>GetPitchTable</p>
<p>GetVolumeTable</p>
<p>CustomPost</p>
<p>GetBootProcs</p>
<h3 id=swi-0dh-gba---getbioschecksum-undocumented>SWI 0Dh (GBA) - GetBiosChecksum (Undocumented)</h3>
<p>Calculates the checksum of the BIOS ROM (by reading in 32bit units, and adding
up these values). IRQ and FIQ are disabled during execution.</p>
<p>The checksum is BAAE187Fh (GBA and GBA SP), or BAAE1880h (DS in GBA mode,
whereas the only difference is that the byte at [3F0Ch] is changed from 00h to
01h, otherwise the BIOS is 1:1 same as GBA BIOS, it does even include multiboot
code).</p>
<p>Parameters: None. Return: r0=Checksum.</p>
<h3 id=swi-03h-nds7nds9dsi7dsi9---waitbyloop>SWI 03h (NDS7/NDS9/DSi7/DSi9) - WaitByLoop</h3>
<p>Performs a “LOP: SUB R0,1 / BGT LOP” wait loop, the loop is executed in BIOS
memory, which provides reliable timings (regardless of the memory waitstates
&amp; cache state of the calling procedure). Intended only for short delays
(eg. flash memory programming cycles).</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Delay value (should be in range 1..7FFFFFFFh)
</code></pre></div></div>
<p>Execution time varies for ARM7 vs ARM9. On ARM9 it does also depend on whether
ROM is cached, and on DSi it does further depended on the ARM9 CPU clock, and
on whether using NDS or DSi BIOS ROM (NDS uses faster THUMB code, whilst DSi
uses ARM code, which is slow on uncached ARM9 ROM reads). For example, to get a
1 millisecond delay, use following values:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  CPU  Clock     Cache   BIOS     Value for 1ms
  ARM7 33.51MHz  none    NDS/DSi  r0=20BAh    ;=20BAh  ;-ARM7
  ARM9 67.03MHz  on      NDS/DSi  r0=20BAh*2  ;=4174h  ;\ARM9 with cache
  ARM9 134.06MHz on      DSi      r0=20BAh*4  ;=82E8h  ;/
  ARM9 67.03MHz  off     NDS      r0=20BAh/2  ;=105Dh  ;\
  ARM9 67.03MHz  off     DSi      r0=20BAh/4  ;=082Eh  ; ARM9 without cache
  ARM9 134.06MHz off     DSi      r0=20BAh/3  ;=0AE8h  ;/
</code></pre></div></div>
<p>Return: No return value.</p>
<h3 id=swi-0eh-nds7nds9dsi7dsi9---getcrc16>SWI 0Eh (NDS7/NDS9/DSi7/DSi9) - GetCRC16</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Initial CRC value (16bit, usually FFFFh)
  r1  Start Address   (must be aligned by 2)
  r2  Length in bytes (must be aligned by 2)
</code></pre></div></div>
<p>CRC16 checksums can be calculated as such:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  val[0..7] = C0C1h,C181h,C301h,C601h,CC01h,D801h,F001h,A001h
  for i=start to end
    crc=crc xor byte[i]
    for j=0 to 7
      crc=crc shr 1:if carry then crc=crc xor (val[j] shl (7-j))
    next j
  next i
</code></pre></div></div>
<p>Return:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Calculated 16bit CRC Value
</code></pre></div></div>
<p>Additionally, if the length is nonzero, r3 contains the last processed halfword
at [addr+len-2]. Unlike most other NDS7/DSi7 SWI functions (which do reject
reading from BIOS memory), this allows to dump the NDS7/DSi7 BIOS (except for
the memory region that is locked via BIOSPROT Port 4000308h).</p>
<h3 id=swi-0fh-nds7nds9---isdebugger>SWI 0Fh (NDS7/NDS9) - IsDebugger</h3>
<p>Detects if 4MB (normal) or 8MB (debug version) Main RAM installed.</p>
<p>Caution: Fails on ARM9 when cache is enabled (always returns 8MB state).</p>
<p>Return: r0 = result (0=normal console 4MB, 1=debug version 8MB)</p>
<p>Destroys halfword at [27FFFFAh] (NDS7) or [27FFFF8h] (NDS9)!</p>
<p>The SWI 0Fh function doesn’t work stable if it gets interrupted by an interrupt
which is calling SWI 0Fh, which would destroy the above halfword scratch value
(unless the IRQ handler has saved/restored the halfword).</p>
<h3 id=swi-1ah-nds7dsi7---getsinetable>SWI 1Ah (NDS7/DSi7) - GetSineTable</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Index (0..3Fh) (must be in that range, otherwise returns garbage)
</code></pre></div></div>
<p>Return: r0 = Desired Entry (0000h..7FF5h) ;SIN(0 .. 88.6 degrees)*8000h</p>
<h3 id=swi-1bh-nds7dsi7---getpitchtable-dsi7-bugged>SWI 1Bh (NDS7/DSi7) - GetPitchTable (DSi7: bugged)</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Index (0..2FFh) (must be in that range, otherwise returns garbage)
</code></pre></div></div>
<p>BUG: DSi7 accidently reads from SineTable instead of PitchTable, as workaround
for obtaining PitchTable values, one can set “r0=(0..2FFh)-46Ah” on DSi.</p>
<p>Return: r0 = Desired Entry (0000h..FF8Ah) (unsigned)</p>
<h3 id=swi-1ch-nds7dsi7---getvolumetable>SWI 1Ch (NDS7/DSi7) - GetVolumeTable</h3>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Index (0..2D3h) (must be in that range, otherwise returns garbage)
</code></pre></div></div>
<p>Return: r0 = Desired Entry (00h..7Fh) (unsigned)</p>
<h3 id=swi-1fh-nds9dsi9---custompost>SWI 1Fh (NDS9/DSi9) - CustomPost</h3>
<p>Writes to the POSTFLG register, probably for use by Firmware boot procedure.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  32bit value, to be written to POSTFLG, Port 4000300h
</code></pre></div></div>
<p>Return: No return value.</p>
<h3 id=swi-1dh-nds7dsi7---getbootprocs>SWI 1Dh (NDS7/DSi7) - GetBootProcs</h3>
<p>Returns addresses of Gamecart boot procedure/interrupt handler, probably for
use by Firmware boot procedure. Most of the returned NDS7 functions won’t work
if the POSTFLG register is set.</p>
<p>The return values are somewhat XORed by each other (on DSi7 most of the values
are zero; which does rather negate the XORing effect, and, as a special
gimmick, one of the zero values is XORed by incoming r2).</p>
<h2 id=--bios-multi-boot-single-game-pak><a name=biosmultibootsinglegamepak></a> BIOS Multi Boot (Single Game Pak)</h2>
<p>MultiBoot</p>
<h3 id=swi-25h-gba---multiboot>SWI 25h (GBA) - MultiBoot</h3>
<p>This function uploads &amp; starts program code to slave GBAs, allowing to
launch programs on slave units even if no cartridge is inserted into the slaves
(this works because all GBA BIOSes contain built-in download procedures in
ROM).</p>
<p>However, the SWI 25h BIOS upload function covers only 45% of the required
Transmission Protocol, the other 55% must be coded in the master cartridge (see
Transmission Protocol below).</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Pointer to MultiBootParam structure
  r1  Transfer Mode (undocumented)
       0=256KHz, 32bit, Normal mode    (fast and stable)
       1=115KHz, 16bit, MultiPlay mode (default, slow, up to three slaves)
       2=2MHz,   32bit, Normal mode    (fastest but maybe unstable)
  Note: HLL-programmers that are using the MultiBoot(param_ptr) macro cannot
  specify the transfer mode and will be forcefully using MultiPlay mode.
</code></pre></div></div>
<p>Return:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  0=okay, 1=failed
</code></pre></div></div>
<p>See below for more details.</p>
<h3 id=multiboot-parameter-structure>Multiboot Parameter Structure</h3>
<p>Size of parameter structure should be 4Ch bytes (the current GBA BIOS uses only
first 44h bytes though). The following entries must be set before calling SWI
25h:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Addr Size Name/Expl.
  14h  1    handshake_data (entry used for normal mode only)
  19h  3    client_data[1,2,3]
  1Ch  1    palette_data
  1Eh  1    client_bit (Bit 1-3 set if child 1-3 detected)
  20h  4    boot_srcp  (typically 8000000h+0C0h)
  24h  4    boot_endp  (typically 8000000h+0C0h+length)
</code></pre></div></div>
<p>The transfer length (excluding header data) should be a multiple of 10h,
minimum length 100h, max 3FF40h (ca. 256KBytes). Set palette_data as
“81h+color*10h+direction*8+speed*2”, or as “0f1h+color*2” for fixed palette,
whereas color=0..6, speed=0..3, direction=0..1. The other entries
(handshake_data, client_data[1-3], and client_bit) must be same as specified in
Transmission Protocol (see below hh,cc,y).</p>
<h3 id=multiboot-transfer-protocol>Multiboot Transfer Protocol</h3>
<p>Below describes the complete transfer protocol, normally only the Initiation
part must be programmed in the master cartridge, the main data transfer can be
then performed by calling SWI 25h, the slave program is started after SWI 25h
completion.</p>
<p>The ending handshake is normally not required, when using it, note that you
will need custom code in BOTH master and slave programs.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  Times  Send   Receive  Expl.
  -----------------------Required Transfer Initiation in master program
  ...    6200   FFFF     Slave not in multiplay/normal mode yet
  1      6200   0000     Slave entered correct mode now
  15     6200   720x     Repeat 15 times, if failed: delay 1/16s and restart
  1      610y   720x     Recognition okay, exchange master/slave info
  60h    xxxx   NN0x     Transfer C0h bytes header data in units of 16bits
  1      6200   000x     Transfer of header data completed
  1      620y   720x     Exchange master/slave info again
  ...    63pp   720x     Wait until all slaves reply 73cc instead 720x
  1      63pp   73cc     Send palette_data and receive client_data[1-3]
  1      64hh   73uu     Send handshake_data for final transfer completion
  -----------------------Below is SWI 25h MultiBoot handler in BIOS
  DELAY  -      -        Wait 1/16 seconds at master side
  1      llll   73rr     Send length information and receive random data[1-3]
  LEN    yyyy   nnnn     Transfer main data block in units of 16 or 32 bits
  1      0065   nnnn     Transfer of main data block completed, request CRC
  ...    0065   0074     Wait until all slaves reply 0075 instead 0074
  1      0065   0075     All slaves ready for CRC transfer
  1      0066   0075     Signalize that transfer of CRC follows
  1      zzzz   zzzz     Exchange CRC must be same for master and slaves
  -----------------------Optional Handshake (NOT part of master/slave BIOS)
  ...    ....   ....     Exchange whatever custom data
</code></pre></div></div>
<p>Legend for above Protocol</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  y     client_bit, bit(s) 1-3 set if slave(s) 1-3 detected
  x     bit 1,2,or 3 set if slave 1,2,or 3
  xxxx  header data, transferred in 16bit (!) units (even in 32bit normal mode)
  nn    response value for header transfer, decreasing 60h..01h
  pp    palette_data
  cc    random client_data[1..3] from slave 1-3, FFh if slave not exists
  hh    handshake_data, 11h+client_data[1]+client_data[2]+client_data[3]
  uu    random data, not used, ignore this value
</code></pre></div></div>
<p>Below automatically calculated by SWI 25h BIOS function (don’t care about)</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  llll  download length/4-34h
  rr    random data from each slave for encryption, FFh if slave not exists
  yyyy  encoded data in 16bit (multiplay) or 32bit (normal mode) units
  nnnn  response value, lower 16bit of destadr in GBA memory (00C0h and up)
  zzzz  16bit download CRC value, must be same for master and slaves
</code></pre></div></div>
<p>Pseudo Code for SWI 25h Transfer with Checksum and Encryption calculations</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  if normal_mode    then c=C387h:x=C37Bh:k=43202F2Fh
  if multiplay_mode then c=FFF8h:x=A517h:k=6465646Fh
  m=dword(pp,cc,cc,cc):f=dword(hh,rr,rr,rr)
  for ptr=000000C0h to (file_size-4) step 4
    c=c xor data[ptr]:for i=1 to 32:c=c shr 1:if carry then c=c xor x:next
    m=(6F646573h*m)+1
    send_32_or_2x16 (data[ptr] xor (-2000000h-ptr) xor m xor k)
  next
  c=c xor f:for i=1 to 32:c=c shr 1:if carry then c=c xor x:next
  wait_all_units_ready_for_checksum:send_32_or_1x16 (c)
</code></pre></div></div>
<p>Whereas, explained: c=chksum,x=chkxor,f=chkfin,k=keyxor,m=keymul</p>
<h3 id=multiboot-communication>Multiboot Communication</h3>
<p>In Multiplay mode, master sends 16bit data, and receives 16bit data from each
slave (or FFFFh if none). In Normal mode, master sends 32bit data (upper 16bit
zero, lower 16bit as for multiplay mode), and receives 32bit data (upper 16bit
as for multiplay mode, and lower 16bit same as lower 16bit previously sent by
master). Because SIODATA32 occupies same addresses as SIOMULTI0-1, the same
transfer code can be used for both multiplay and normal mode (in normal mode
SIOMULTI2-3 should be forced to FFFFh though). After each transfer, master
should wait for Start bit cleared in SIOCNT register, followed by a 36us delay.</p>
<p>Note: The multiboot slave would also recognize data being sent in Joybus mode,
however, master GBAs cannot use joybus mode (because GBA hardware cannot act as
master in joybus mode).</p>
<h3 id=multiboot-slave-header>Multiboot Slave Header</h3>
<p>The transferred Header block is written to 2000000-20000BFh in slave RAM, the
header must contain valid data (identically as for normal ROM-cartridge
headers, including a copy of the Nintendo logo, correct header CRC, etc.), in
most cases it’d be recommended just to transfer a copy of the master cartridges
header from 8000000h-80000BFh.</p>
<h3 id=multiboot-slave-programdata>Multiboot Slave Program/Data</h3>
<p>The transferred main program/data block is written to 20000C0h and up (max
203FFFFh) in slave RAM, note that absolute addresses in the program must be
then originated at 2000000h rather than 8000000h. In case that the master
cartridge is 256K or less, it could just transfer a copy of the whole cartridge
at 80000C0h and up, the master should then copy &amp; execute its own ROM data
into RAM as well.</p>
<h3 id=multiboot-slave-extended-header>Multiboot Slave Extended Header</h3>
<p>For Multiboot slaves, separate Entry Point(s) must be defined at the beginning
of the Program/Data block (the Entry Point in the normal header is ignored),
also some reserved bytes in this section are overwritten by the Multiboot
procedure. For more information see chapter about Cartridge Header.</p>
<h3 id=multiboot-slave-with-cartridge>Multiboot Slave with Cartridge</h3>
<p>Beside for slaves without cartridge, multiboot can be also used for slaves
which do have a cartridge inserted, if so, SELECT and START must be kept held
down during power-on in order to switch the slave GBA into Multiboot mode (ie.
to prevent it from starting the cartridge as normally).</p>
<p>The general idea is to enable newer programs to link to any existing older GBA
programs, even if these older programs originally didn’t have been intended to
support linking.</p>
<p>The uploaded program may access the slaves SRAM, Flash ROM, or EEPROM (if any,
allowing to read out or modify slave game positions), as well as cartridge ROM
at 80000A0h-8000FFFh (the first 4KBytes, excluding the nintendo logo, allowing
to read out the cartridge name from the header, for example).</p>
<p>The main part of the cartridge ROM is meant to be locked out in order to
prevent software pirates from uploading “intruder” programs which would send
back a copy of the whole cartridge to the master, however, for good or evil, at
present time, current GBA models and GBA carts do not seem to contain any such
protection.</p>
<h3 id=uploading-programs-from-pc>Uploading Programs from PC</h3>
<p>Beside for the ability to upload a program from one GBA to another, this
feature can be also used to upload small programs from a PC to a GBA. For more
information see chapter about External Connectors.</p>
<h3 id=nintendo-ds>Nintendo DS</h3>
<p>The GBA multiboot function requires a link port, and so, works on GBA and GBA
SP only. The Nintendo DS in GBA mode does include the multiboot BIOS function,
but it won’t be of any use as the DS doesn’t have a link port.</p>
<h2 id=--bios-sound-functions><a name=biossoundfunctions></a> BIOS Sound Functions</h2>
<h3 id=swi-1fh-gba---midikey2freq>SWI 1Fh (GBA) - MidiKey2Freq</h3>
<p>Calculates the value of the assignment to ((SoundArea)sa).vchn[x].fr when
playing the wave data, wa, with the interval (MIDI KEY) mk and the fine
adjustment value (halftones=256) fp.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  WaveData* wa
  r1  u8 mk
  r2  u8 fp
</code></pre></div></div>
<p>Return:</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  u32
</code></pre></div></div>
<p>This function is particularly popular because it allows to read from BIOS
memory without copy protection range checks. The formula to read one byte (a)
from address (i, 0..3FFF) is:</p>
<p>a = (MidiKey2Freq(i-(((i AND 3)+1)OR 3), 168, 0) * 2) SHR 24</p>
<h3 id=swi-19h-gba-or-swi-08h-nds7dsi7---soundbias>SWI 19h (GBA) or SWI 08h (NDS7/DSi7) - SoundBias</h3>
<p>Increments or decrements the current level of the SOUNDBIAS register (with
short delays) until reaching the desired new level. The upper bits of the
register are kept unchanged.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0   BIAS level (0=Level 000h, any other value=Level 200h)
  r1   Delay Count (NDS/DSi only) (GBA uses a fixed delay count of 8)
</code></pre></div></div>
<p>Return: No return value.</p>
<h3 id=swi-1eh-gba---soundchannelclear>SWI 1Eh (GBA) - SoundChannelClear</h3>
<p>Clears all direct sound channels and stops the sound.</p>
<p>This function may not operate properly when the library which expands the sound
driver feature is combined afterwards. In this case, do not use it.</p>
<p>No parameters, no return value.</p>
<h3 id=swi-1ah-gba---sounddriverinit>SWI 1Ah (GBA) - SoundDriverInit</h3>
<p>Initializes the sound driver. Call this only once when the game starts up.</p>
<p>It is essential that the work area already be secured at the time this function
is called.</p>
<p>You cannot execute this driver multiple times, even if separate work areas have
been prepared.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Pointer to work area for sound driver, SoundArea structure as follows:
       SoundArea (sa) Structure
        u32    ident      Flag the system checks to see whether the
                          work area has been initialized and whether it
                          is currently being accessed.
        vu8    DmaCount   User access prohibited
        u8     reverb     Variable for applying reverb effects to direct sound
        u16    d1         User access prohibited
        void   (*func)()  User access prohibited
        int    intp       User access prohibited
        void*  NoUse      User access prohibited
        SndCh  vchn[MAX]  The structure array for controlling the direct
                          sound channels (currently 8 channels are
                          available). The term "channel" here does
                          not refer to hardware channels, but rather to
                          virtual constructs inside the sound driver.
        s8     pcmbuf[PCM_BF*2]
       SoundChannel Structure
        u8         sf     The flag indicating the status of this channel.
                          When 0 sound is stopped.
                          To start sound, set other parameters and
                          then write 80h to here.
                          To stop sound, logical OR 40h for a
                          release-attached off (key-off), or write zero
                          for a pause. The use of other bits is
                          prohibited.
        u8         r1     User access prohibited
        u8         rv     Sound volume output to right side
        u8         lv     Sound volume output to left side
        u8         at     The attack value of the envelope. When the
                          sound starts, the volume begins at zero and
                          increases every 1/60 second. When it
                          reaches 255, the process moves on to the
                          next decay value.
        u8         de     The decay value of the envelope. It is
                          multiplied by "this value/256" every 1/60
                          sec. and when sustain value is reached, the
                          process moves to the sustain condition.
        u8         su     The sustain value of the envelope. The
                          sound is sustained by this amount.
                          (Actually, multiplied by rv/256, lv/256 and
                          output left and right.)
        u8         re     The release value of the envelope. Key-off
                          (logical OR 40h in sf) to enter this state.
                          The value is multiplied by "this value/256"
                          every 1/60 sec. and when it reaches zero,
                          this channel is completely stopped.
        u8         r2[4]  User access prohibited
        u32        fr     The frequency of the produced sound.
                          Write the value obtained with the
                          MidiKey2Freq function here.
        WaveData*  wp     Pointer to the sound's waveform data. The waveform
                          data can be generated automatically from the AIFF
                          file using the tool (aif2agb.exe), so users normally
                          do not need to create this themselves.
        u32        r3[6]  User access prohibited
        u8         r4[4]  User access prohibited
       WaveData Structure
        u16   type    Indicates the data type. This is currently not used.
        u16   stat    At the present time, non-looped (1 shot) waveform
                      is 0000h and forward loop is 4000h.
        u32   freq    This value is used to calculate the frequency.
                      It is obtained using the following formula:
                      sampling rate x 2^((180-original MIDI key)/12)
        u32   loop    Loop pointer (start of loop)
        u32   size    Number of samples (end position)
        s8    data[]  The actual waveform data. Takes (number of samples+1)
                      bytes of 8bit signed linear uncompressed data. The last
                      byte is zero for a non-looped waveform, and the same
                      value as the loop pointer data for a looped waveform.
</code></pre></div></div>
<p>Return: No return value.</p>
<h3 id=swi-1ch-gba---sounddrivermain>SWI 1Ch (GBA) - SoundDriverMain</h3>
<p>Main of the sound driver.</p>
<p>Call every 1/60 of a second. The flow of the process is to call
SoundDriverVSync, which is explained later, immediately after the V-Blank
interrupt.</p>
<p>After that, this routine is called after BG and OBJ processing is executed.</p>
<p>No parameters, no return value.</p>
<h3 id=swi-1bh-gba---sounddrivermode>SWI 1Bh (GBA) - SoundDriverMode</h3>
<p>Sets the sound driver operation mode.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Sound driver operation mode
       Bit    Expl.
       0-6    Direct Sound Reverb value (0-127, default=0) (ignored if Bit7=0)
       7      Direct Sound Reverb set (0=ignore, 1=apply reverb value)
       8-11   Direct Sound Simultaneously-produced (1-12 channels, default 8)
       12-15  Direct Sound Master volume (1-15, default 15)
       16-19  Direct Sound Playback Frequency (1-12 = 5734,7884,10512,13379,
              15768,18157,21024,26758,31536,36314,40137,42048, def 4=13379 Hz)
       20-23  Final number of D/A converter bits (8-11 = 9-6bits, def. 9=8bits)
       24-31  Not used.
</code></pre></div></div>
<p>Return: No return value.</p>
<h3 id=swi-1dh-gba---sounddrivervsync>SWI 1Dh (GBA) - SoundDriverVSync</h3>
<p>An extremely short system call that resets the sound DMA. The timing is
extremely critical, so call this function immediately after the V-Blank
interrupt every 1/60 second.</p>
<p>No parameters, no return value.</p>
<h3 id=swi-28h-gba---sounddrivervsyncoff>SWI 28h (GBA) - SoundDriverVSyncOff</h3>
<p>Due to problems with the main program if the V-Blank interrupts are stopped,
and SoundDriverVSync cannot be called every 1/60 a second, this function must
be used to stop sound DMA.</p>
<p>Otherwise, even if you exceed the limit of the buffer the DMA will not stop and
noise will result.</p>
<p>No parameters, no return value.</p>
<h3 id=swi-29h-gba---sounddrivervsyncon>SWI 29h (GBA) - SoundDriverVSyncOn</h3>
<p>This function restarts the sound DMA stopped with the previously described
SoundDriverVSyncOff.</p>
<p>After calling this function, have a V-Blank occur within 2/60 of a second and
call SoundDriverVSync.</p>
<p>No parameters, no return value.</p>
<h3 id=swi-20h24h-gba---soundwhatever04-undocumented>SWI 20h..24h (GBA) - SoundWhatever0..4 (Undocumented)</h3>
<p>Whatever undocumented sound-related BIOS functions.</p>
<h3 id=swi-2ah-gba---soundgetjumplist-undocumented>SWI 2Ah (GBA) - SoundGetJumpList (Undocumented)</h3>
<p>Receives pointers to 36 additional sound-related BIOS functions.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  r0  Destination address (must be aligned by 4) (120h bytes buffer)
</code></pre></div></div>
<h2 id=--bios-ram-usage><a name=biosramusage></a> BIOS RAM Usage</h2>
<p>Below contains info about RAM contents at cartridge boot time (as initialized
by the BIOS/Firmware), plus info about RAM locations used by IRQ handlers and
SWI functions.</p>
<h3 id=gba-bios-ram-usage>GBA BIOS RAM Usage</h3>
<p>Below memory at 3007Fxxh is often accessed directly, or via mirrors at
3FFFFxxh.</p>
<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>  3000000h 7F00h User Memory and User Stack              (sp_usr=3007F00h)
  3007F00h A0h   Default Interrupt Stack (6 words/time)  (sp_irq=3007FA0h)
  3007FA0h 40h   Default Supervisor Stack (4 words/time) (sp_svc=3007FE0h)
  3007FE0h 10h   Debug Exception Stack (4 words/time)    (sp_xxx=3007FF0h)
  3007FF0h 4     Pointer to Sound Buffer (for SWI Sound functions)
  3007FF4h 3     Reserved (unused)
  3007FF7h 1     Reserved (intro/nintendo logo related)
  3007FF8h 2     IRQ IF Check Flags (for SWI IntrWait/VBlankIntrWait functions)
  3007FFAh 1     Soft Reset Re-entry Flag (for SWI SoftReset function)
  3007FFBh 1     Reserved (intro/multiboot slave related)
  3007FFCh 4     Pointer to user IRQ handler (to 32bit ARM code)
</code></pre></div></div>
